<!DOCTYPE html>
<html lang="en">
  <head>
    <link rel="icon" type="image/png" href="favicon.png">
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <!-- The above 3 meta tags *must* come first in the head; any other head content must come *after* these tags -->
    <title>Virtual File System (VFS) layer</title>
    <!-- jQuery (necessary for Bootstrap's JavaScript plugins) -->
    <script src="jquery.min.js"></script>
    <script src="jquery.powertip.min.js"></script>
    <script src="jquery-ui.min.js"></script>
    <script src="jquery.scrollTo.min.js"></script>
    <script src="doxy-jquery.js"></script>
    <script src="dynsections.js"></script>
    <link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
  $(document).ready(initResizable);
/* @license-end */</script>
    <link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
    <!-- Bootstrap -->
    <link href="doxygen.css" rel="stylesheet">
    <link href="fonts.css" rel="stylesheet">
    <link href="bootstrap.min.css" rel="stylesheet">
    <link href="jquery.smartmenus.bootstrap.css" rel="stylesheet">
    <link href="riot.css" rel="stylesheet">
    <!-- HTML5 shim and Respond.js for IE8 support of HTML5 elements and media queries -->
    <!-- WARNING: Respond.js doesn't work if you view the page via file:// -->
    <!--[if lt IE 9]>
      <script src="https://oss.maxcdn.com/html5shiv/3.7.3/html5shiv.min.js"></script>
      <script src="https://oss.maxcdn.com/respond/1.4.2/respond.min.js"></script>
    <![endif]-->
        <script>
            function displaySR(){
            searchBox.Search();
            var rhtml=(document.getElementById('MSearchResults').contentWindow.document.body.innerHTML).replace(/href=\"\.\.\//g,'href="');
            document.getElementById('MSearchResultsWindow').style.display='none';
            document.getElementById('top').append(document.getElementById('MSearchSelectWindow'));
            document.getElementById('top').append(document.getElementById('MSearchResultsWindow'));
            document.getElementById('doc-content').innerHTML=rhtml;
            }
            function modSearch(){
            if(!searchBox.doxySearch){
                searchBox.doxySearch=searchBox.Search
                searchBox.Search= function(){this.doxySearch();
                var r=document.getElementById('MSearchResultsWindow');console.log(r.style);
                if(parseInt(r.style.left)<0)r.style.left=0;
                var x=document.getElementById('MSearchResults');
                if(x.scrollWidth>window.screen.width)x.style.width=window.screen.width-2+'px';
                var f=document.getElementById('riot-searchform');
                if(parseInt( r.style.top) < f.offsetTop+f.scrollHeight) r.style.top = f.offsetTop+f.scrollHeight+'px';}
            }
            }
        </script>
  </head>
  <body>
      <div id="top">
        <nav class="navbar navbar-inverse">
          <div class="container-fluid">
            <!-- Brand and toggle get grouped for better mobile display -->
            <div class="navbar-header">
              <button type="button" class="navbar-toggle collapsed" data-toggle="collapse" data-target="#navbar-collapse" aria-expanded="false">
                <span class="sr-only">Toggle navigation</span>
                <span class="icon-bar"></span>
                <span class="icon-bar"></span>
                <span class="icon-bar"></span>
              </button>
              <a class="navbar-brand" id="brand-logo" href="http://riot-os.org"><img height="40px" src="riot-logo.svg" /></a>
              <p class="navbar-text text-center visible-xs">Documentation</p>
            </div>
            <!-- Collect the nav links, forms, and other content for toggling -->
            <div class="collapse navbar-collapse" id="navbar-collapse">
              <p class="navbar-text navbar-left"><span id="projectbrief">The friendly Operating System for the Internet of Things</span></p>
              <ul id="riot-navlist" class="nav navbar-nav"></ul>
              <form id="riot-searchform" class="navbar-form navbar-left navbar-right" action="https://duckduckgo.com/" method="get">
                 <input type="hidden" name="sites" value="doc.riot-os.org"/>
                 <input type="hidden" name="kt" value="h"/>
                 <div class="form-group">
                   <div id="MSearchBox" class="MSearchBoxActive">
                     <div class="input-group">
                       <div class="input-group-addon">
                         <span id="MSearchSelect" class="glyphicon glyphicon-search" aria-hidden="true" onmouseover="return searchBox.OnSearchSelectShow()" onmouseout="return searchBox.OnSearchSelectHide()"></span>
                       </div>
                       <input class="form-control" type="text" name="q" id="MSearchField" placeholder="Search" accesskey="S" onfocus="searchBox.OnSearchFieldFocus(true)" onblur="searchBox.OnSearchFieldFocus(false)" onkeyup="searchBox.OnSearchFieldChange(event); modSearch();">
                       <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()">
                         <span id="search-reset" class="glyphicon glyphicon-remove-circle" aria-hidden="true"></span>
                       </a>
                     </div>
                   </div>
                 </div>
              </form>
            </div><!-- /.navbar-collapse -->
          </div><!-- /.container-fluid -->
        </nav>
      </div>
<!-- Generated by Doxygen 1.8.14 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(document).ready(function(){initNavTree('group__sys__vfs.html','');});
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#groups">Modules</a> &#124;
<a href="#files">Files</a> &#124;
<a href="#nested-classes">Data Structures</a> &#124;
<a href="#define-members">Macros</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#func-members">Functions</a> &#124;
<a href="#var-members">Variables</a>  </div>
  <div class="headertitle">
<div class="title">Virtual File System (VFS) layer<div class="ingroups"><a class="el" href="group__sys.html">System</a></div></div>  </div>
</div><!--header-->
<div class="contents">

<p>Provides an interface for accessing files and directories from different devices and file systems.  
<a href="#details">More...</a></p>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<p>Provides an interface for accessing files and directories from different devices and file systems. </p>
<p>This layer is modeled as a mix between POSIX syscalls (e.g. open) and the Linux VFS layer implementation, with major reductions in the feature set, in order to fit the resource constrained platforms that RIOT targets.</p>
<p>The overall design goals are:</p><ul>
<li>Provide implementations for all newlib "file" syscalls</li>
<li>Keep it simple, do not add every possible file operation from Linux VFS.</li>
<li>Easy to map existing file system implementations for resource constrained systems onto the VFS layer API</li>
<li>Avoid keeping a central <code>enum</code> of all file system drivers that has to be kept up to date with external packages etc.</li>
<li>Use POSIX <code>&lt;<a class="el" href="errno_8h.html">errno.h</a>&gt;</code> numbers as negative return codes for errors, avoid the global <code>errno</code> variable.</li>
<li>Only absolute paths to files (no per-process working directory)</li>
<li>No dynamic memory allocation</li>
</ul>
<p>The API should be easy to understand for users who are familiar with the POSIX file functions (open, close, read, write, fstat, lseek etc.)</p>
<p>The VFS layer keeps track of mounted file systems and open files, the <code>vfs_open</code> function searches the array of mounted file systems and dispatches the call to the file system instance with the longest matching mount point prefix. Subsequent calls to <code>vfs_read</code>, <code>vfs_write</code>, etc will do a look up in the table of open files and dispatch the call to the correct file system driver for handling.</p>
<p><code>vfs_mount</code> takes a string containing the mount point, a file system driver specification (<code>struct file_system</code>), and an opaque pointer that only the FS driver knows how to use, which can be used to keep driver parameters in order to allow dynamic handling of multiple devices.</p>
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo000034">Todo:</a></b></dt><dd>VFS layer reference counting and locking for open files and simultaneous access.</dd></dl>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="groups"></a>
Modules</h2></td></tr>
<tr class="memitem:group__sys__vfs__util"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__sys__vfs__util.html">VFS helper functions</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="files"></a>
Files</h2></td></tr>
<tr class="memitem:vfs_8h"><td class="memItemLeft" align="right" valign="top">file &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="vfs_8h.html">vfs.h</a></td></tr>
<tr class="memdesc:vfs_8h"><td class="mdescLeft">&#160;</td><td class="mdescRight">VFS layer API declarations. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:vfs__default_8h"><td class="memItemLeft" align="right" valign="top">file &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="vfs__default_8h.html">vfs_default.h</a></td></tr>
<tr class="memdesc:vfs__default_8h"><td class="mdescLeft">&#160;</td><td class="mdescRight">VFS default mount points. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Data Structures</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structvfs__file__system__t.html">vfs_file_system_t</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A file system driver.  <a href="structvfs__file__system__t.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structvfs__mount__struct.html">vfs_mount_struct</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A mounted file system.  <a href="structvfs__mount__struct.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structvfs__file__t.html">vfs_file_t</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Information about an open file.  <a href="structvfs__file__t.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structvfs__DIR.html">vfs_DIR</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Internal representation of a file system directory entry.  <a href="structvfs__DIR.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structvfs__dirent__t.html">vfs_dirent_t</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">User facing directory entry.  <a href="structvfs__dirent__t.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structvfs__file__ops.html">vfs_file_ops</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Operations on open files.  <a href="structvfs__file__ops.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structvfs__dir__ops.html">vfs_dir_ops</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Operations on open directories.  <a href="structvfs__dir__ops.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structvfs__file__system__ops.html">vfs_file_system_ops</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Operations on mounted file systems.  <a href="structvfs__file__system__ops.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="define-members"></a>
Macros</h2></td></tr>
<tr class="memitem:gadc0ecc0a95f5e03d5199cbbc644fa543"><td class="memItemLeft" align="right" valign="top"><a id="gadc0ecc0a95f5e03d5199cbbc644fa543"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__sys__vfs.html#gadc0ecc0a95f5e03d5199cbbc644fa543">MAX6</a>(a,  b,  c,  d,  e,  f)&#160;&#160;&#160;<a class="el" href="core_2lib_2include_2macros_2utils_8h.html#afa99ec4acc4ecb2dc3c2d05da15d0e3f">MAX</a>(<a class="el" href="core_2lib_2include_2macros_2utils_8h.html#afa99ec4acc4ecb2dc3c2d05da15d0e3f">MAX</a>(<a class="el" href="core_2lib_2include_2macros_2utils_8h.html#afa99ec4acc4ecb2dc3c2d05da15d0e3f">MAX</a>(<a class="el" href="core_2lib_2include_2macros_2utils_8h.html#afa99ec4acc4ecb2dc3c2d05da15d0e3f">MAX</a>((a), (b)), <a class="el" href="core_2lib_2include_2macros_2utils_8h.html#afa99ec4acc4ecb2dc3c2d05da15d0e3f">MAX</a>((c), (d))), (e)), (f))</td></tr>
<tr class="memdesc:gadc0ecc0a95f5e03d5199cbbc644fa543"><td class="mdescLeft">&#160;</td><td class="mdescRight">MAX6 Function to get the largest of 6 values. <br /></td></tr>
<tr class="separator:gadc0ecc0a95f5e03d5199cbbc644fa543"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0dc4e529ed77b4432c7bd295bd89fefc"><td class="memItemLeft" align="right" valign="top"><a id="ga0dc4e529ed77b4432c7bd295bd89fefc"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__sys__vfs.html#ga0dc4e529ed77b4432c7bd295bd89fefc">VFS_MAX_OPEN_FILES</a>&#160;&#160;&#160;(16)</td></tr>
<tr class="memdesc:ga0dc4e529ed77b4432c7bd295bd89fefc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Maximum number of simultaneous open files. <br /></td></tr>
<tr class="separator:ga0dc4e529ed77b4432c7bd295bd89fefc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0e3cb874e1e5f6a49f33151d89f0aaef"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__sys__vfs.html#ga0e3cb874e1e5f6a49f33151d89f0aaef">VFS_DIR_BUFFER_SIZE</a></td></tr>
<tr class="memdesc:ga0e3cb874e1e5f6a49f33151d89f0aaef"><td class="mdescLeft">&#160;</td><td class="mdescRight">Size of buffer space in <a class="el" href="structvfs__DIR.html" title="Internal representation of a file system directory entry. ">vfs_DIR</a>.  <a href="#ga0e3cb874e1e5f6a49f33151d89f0aaef">More...</a><br /></td></tr>
<tr class="separator:ga0e3cb874e1e5f6a49f33151d89f0aaef"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6d9a9dcf98b4d4e4372cc476b8fe8eba"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__sys__vfs.html#ga6d9a9dcf98b4d4e4372cc476b8fe8eba">VFS_FILE_BUFFER_SIZE</a></td></tr>
<tr class="memdesc:ga6d9a9dcf98b4d4e4372cc476b8fe8eba"><td class="mdescLeft">&#160;</td><td class="mdescRight">Size of buffer space in <a class="el" href="structvfs__file__t.html" title="Information about an open file. ">vfs_file_t</a>.  <a href="#ga6d9a9dcf98b4d4e4372cc476b8fe8eba">More...</a><br /></td></tr>
<tr class="separator:ga6d9a9dcf98b4d4e4372cc476b8fe8eba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga818372246f79e5e859a10eb24517a3df"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__sys__vfs.html#ga818372246f79e5e859a10eb24517a3df">VFS_NAME_MAX</a>&#160;&#160;&#160;(31)</td></tr>
<tr class="memdesc:ga818372246f79e5e859a10eb24517a3df"><td class="mdescLeft">&#160;</td><td class="mdescRight">Maximum length of the name in a <code><a class="el" href="structvfs__dirent__t.html" title="User facing directory entry. ">vfs_dirent_t</a></code> (not including terminating null)  <a href="#ga818372246f79e5e859a10eb24517a3df">More...</a><br /></td></tr>
<tr class="separator:ga818372246f79e5e859a10eb24517a3df"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2033ea53eb6551b0de53412ab38d0f41"><td class="memItemLeft" align="right" valign="top"><a id="ga2033ea53eb6551b0de53412ab38d0f41"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__sys__vfs.html#ga2033ea53eb6551b0de53412ab38d0f41">VFS_ANY_FD</a>&#160;&#160;&#160;(-1)</td></tr>
<tr class="memdesc:ga2033ea53eb6551b0de53412ab38d0f41"><td class="mdescLeft">&#160;</td><td class="mdescRight">Used with vfs_bind to bind to any available fd number. <br /></td></tr>
<tr class="separator:ga2033ea53eb6551b0de53412ab38d0f41"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6fdbbbfc8a5870cf706458d5c8419f9a"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__sys__vfs.html#ga6fdbbbfc8a5870cf706458d5c8419f9a">VFS_MTD</a>(mtd)&#160;&#160;&#160;{ .dev = &amp;mtd.base }</td></tr>
<tr class="memdesc:ga6fdbbbfc8a5870cf706458d5c8419f9a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper macro for VFS_AUTO_MOUNT.  <a href="#ga6fdbbbfc8a5870cf706458d5c8419f9a">More...</a><br /></td></tr>
<tr class="separator:ga6fdbbbfc8a5870cf706458d5c8419f9a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga74c1713a82cbe6a385e552ed6427f0bb"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__sys__vfs.html#ga74c1713a82cbe6a385e552ed6427f0bb">VFS_AUTO_MOUNT</a>(type,  mtd,  path,  idx)</td></tr>
<tr class="memdesc:ga74c1713a82cbe6a385e552ed6427f0bb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Define an automatic mountpoint.  <a href="#ga74c1713a82cbe6a385e552ed6427f0bb">More...</a><br /></td></tr>
<tr class="separator:ga74c1713a82cbe6a385e552ed6427f0bb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2116058f96366fca25adf0065ebef013"><td class="memItemLeft" align="right" valign="top"><a id="ga2116058f96366fca25adf0065ebef013"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__sys__vfs.html#ga2116058f96366fca25adf0065ebef013">VFS_FS_FLAG_WANT_ABS_PATH</a>&#160;&#160;&#160;(1 &lt;&lt; 0)</td></tr>
<tr class="memdesc:ga2116058f96366fca25adf0065ebef013"><td class="mdescLeft">&#160;</td><td class="mdescRight">File system always wants the full VFS path. <br /></td></tr>
<tr class="separator:ga2116058f96366fca25adf0065ebef013"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:gaae22046871c456cbbd1bca6298766b68"><td class="memItemLeft" align="right" valign="top"><a id="gaae22046871c456cbbd1bca6298766b68"></a>
typedef struct <a class="el" href="structvfs__file__ops.html">vfs_file_ops</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__sys__vfs.html#gaae22046871c456cbbd1bca6298766b68">vfs_file_ops_t</a></td></tr>
<tr class="memdesc:gaae22046871c456cbbd1bca6298766b68"><td class="mdescLeft">&#160;</td><td class="mdescRight">struct <code><a class="el" href="structvfs__file__ops.html" title="Operations on open files. ">vfs_file_ops</a></code> typedef <br /></td></tr>
<tr class="separator:gaae22046871c456cbbd1bca6298766b68"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaefe122d8eea546f0786cbff3adcc4156"><td class="memItemLeft" align="right" valign="top"><a id="gaefe122d8eea546f0786cbff3adcc4156"></a>
typedef struct <a class="el" href="structvfs__dir__ops.html">vfs_dir_ops</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__sys__vfs.html#gaefe122d8eea546f0786cbff3adcc4156">vfs_dir_ops_t</a></td></tr>
<tr class="memdesc:gaefe122d8eea546f0786cbff3adcc4156"><td class="mdescLeft">&#160;</td><td class="mdescRight">struct <code><a class="el" href="structvfs__dir__ops.html" title="Operations on open directories. ">vfs_dir_ops</a></code> typedef <br /></td></tr>
<tr class="separator:gaefe122d8eea546f0786cbff3adcc4156"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1be46db273a8474303603f514fb7bfee"><td class="memItemLeft" align="right" valign="top"><a id="ga1be46db273a8474303603f514fb7bfee"></a>
typedef struct <a class="el" href="structvfs__file__system__ops.html">vfs_file_system_ops</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__sys__vfs.html#ga1be46db273a8474303603f514fb7bfee">vfs_file_system_ops_t</a></td></tr>
<tr class="memdesc:ga1be46db273a8474303603f514fb7bfee"><td class="mdescLeft">&#160;</td><td class="mdescRight">struct <code><a class="el" href="structvfs__file__system__ops.html" title="Operations on mounted file systems. ">vfs_file_system_ops</a></code> typedef <br /></td></tr>
<tr class="separator:ga1be46db273a8474303603f514fb7bfee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9fc6f9bb8f8b2f401e2bd7181cc4018f"><td class="memItemLeft" align="right" valign="top"><a id="ga9fc6f9bb8f8b2f401e2bd7181cc4018f"></a>
typedef struct <a class="el" href="structvfs__mount__struct.html">vfs_mount_struct</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__sys__vfs.html#ga9fc6f9bb8f8b2f401e2bd7181cc4018f">vfs_mount_t</a></td></tr>
<tr class="memdesc:ga9fc6f9bb8f8b2f401e2bd7181cc4018f"><td class="mdescLeft">&#160;</td><td class="mdescRight">struct <code><a class="el" href="structvfs__mount__struct.html" title="A mounted file system. ">vfs_mount_struct</a></code> typedef <br /></td></tr>
<tr class="separator:ga9fc6f9bb8f8b2f401e2bd7181cc4018f"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:ga9b760e38efd5f348b77e582954f0b141"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__sys__vfs.html#ga9b760e38efd5f348b77e582954f0b141">vfs_bind_stdio</a> (void)</td></tr>
<tr class="memdesc:ga9b760e38efd5f348b77e582954f0b141"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allocate and bind file descriptors for STDIN, STDERR, and STDOUT.  <a href="#ga9b760e38efd5f348b77e582954f0b141">More...</a><br /></td></tr>
<tr class="separator:ga9b760e38efd5f348b77e582954f0b141"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga60d1dba40888b0dadfbb4f0a30e1cb89"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__sys__vfs.html#ga60d1dba40888b0dadfbb4f0a30e1cb89">vfs_close</a> (int fd)</td></tr>
<tr class="memdesc:ga60d1dba40888b0dadfbb4f0a30e1cb89"><td class="mdescLeft">&#160;</td><td class="mdescRight">Close an open file.  <a href="#ga60d1dba40888b0dadfbb4f0a30e1cb89">More...</a><br /></td></tr>
<tr class="separator:ga60d1dba40888b0dadfbb4f0a30e1cb89"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gacfac67f4d58f160ca165336b95e14c76"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__sys__vfs.html#gacfac67f4d58f160ca165336b95e14c76">vfs_fcntl</a> (int fd, int cmd, int arg)</td></tr>
<tr class="memdesc:gacfac67f4d58f160ca165336b95e14c76"><td class="mdescLeft">&#160;</td><td class="mdescRight">Query/set options on an open file.  <a href="#gacfac67f4d58f160ca165336b95e14c76">More...</a><br /></td></tr>
<tr class="separator:gacfac67f4d58f160ca165336b95e14c76"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad4649a984a7aa0643d157f8467d9c4ee"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__sys__vfs.html#gad4649a984a7aa0643d157f8467d9c4ee">vfs_fstat</a> (int fd, struct stat *buf)</td></tr>
<tr class="memdesc:gad4649a984a7aa0643d157f8467d9c4ee"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get status of an open file.  <a href="#gad4649a984a7aa0643d157f8467d9c4ee">More...</a><br /></td></tr>
<tr class="separator:gad4649a984a7aa0643d157f8467d9c4ee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf67facc4f466ae49d9eef46437a47581"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__sys__vfs.html#gaf67facc4f466ae49d9eef46437a47581">vfs_fstatvfs</a> (int fd, struct <a class="el" href="structstatvfs.html">statvfs</a> *buf)</td></tr>
<tr class="memdesc:gaf67facc4f466ae49d9eef46437a47581"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get file system status of the file system containing an open file.  <a href="#gaf67facc4f466ae49d9eef46437a47581">More...</a><br /></td></tr>
<tr class="separator:gaf67facc4f466ae49d9eef46437a47581"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac8053fc8b584ba894953565b345f0d16"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__sys__vfs.html#gac8053fc8b584ba894953565b345f0d16">vfs_dstatvfs</a> (<a class="el" href="structvfs__DIR.html">vfs_DIR</a> *dirp, struct <a class="el" href="structstatvfs.html">statvfs</a> *buf)</td></tr>
<tr class="memdesc:gac8053fc8b584ba894953565b345f0d16"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get file system status of the file system containing an open directory.  <a href="#gac8053fc8b584ba894953565b345f0d16">More...</a><br /></td></tr>
<tr class="separator:gac8053fc8b584ba894953565b345f0d16"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8280218c31e2cc294019433319c2d5aa"><td class="memItemLeft" align="right" valign="top">off_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__sys__vfs.html#ga8280218c31e2cc294019433319c2d5aa">vfs_lseek</a> (int fd, off_t off, int whence)</td></tr>
<tr class="memdesc:ga8280218c31e2cc294019433319c2d5aa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Seek to position in file.  <a href="#ga8280218c31e2cc294019433319c2d5aa">More...</a><br /></td></tr>
<tr class="separator:ga8280218c31e2cc294019433319c2d5aa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga208458bdb4b5da7c1330e5fa160e7fee"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__sys__vfs.html#ga208458bdb4b5da7c1330e5fa160e7fee">vfs_open</a> (const char *name, int flags, mode_t mode)</td></tr>
<tr class="memdesc:ga208458bdb4b5da7c1330e5fa160e7fee"><td class="mdescLeft">&#160;</td><td class="mdescRight">Open a file.  <a href="#ga208458bdb4b5da7c1330e5fa160e7fee">More...</a><br /></td></tr>
<tr class="separator:ga208458bdb4b5da7c1330e5fa160e7fee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae56830870bc891bd8617d08bc621c5ea"><td class="memItemLeft" align="right" valign="top">ssize_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__sys__vfs.html#gae56830870bc891bd8617d08bc621c5ea">vfs_read</a> (int fd, void *dest, size_t count)</td></tr>
<tr class="memdesc:gae56830870bc891bd8617d08bc621c5ea"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read bytes from an open file.  <a href="#gae56830870bc891bd8617d08bc621c5ea">More...</a><br /></td></tr>
<tr class="separator:gae56830870bc891bd8617d08bc621c5ea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9ce2d59faff599decefb5fb9848fddca"><td class="memItemLeft" align="right" valign="top">ssize_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__sys__vfs.html#ga9ce2d59faff599decefb5fb9848fddca">vfs_readline</a> (int fd, char *dest, size_t count)</td></tr>
<tr class="memdesc:ga9ce2d59faff599decefb5fb9848fddca"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read a line from an open text file.  <a href="#ga9ce2d59faff599decefb5fb9848fddca">More...</a><br /></td></tr>
<tr class="separator:ga9ce2d59faff599decefb5fb9848fddca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3ab340fc28c34361e2b8206693e049d6"><td class="memItemLeft" align="right" valign="top">ssize_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__sys__vfs.html#ga3ab340fc28c34361e2b8206693e049d6">vfs_write</a> (int fd, const void *src, size_t count)</td></tr>
<tr class="memdesc:ga3ab340fc28c34361e2b8206693e049d6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Write bytes to an open file.  <a href="#ga3ab340fc28c34361e2b8206693e049d6">More...</a><br /></td></tr>
<tr class="separator:ga3ab340fc28c34361e2b8206693e049d6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga97f6250e54e0c0aa22d1d9efaaa67fc7"><td class="memItemLeft" align="right" valign="top">ssize_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__sys__vfs.html#ga97f6250e54e0c0aa22d1d9efaaa67fc7">vfs_write_iol</a> (int fd, const <a class="el" href="group__sys__iolist.html#gaa17f91ef26edec149cd806d8457aa3a0">iolist_t</a> *<a class="el" href="structiolist.html">iolist</a>)</td></tr>
<tr class="memdesc:ga97f6250e54e0c0aa22d1d9efaaa67fc7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Write bytes from an iolist to an open file.  <a href="#ga97f6250e54e0c0aa22d1d9efaaa67fc7">More...</a><br /></td></tr>
<tr class="separator:ga97f6250e54e0c0aa22d1d9efaaa67fc7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab2566aeb152e97175242bf6edb45d0cc"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__sys__vfs.html#gab2566aeb152e97175242bf6edb45d0cc">vfs_fsync</a> (int fd)</td></tr>
<tr class="memdesc:gab2566aeb152e97175242bf6edb45d0cc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Synchronize a file on storage Any pending writes are written out to storage.  <a href="#gab2566aeb152e97175242bf6edb45d0cc">More...</a><br /></td></tr>
<tr class="separator:gab2566aeb152e97175242bf6edb45d0cc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab28e72f381ff98931d9c2db584781162"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__sys__vfs.html#gab28e72f381ff98931d9c2db584781162">vfs_opendir</a> (<a class="el" href="structvfs__DIR.html">vfs_DIR</a> *dirp, const char *dirname)</td></tr>
<tr class="memdesc:gab28e72f381ff98931d9c2db584781162"><td class="mdescLeft">&#160;</td><td class="mdescRight">Open a directory for reading with readdir.  <a href="#gab28e72f381ff98931d9c2db584781162">More...</a><br /></td></tr>
<tr class="separator:gab28e72f381ff98931d9c2db584781162"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga81bb503b1aa7bb77d1d91170a0ea1b6d"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__sys__vfs.html#ga81bb503b1aa7bb77d1d91170a0ea1b6d">vfs_readdir</a> (<a class="el" href="structvfs__DIR.html">vfs_DIR</a> *dirp, <a class="el" href="structvfs__dirent__t.html">vfs_dirent_t</a> *entry)</td></tr>
<tr class="memdesc:ga81bb503b1aa7bb77d1d91170a0ea1b6d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read a single entry from the open directory dirp and advance the read position by one.  <a href="#ga81bb503b1aa7bb77d1d91170a0ea1b6d">More...</a><br /></td></tr>
<tr class="separator:ga81bb503b1aa7bb77d1d91170a0ea1b6d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf3ffccb04f73042f1b1bdb63ca770e73"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__sys__vfs.html#gaf3ffccb04f73042f1b1bdb63ca770e73">vfs_closedir</a> (<a class="el" href="structvfs__DIR.html">vfs_DIR</a> *dirp)</td></tr>
<tr class="memdesc:gaf3ffccb04f73042f1b1bdb63ca770e73"><td class="mdescLeft">&#160;</td><td class="mdescRight">Close an open directory.  <a href="#gaf3ffccb04f73042f1b1bdb63ca770e73">More...</a><br /></td></tr>
<tr class="separator:gaf3ffccb04f73042f1b1bdb63ca770e73"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga85c6c8cab631ccd9ad61badb54d8ba10"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__sys__vfs.html#ga85c6c8cab631ccd9ad61badb54d8ba10">vfs_format</a> (<a class="el" href="group__sys__vfs.html#ga9fc6f9bb8f8b2f401e2bd7181cc4018f">vfs_mount_t</a> *mountp)</td></tr>
<tr class="memdesc:ga85c6c8cab631ccd9ad61badb54d8ba10"><td class="mdescLeft">&#160;</td><td class="mdescRight">Format a file system.  <a href="#ga85c6c8cab631ccd9ad61badb54d8ba10">More...</a><br /></td></tr>
<tr class="separator:ga85c6c8cab631ccd9ad61badb54d8ba10"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8c6143529d99c05c153dc97147721104"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__sys__vfs.html#ga8c6143529d99c05c153dc97147721104">vfs_format_by_path</a> (const char *path)</td></tr>
<tr class="memdesc:ga8c6143529d99c05c153dc97147721104"><td class="mdescLeft">&#160;</td><td class="mdescRight">Format a file system.  <a href="#ga8c6143529d99c05c153dc97147721104">More...</a><br /></td></tr>
<tr class="separator:ga8c6143529d99c05c153dc97147721104"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga188e99ea85dc9923550473e7e7b81500"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__sys__vfs.html#ga188e99ea85dc9923550473e7e7b81500">vfs_mount</a> (<a class="el" href="group__sys__vfs.html#ga9fc6f9bb8f8b2f401e2bd7181cc4018f">vfs_mount_t</a> *mountp)</td></tr>
<tr class="memdesc:ga188e99ea85dc9923550473e7e7b81500"><td class="mdescLeft">&#160;</td><td class="mdescRight">Mount a file system.  <a href="#ga188e99ea85dc9923550473e7e7b81500">More...</a><br /></td></tr>
<tr class="separator:ga188e99ea85dc9923550473e7e7b81500"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gafe0112ee960e58b9216399294b87df08"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__sys__vfs.html#gafe0112ee960e58b9216399294b87df08">vfs_mount_by_path</a> (const char *path)</td></tr>
<tr class="memdesc:gafe0112ee960e58b9216399294b87df08"><td class="mdescLeft">&#160;</td><td class="mdescRight">Mount a file system with a pre-configured mount path.  <a href="#gafe0112ee960e58b9216399294b87df08">More...</a><br /></td></tr>
<tr class="separator:gafe0112ee960e58b9216399294b87df08"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gafe07bef032f76c753c773a7e7ee11e03"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__sys__vfs.html#gafe07bef032f76c753c773a7e7ee11e03">vfs_unmount_by_path</a> (const char *path, bool force)</td></tr>
<tr class="memdesc:gafe07bef032f76c753c773a7e7ee11e03"><td class="mdescLeft">&#160;</td><td class="mdescRight">Unmount a file system with a pre-configured mount path.  <a href="#gafe07bef032f76c753c773a7e7ee11e03">More...</a><br /></td></tr>
<tr class="separator:gafe07bef032f76c753c773a7e7ee11e03"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8d018700b625ff53592d50f4ef1c69a1"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__sys__vfs.html#ga8d018700b625ff53592d50f4ef1c69a1">vfs_rename</a> (const char *from_path, const char *to_path)</td></tr>
<tr class="memdesc:ga8d018700b625ff53592d50f4ef1c69a1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Rename a file.  <a href="#ga8d018700b625ff53592d50f4ef1c69a1">More...</a><br /></td></tr>
<tr class="separator:ga8d018700b625ff53592d50f4ef1c69a1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga47aaf69f968a163cc65a2805d76c2bd9"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__sys__vfs.html#ga47aaf69f968a163cc65a2805d76c2bd9">vfs_umount</a> (<a class="el" href="group__sys__vfs.html#ga9fc6f9bb8f8b2f401e2bd7181cc4018f">vfs_mount_t</a> *mountp, bool force)</td></tr>
<tr class="memdesc:ga47aaf69f968a163cc65a2805d76c2bd9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Unmount a mounted file system.  <a href="#ga47aaf69f968a163cc65a2805d76c2bd9">More...</a><br /></td></tr>
<tr class="separator:ga47aaf69f968a163cc65a2805d76c2bd9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaadef8ee16be7695b8be4c151331df79c"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__sys__vfs.html#gaadef8ee16be7695b8be4c151331df79c">vfs_unlink</a> (const char *name)</td></tr>
<tr class="memdesc:gaadef8ee16be7695b8be4c151331df79c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Unlink (delete) a file from a mounted file system.  <a href="#gaadef8ee16be7695b8be4c151331df79c">More...</a><br /></td></tr>
<tr class="separator:gaadef8ee16be7695b8be4c151331df79c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4351778a74bb39fd68256847b6a22c8c"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__sys__vfs.html#ga4351778a74bb39fd68256847b6a22c8c">vfs_mkdir</a> (const char *name, mode_t mode)</td></tr>
<tr class="memdesc:ga4351778a74bb39fd68256847b6a22c8c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a directory on the file system.  <a href="#ga4351778a74bb39fd68256847b6a22c8c">More...</a><br /></td></tr>
<tr class="separator:ga4351778a74bb39fd68256847b6a22c8c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac9e6c31f4d15ed832cb5c61e0c6e9659"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__sys__vfs.html#gac9e6c31f4d15ed832cb5c61e0c6e9659">vfs_rmdir</a> (const char *name)</td></tr>
<tr class="memdesc:gac9e6c31f4d15ed832cb5c61e0c6e9659"><td class="mdescLeft">&#160;</td><td class="mdescRight">Remove a directory from the file system.  <a href="#gac9e6c31f4d15ed832cb5c61e0c6e9659">More...</a><br /></td></tr>
<tr class="separator:gac9e6c31f4d15ed832cb5c61e0c6e9659"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9a4ef5ceb298c288b544cce1f7736aec"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__sys__vfs.html#ga9a4ef5ceb298c288b544cce1f7736aec">vfs_stat</a> (const char *restrict path, struct stat *restrict buf)</td></tr>
<tr class="memdesc:ga9a4ef5ceb298c288b544cce1f7736aec"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get file status.  <a href="#ga9a4ef5ceb298c288b544cce1f7736aec">More...</a><br /></td></tr>
<tr class="separator:ga9a4ef5ceb298c288b544cce1f7736aec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2dd77a30a2ea9cc4531f40d089483b8e"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__sys__vfs.html#ga2dd77a30a2ea9cc4531f40d089483b8e">vfs_statvfs</a> (const char *restrict path, struct <a class="el" href="structstatvfs.html">statvfs</a> *restrict buf)</td></tr>
<tr class="memdesc:ga2dd77a30a2ea9cc4531f40d089483b8e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get file system status.  <a href="#ga2dd77a30a2ea9cc4531f40d089483b8e">More...</a><br /></td></tr>
<tr class="separator:ga2dd77a30a2ea9cc4531f40d089483b8e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga88894417c3313eece41cf4cb3a283d42"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__sys__vfs.html#ga88894417c3313eece41cf4cb3a283d42">vfs_bind</a> (int fd, int flags, const <a class="el" href="group__sys__vfs.html#gaae22046871c456cbbd1bca6298766b68">vfs_file_ops_t</a> *f_op, void *private_data)</td></tr>
<tr class="memdesc:ga88894417c3313eece41cf4cb3a283d42"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allocate a new file descriptor and give it file operations.  <a href="#ga88894417c3313eece41cf4cb3a283d42">More...</a><br /></td></tr>
<tr class="separator:ga88894417c3313eece41cf4cb3a283d42"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1a43fdb3d5de4d23eef9f39dccf90cae"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__sys__vfs.html#ga1a43fdb3d5de4d23eef9f39dccf90cae">vfs_normalize_path</a> (char *buf, const char *path, size_t buflen)</td></tr>
<tr class="memdesc:ga1a43fdb3d5de4d23eef9f39dccf90cae"><td class="mdescLeft">&#160;</td><td class="mdescRight">Normalize a path.  <a href="#ga1a43fdb3d5de4d23eef9f39dccf90cae">More...</a><br /></td></tr>
<tr class="separator:ga1a43fdb3d5de4d23eef9f39dccf90cae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gafdbefec3679da1fed038f1fc42e8e821"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="group__sys__vfs.html#ga9fc6f9bb8f8b2f401e2bd7181cc4018f">vfs_mount_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__sys__vfs.html#gafdbefec3679da1fed038f1fc42e8e821">vfs_iterate_mounts</a> (const <a class="el" href="group__sys__vfs.html#ga9fc6f9bb8f8b2f401e2bd7181cc4018f">vfs_mount_t</a> *cur)</td></tr>
<tr class="memdesc:gafdbefec3679da1fed038f1fc42e8e821"><td class="mdescLeft">&#160;</td><td class="mdescRight">Iterate through all mounted file systems.  <a href="#gafdbefec3679da1fed038f1fc42e8e821">More...</a><br /></td></tr>
<tr class="separator:gafdbefec3679da1fed038f1fc42e8e821"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae972dfeffadbdccd3c878b279446baaa"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__sys__vfs.html#gae972dfeffadbdccd3c878b279446baaa">vfs_iterate_mount_dirs</a> (<a class="el" href="structvfs__DIR.html">vfs_DIR</a> *dir)</td></tr>
<tr class="memdesc:gae972dfeffadbdccd3c878b279446baaa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Iterate through all mounted file systems by their root directories.  <a href="#gae972dfeffadbdccd3c878b279446baaa">More...</a><br /></td></tr>
<tr class="separator:gae972dfeffadbdccd3c878b279446baaa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa717194c0d9d055711196323dd5cb8aa"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="structvfs__file__t.html">vfs_file_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__sys__vfs.html#gaa717194c0d9d055711196323dd5cb8aa">vfs_file_get</a> (int fd)</td></tr>
<tr class="memdesc:gaa717194c0d9d055711196323dd5cb8aa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get information about the file for internal purposes.  <a href="#gaa717194c0d9d055711196323dd5cb8aa">More...</a><br /></td></tr>
<tr class="separator:gaa717194c0d9d055711196323dd5cb8aa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga77f919082a5f2e395ad60fac39a821b9"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__sys__vfs.html#ga77f919082a5f2e395ad60fac39a821b9">vfs_sysop_stat_from_fstat</a> (<a class="el" href="group__sys__vfs.html#ga9fc6f9bb8f8b2f401e2bd7181cc4018f">vfs_mount_t</a> *mountp, const char *restrict path, struct stat *restrict buf)</td></tr>
<tr class="memdesc:ga77f919082a5f2e395ad60fac39a821b9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Implementation of <code>stat</code> using <code>fstat</code>  <a href="#ga77f919082a5f2e395ad60fac39a821b9">More...</a><br /></td></tr>
<tr class="separator:ga77f919082a5f2e395ad60fac39a821b9"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="var-members"></a>
Variables</h2></td></tr>
<tr class="memitem:gac0a5658e078c937a88369f695baf88d8"><td class="memItemLeft" align="right" valign="top"><a id="gac0a5658e078c937a88369f695baf88d8"></a>
const <a class="el" href="group__sys__vfs.html#gaae22046871c456cbbd1bca6298766b68">vfs_file_ops_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__sys__vfs.html#gac0a5658e078c937a88369f695baf88d8">mtd_vfs_ops</a></td></tr>
<tr class="memdesc:gac0a5658e078c937a88369f695baf88d8"><td class="mdescLeft">&#160;</td><td class="mdescRight">MTD driver for VFS. <br /></td></tr>
<tr class="separator:gac0a5658e078c937a88369f695baf88d8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf168cd5f6f5766b34d6be9b9c1ce9f26"><td class="memItemLeft" align="right" valign="top"><a id="gaf168cd5f6f5766b34d6be9b9c1ce9f26"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__sys__vfs.html#gaf168cd5f6f5766b34d6be9b9c1ce9f26">FATFS_VFS_DIR_BUFFER_SIZE</a>&#160;&#160;&#160;(1)</td></tr>
<tr class="memdesc:gaf168cd5f6f5766b34d6be9b9c1ce9f26"><td class="mdescLeft">&#160;</td><td class="mdescRight">VFS parameters for FAT. <br /></td></tr>
<tr class="separator:gaf168cd5f6f5766b34d6be9b9c1ce9f26"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga069e70ed819eb2071c355529c933a65b"><td class="memItemLeft" align="right" valign="top"><a id="ga069e70ed819eb2071c355529c933a65b"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>FATFS_VFS_FILE_BUFFER_SIZE</b>&#160;&#160;&#160;(1)</td></tr>
<tr class="separator:ga069e70ed819eb2071c355529c933a65b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga39a3ce949009b07b680210b57ace4650"><td class="memItemLeft" align="right" valign="top"><a id="ga39a3ce949009b07b680210b57ace4650"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__sys__vfs.html#ga39a3ce949009b07b680210b57ace4650">LITTLEFS_VFS_DIR_BUFFER_SIZE</a>&#160;&#160;&#160;(1)</td></tr>
<tr class="memdesc:ga39a3ce949009b07b680210b57ace4650"><td class="mdescLeft">&#160;</td><td class="mdescRight">VFS parameters for littlefs. <br /></td></tr>
<tr class="separator:ga39a3ce949009b07b680210b57ace4650"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2a299d759966f4be9e60473b85844db5"><td class="memItemLeft" align="right" valign="top"><a id="ga2a299d759966f4be9e60473b85844db5"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>LITTLEFS_VFS_FILE_BUFFER_SIZE</b>&#160;&#160;&#160;(1)</td></tr>
<tr class="separator:ga2a299d759966f4be9e60473b85844db5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8bb076eda1b8d4f5176fec79314a020b"><td class="memItemLeft" align="right" valign="top"><a id="ga8bb076eda1b8d4f5176fec79314a020b"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__sys__vfs.html#ga8bb076eda1b8d4f5176fec79314a020b">LITTLEFS2_VFS_DIR_BUFFER_SIZE</a>&#160;&#160;&#160;(1)</td></tr>
<tr class="memdesc:ga8bb076eda1b8d4f5176fec79314a020b"><td class="mdescLeft">&#160;</td><td class="mdescRight">VFS parameters for littlefs2. <br /></td></tr>
<tr class="separator:ga8bb076eda1b8d4f5176fec79314a020b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga73c894ae1c52a2c875b977280418feae"><td class="memItemLeft" align="right" valign="top"><a id="ga73c894ae1c52a2c875b977280418feae"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>LITTLEFS2_VFS_FILE_BUFFER_SIZE</b>&#160;&#160;&#160;(1)</td></tr>
<tr class="separator:ga73c894ae1c52a2c875b977280418feae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0def0df1a3ac093ececed5dc59873b62"><td class="memItemLeft" align="right" valign="top"><a id="ga0def0df1a3ac093ececed5dc59873b62"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__sys__vfs.html#ga0def0df1a3ac093ececed5dc59873b62">SPIFFS_VFS_DIR_BUFFER_SIZE</a>&#160;&#160;&#160;(1)</td></tr>
<tr class="memdesc:ga0def0df1a3ac093ececed5dc59873b62"><td class="mdescLeft">&#160;</td><td class="mdescRight">VFS parameters for spiffs. <br /></td></tr>
<tr class="separator:ga0def0df1a3ac093ececed5dc59873b62"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga43f70b723645183965add3e54025452a"><td class="memItemLeft" align="right" valign="top"><a id="ga43f70b723645183965add3e54025452a"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>SPIFFS_VFS_FILE_BUFFER_SIZE</b>&#160;&#160;&#160;(1)</td></tr>
<tr class="separator:ga43f70b723645183965add3e54025452a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa976da80fd2af755c62ad0dc66eb7c57"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__sys__vfs.html#gaa976da80fd2af755c62ad0dc66eb7c57">LWEXT4_VFS_DIR_BUFFER_SIZE</a>&#160;&#160;&#160;(308)</td></tr>
<tr class="memdesc:gaa976da80fd2af755c62ad0dc66eb7c57"><td class="mdescLeft">&#160;</td><td class="mdescRight">VFS parameters for lwext4.  <a href="#gaa976da80fd2af755c62ad0dc66eb7c57">More...</a><br /></td></tr>
<tr class="separator:gaa976da80fd2af755c62ad0dc66eb7c57"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6f5d3938070fb53e14cf28049e7d2b41"><td class="memItemLeft" align="right" valign="top"><a id="ga6f5d3938070fb53e14cf28049e7d2b41"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__sys__vfs.html#ga6f5d3938070fb53e14cf28049e7d2b41">LWEXT4_VFS_FILE_BUFFER_SIZE</a>&#160;&#160;&#160;(32)</td></tr>
<tr class="memdesc:ga6f5d3938070fb53e14cf28049e7d2b41"><td class="mdescLeft">&#160;</td><td class="mdescRight">sizeof(ext4_file) <br /></td></tr>
<tr class="separator:ga6f5d3938070fb53e14cf28049e7d2b41"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4c9ada0af73ad435588f0ec27a44f126"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__sys__vfs.html#ga4c9ada0af73ad435588f0ec27a44f126">NANOCOAP_FS_VFS_DIR_BUFFER_SIZE</a>&#160;&#160;&#160;(4 + <a class="el" href="group__net__sock__util__conf.html#gad90280b1a26f189c13b65400ae14af37">CONFIG_SOCK_URLPATH_MAXLEN</a>)</td></tr>
<tr class="memdesc:ga4c9ada0af73ad435588f0ec27a44f126"><td class="mdescLeft">&#160;</td><td class="mdescRight">VFS parameters for nanoCoAP FS.  <a href="#ga4c9ada0af73ad435588f0ec27a44f126">More...</a><br /></td></tr>
<tr class="separator:ga4c9ada0af73ad435588f0ec27a44f126"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1e049cb67cd3bca8c6b7b89a3e5525ee"><td class="memItemLeft" align="right" valign="top"><a id="ga1e049cb67cd3bca8c6b7b89a3e5525ee"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__sys__vfs.html#ga1e049cb67cd3bca8c6b7b89a3e5525ee">NANOCOAP_FS_VFS_FILE_BUFFER_SIZE</a>&#160;&#160;&#160;(4 + <a class="el" href="group__net__sock__util__conf.html#gad90280b1a26f189c13b65400ae14af37">CONFIG_SOCK_URLPATH_MAXLEN</a>)</td></tr>
<tr class="memdesc:ga1e049cb67cd3bca8c6b7b89a3e5525ee"><td class="mdescLeft">&#160;</td><td class="mdescRight">sizeof(nanocoap_fs_file_t) <br /></td></tr>
<tr class="separator:ga1e049cb67cd3bca8c6b7b89a3e5525ee"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Macro Definition Documentation</h2>
<a id="gaa976da80fd2af755c62ad0dc66eb7c57"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaa976da80fd2af755c62ad0dc66eb7c57">&#9670;&nbsp;</a></span>LWEXT4_VFS_DIR_BUFFER_SIZE</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define LWEXT4_VFS_DIR_BUFFER_SIZE&#160;&#160;&#160;(308)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>VFS parameters for lwext4. </p>
<p>sizeof(ext4_dir) </p>

<p class="definition">Definition at line <a class="el" href="vfs_8h_source.html#l00198">198</a> of file <a class="el" href="vfs_8h_source.html">vfs.h</a>.</p>

</div>
</div>
<a id="ga4c9ada0af73ad435588f0ec27a44f126"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga4c9ada0af73ad435588f0ec27a44f126">&#9670;&nbsp;</a></span>NANOCOAP_FS_VFS_DIR_BUFFER_SIZE</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define NANOCOAP_FS_VFS_DIR_BUFFER_SIZE&#160;&#160;&#160;(4 + <a class="el" href="group__net__sock__util__conf.html#gad90280b1a26f189c13b65400ae14af37">CONFIG_SOCK_URLPATH_MAXLEN</a>)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>VFS parameters for nanoCoAP FS. </p>
<p>sizeof(nanocoap_fs_dir_t) </p>

<p class="definition">Definition at line <a class="el" href="vfs_8h_source.html#l00211">211</a> of file <a class="el" href="vfs_8h_source.html">vfs.h</a>.</p>

</div>
</div>
<a id="ga74c1713a82cbe6a385e552ed6427f0bb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga74c1713a82cbe6a385e552ed6427f0bb">&#9670;&nbsp;</a></span>VFS_AUTO_MOUNT</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define VFS_AUTO_MOUNT</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">type, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">mtd, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">path, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">idx&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Value:</b><div class="fragment"><div class="line"><span class="keyword">static</span> type ## _desc_t fs_desc_ ## idx = mtd;   <a class="code" href="xfa_8h.html#a2bf3af8f2c60989478190d3f107bfe09">\</a></div><div class="line"><a class="code" href="xfa_8h.html#a2bf3af8f2c60989478190d3f107bfe09">                                                    \</a></div><div class="line"><a class="code" href="xfa_8h.html#a2bf3af8f2c60989478190d3f107bfe09">    XFA</a>(<a class="code" href="structvfs__mount__struct.html">vfs_mount_t</a>, vfs_mountpoints_xfa, 0)        \</div><div class="line">    _mount_mtd_ ## idx = {                          \</div><div class="line">        .fs = &amp;type ## _file_system,                \</div><div class="line">        .mount_point = path,                        \</div><div class="line">        .private_data = &amp;fs_desc_ ## idx,           \</div><div class="line">    }</div><div class="ttc" id="xfa_8h_html_a2bf3af8f2c60989478190d3f107bfe09"><div class="ttname"><a href="xfa_8h.html#a2bf3af8f2c60989478190d3f107bfe09">XFA</a></div><div class="ttdeci">#define XFA(type, xfa_name, prio)</div><div class="ttdoc">Define variable in writable cross-file array. </div><div class="ttdef"><b>Definition:</b> <a href="xfa_8h_source.html#l00145">xfa.h:145</a></div></div>
<div class="ttc" id="structvfs__mount__struct_html"><div class="ttname"><a href="structvfs__mount__struct.html">vfs_mount_struct</a></div><div class="ttdoc">A mounted file system. </div><div class="ttdef"><b>Definition:</b> <a href="vfs_8h_source.html#l00385">vfs.h:385</a></div></div>
</div><!-- fragment -->
<p>Define an automatic mountpoint. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">type</td><td>file system type Can be littlefs, littlefs2, spiffs or fatfs</td></tr>
  </table>
  </dd>
</dl>
<p>Internally, file systems supporting this must name their <a class="el" href="structvfs__file__system__t.html">vfs_file_system_t</a> <code>${TYPE}_file_system</code>, and must use a type named <code>${TYPE}_desc_t</code> for their private data </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">mtd</td><td>file system backed device configuration </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">path</td><td>Mount path </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">idx</td><td>Unique index of the mount point </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="vfs_8h_source.html#l00330">330</a> of file <a class="el" href="vfs_8h_source.html">vfs.h</a>.</p>

</div>
</div>
<a id="ga0e3cb874e1e5f6a49f33151d89f0aaef"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga0e3cb874e1e5f6a49f33151d89f0aaef">&#9670;&nbsp;</a></span>VFS_DIR_BUFFER_SIZE</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define VFS_DIR_BUFFER_SIZE</td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Value:</b><div class="fragment"><div class="line"><a class="code" href="group__sys__vfs.html#gadc0ecc0a95f5e03d5199cbbc644fa543">MAX6</a>(<a class="code" href="group__sys__vfs.html#gaf168cd5f6f5766b34d6be9b9c1ce9f26">FATFS_VFS_DIR_BUFFER_SIZE</a>,      \</div><div class="line">                                 <a class="code" href="group__sys__vfs.html#ga39a3ce949009b07b680210b57ace4650">LITTLEFS_VFS_DIR_BUFFER_SIZE</a>,   \</div><div class="line">                                 <a class="code" href="group__sys__vfs.html#ga8bb076eda1b8d4f5176fec79314a020b">LITTLEFS2_VFS_DIR_BUFFER_SIZE</a>,  \</div><div class="line">                                 <a class="code" href="group__sys__vfs.html#ga0def0df1a3ac093ececed5dc59873b62">SPIFFS_VFS_DIR_BUFFER_SIZE</a>,     \</div><div class="line">                                 <a class="code" href="group__sys__vfs.html#gaa976da80fd2af755c62ad0dc66eb7c57">LWEXT4_VFS_DIR_BUFFER_SIZE</a>,     \</div><div class="line">                                 <a class="code" href="group__sys__vfs.html#ga4c9ada0af73ad435588f0ec27a44f126">NANOCOAP_FS_VFS_DIR_BUFFER_SIZE</a> \</div><div class="line">                                )</div><div class="ttc" id="group__sys__vfs_html_gaf168cd5f6f5766b34d6be9b9c1ce9f26"><div class="ttname"><a href="group__sys__vfs.html#gaf168cd5f6f5766b34d6be9b9c1ce9f26">FATFS_VFS_DIR_BUFFER_SIZE</a></div><div class="ttdeci">#define FATFS_VFS_DIR_BUFFER_SIZE</div><div class="ttdoc">VFS parameters for FAT. </div><div class="ttdef"><b>Definition:</b> <a href="vfs_8h_source.html#l00139">vfs.h:139</a></div></div>
<div class="ttc" id="group__sys__vfs_html_ga4c9ada0af73ad435588f0ec27a44f126"><div class="ttname"><a href="group__sys__vfs.html#ga4c9ada0af73ad435588f0ec27a44f126">NANOCOAP_FS_VFS_DIR_BUFFER_SIZE</a></div><div class="ttdeci">#define NANOCOAP_FS_VFS_DIR_BUFFER_SIZE</div><div class="ttdoc">VFS parameters for nanoCoAP FS. </div><div class="ttdef"><b>Definition:</b> <a href="vfs_8h_source.html#l00211">vfs.h:211</a></div></div>
<div class="ttc" id="group__sys__vfs_html_ga39a3ce949009b07b680210b57ace4650"><div class="ttname"><a href="group__sys__vfs.html#ga39a3ce949009b07b680210b57ace4650">LITTLEFS_VFS_DIR_BUFFER_SIZE</a></div><div class="ttdeci">#define LITTLEFS_VFS_DIR_BUFFER_SIZE</div><div class="ttdoc">VFS parameters for littlefs. </div><div class="ttdef"><b>Definition:</b> <a href="vfs_8h_source.html#l00157">vfs.h:157</a></div></div>
<div class="ttc" id="group__sys__vfs_html_gadc0ecc0a95f5e03d5199cbbc644fa543"><div class="ttname"><a href="group__sys__vfs.html#gadc0ecc0a95f5e03d5199cbbc644fa543">MAX6</a></div><div class="ttdeci">#define MAX6(a, b, c, d, e, f)</div><div class="ttdoc">MAX6 Function to get the largest of 6 values. </div><div class="ttdef"><b>Definition:</b> <a href="vfs_8h_source.html#l00085">vfs.h:85</a></div></div>
<div class="ttc" id="group__sys__vfs_html_ga0def0df1a3ac093ececed5dc59873b62"><div class="ttname"><a href="group__sys__vfs.html#ga0def0df1a3ac093ececed5dc59873b62">SPIFFS_VFS_DIR_BUFFER_SIZE</a></div><div class="ttdeci">#define SPIFFS_VFS_DIR_BUFFER_SIZE</div><div class="ttdoc">VFS parameters for spiffs. </div><div class="ttdef"><b>Definition:</b> <a href="vfs_8h_source.html#l00188">vfs.h:188</a></div></div>
<div class="ttc" id="group__sys__vfs_html_ga8bb076eda1b8d4f5176fec79314a020b"><div class="ttname"><a href="group__sys__vfs.html#ga8bb076eda1b8d4f5176fec79314a020b">LITTLEFS2_VFS_DIR_BUFFER_SIZE</a></div><div class="ttdeci">#define LITTLEFS2_VFS_DIR_BUFFER_SIZE</div><div class="ttdoc">VFS parameters for littlefs2. </div><div class="ttdef"><b>Definition:</b> <a href="vfs_8h_source.html#l00175">vfs.h:175</a></div></div>
<div class="ttc" id="group__sys__vfs_html_gaa976da80fd2af755c62ad0dc66eb7c57"><div class="ttname"><a href="group__sys__vfs.html#gaa976da80fd2af755c62ad0dc66eb7c57">LWEXT4_VFS_DIR_BUFFER_SIZE</a></div><div class="ttdeci">#define LWEXT4_VFS_DIR_BUFFER_SIZE</div><div class="ttdoc">VFS parameters for lwext4. </div><div class="ttdef"><b>Definition:</b> <a href="vfs_8h_source.html#l00198">vfs.h:198</a></div></div>
</div><!-- fragment -->
<p>Size of buffer space in <a class="el" href="structvfs__DIR.html" title="Internal representation of a file system directory entry. ">vfs_DIR</a>. </p>
<p>This space is needed to avoid dynamic memory allocations for some file systems where a single pointer is not enough space for its directory stream state, e.g. SPIFFS.</p>
<p>Guidelines:</p>
<p>SPIFFS requires a sizeof(spiffs_DIR) (6-16 bytes, depending on target platform and configuration) buffer for its DIR struct.</p>
<dl class="section attention"><dt>Attention</dt><dd>File system developers: If your file system requires a buffer for DIR streams that is larger than a single pointer or <code>int</code> variable, ensure that you have a preprocessor check in your header file (so that it is impossible to attempt to mount the file system without running into a compiler error):</dd>
<dd>
<div class="fragment"><div class="line"><span class="preprocessor">#if VFS_DIR_BUFFER_SIZE &lt; 123</span></div><div class="line"><span class="preprocessor">#error VFS_DIR_BUFFER_SIZE is too small, at least 123 bytes is required</span></div><div class="line"><span class="preprocessor">#endif</span></div></div><!-- fragment --></dd>
<dd>
Put the check in the public header file (.h), do not put the check in the implementation (.c) file. </dd></dl>

<p class="definition">Definition at line <a class="el" href="vfs_8h_source.html#l00256">256</a> of file <a class="el" href="vfs_8h_source.html">vfs.h</a>.</p>

</div>
</div>
<a id="ga6d9a9dcf98b4d4e4372cc476b8fe8eba"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga6d9a9dcf98b4d4e4372cc476b8fe8eba">&#9670;&nbsp;</a></span>VFS_FILE_BUFFER_SIZE</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define VFS_FILE_BUFFER_SIZE</td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Value:</b><div class="fragment"><div class="line"><a class="code" href="group__sys__vfs.html#gadc0ecc0a95f5e03d5199cbbc644fa543">MAX6</a>(FATFS_VFS_FILE_BUFFER_SIZE,      \</div><div class="line">                                  LITTLEFS_VFS_FILE_BUFFER_SIZE,   \</div><div class="line">                                  LITTLEFS2_VFS_FILE_BUFFER_SIZE,  \</div><div class="line">                                  SPIFFS_VFS_FILE_BUFFER_SIZE,     \</div><div class="line">                                  <a class="code" href="group__sys__vfs.html#ga6f5d3938070fb53e14cf28049e7d2b41">LWEXT4_VFS_FILE_BUFFER_SIZE</a>,     \</div><div class="line">                                  <a class="code" href="group__sys__vfs.html#ga1e049cb67cd3bca8c6b7b89a3e5525ee">NANOCOAP_FS_VFS_FILE_BUFFER_SIZE</a> \</div><div class="line">                                 )</div><div class="ttc" id="group__sys__vfs_html_ga6f5d3938070fb53e14cf28049e7d2b41"><div class="ttname"><a href="group__sys__vfs.html#ga6f5d3938070fb53e14cf28049e7d2b41">LWEXT4_VFS_FILE_BUFFER_SIZE</a></div><div class="ttdeci">#define LWEXT4_VFS_FILE_BUFFER_SIZE</div><div class="ttdoc">sizeof(ext4_file) </div><div class="ttdef"><b>Definition:</b> <a href="vfs_8h_source.html#l00199">vfs.h:199</a></div></div>
<div class="ttc" id="group__sys__vfs_html_gadc0ecc0a95f5e03d5199cbbc644fa543"><div class="ttname"><a href="group__sys__vfs.html#gadc0ecc0a95f5e03d5199cbbc644fa543">MAX6</a></div><div class="ttdeci">#define MAX6(a, b, c, d, e, f)</div><div class="ttdoc">MAX6 Function to get the largest of 6 values. </div><div class="ttdef"><b>Definition:</b> <a href="vfs_8h_source.html#l00085">vfs.h:85</a></div></div>
<div class="ttc" id="group__sys__vfs_html_ga1e049cb67cd3bca8c6b7b89a3e5525ee"><div class="ttname"><a href="group__sys__vfs.html#ga1e049cb67cd3bca8c6b7b89a3e5525ee">NANOCOAP_FS_VFS_FILE_BUFFER_SIZE</a></div><div class="ttdeci">#define NANOCOAP_FS_VFS_FILE_BUFFER_SIZE</div><div class="ttdoc">sizeof(nanocoap_fs_file_t) </div><div class="ttdef"><b>Definition:</b> <a href="vfs_8h_source.html#l00213">vfs.h:213</a></div></div>
</div><!-- fragment -->
<p>Size of buffer space in <a class="el" href="structvfs__file__t.html" title="Information about an open file. ">vfs_file_t</a>. </p>
<p>Same as with VFS_DIR_BUFFER_SIZE some file systems (e.g. FatFs) require more space to store data about their files.</p>
<p>Guidelines are same as with VFS_DIR_BUFFER_SIZE, so add the following snippet to your fs header:</p>
<dl class="section attention"><dt>Attention</dt><dd><div class="fragment"><div class="line"><span class="preprocessor">#if VFS_FILE_BUFFER_SIZE &lt; 123</span></div><div class="line"><span class="preprocessor">#error VFS_FILE_BUFFER_SIZE is too small, at least 123 bytes is required</span></div><div class="line"><span class="preprocessor">#endif</span></div></div><!-- fragment --></dd>
<dd>
Put the check in the public header file (.h), do not put the check in the implementation (.c) file. </dd></dl>

<p class="definition">Definition at line <a class="el" href="vfs_8h_source.html#l00285">285</a> of file <a class="el" href="vfs_8h_source.html">vfs.h</a>.</p>

</div>
</div>
<a id="ga6fdbbbfc8a5870cf706458d5c8419f9a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga6fdbbbfc8a5870cf706458d5c8419f9a">&#9670;&nbsp;</a></span>VFS_MTD</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define VFS_MTD</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">mtd</td><td>)</td>
          <td>&#160;&#160;&#160;{ .dev = &amp;mtd.base }</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Helper macro for VFS_AUTO_MOUNT. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">mtd</td><td>MTD device to use for filesystem </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="vfs_8h_source.html#l00315">315</a> of file <a class="el" href="vfs_8h_source.html">vfs.h</a>.</p>

</div>
</div>
<a id="ga818372246f79e5e859a10eb24517a3df"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga818372246f79e5e859a10eb24517a3df">&#9670;&nbsp;</a></span>VFS_NAME_MAX</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define VFS_NAME_MAX&#160;&#160;&#160;(31)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Maximum length of the name in a <code><a class="el" href="structvfs__dirent__t.html" title="User facing directory entry. ">vfs_dirent_t</a></code> (not including terminating null) </p>
<p>Maximum number of bytes in a filename (not including terminating null).</p>
<p>Similar to the POSIX macro NAME_MAX </p>

<p class="definition">Definition at line <a class="el" href="vfs_8h_source.html#l00302">302</a> of file <a class="el" href="vfs_8h_source.html">vfs.h</a>.</p>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a id="ga88894417c3313eece41cf4cb3a283d42"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga88894417c3313eece41cf4cb3a283d42">&#9670;&nbsp;</a></span>vfs_bind()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int vfs_bind </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>fd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>flags</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group__sys__vfs.html#gaae22046871c456cbbd1bca6298766b68">vfs_file_ops_t</a> *&#160;</td>
          <td class="paramname"><em>f_op</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>private_data</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Allocate a new file descriptor and give it file operations. </p>
<p>The new fd will be initialized with pointers to the given <code>f_op</code> file operations table and <code>private_data</code>.</p>
<p>This function can be used to give file-like functionality to devices, e.g. UART.</p>
<p><code>private_data</code> can be used for passing instance information to the file operation handlers in <code>f_op</code>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">fd</td><td>Desired fd number, use VFS_ANY_FD for any available fd </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">flags</td><td>not implemented yet </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">f_op</td><td>pointer to file operations table </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">private_data</td><td>opaque pointer to private data</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>fd number on success (&gt;= 0) </dd>
<dd>
&lt;0 on error </dd></dl>

</div>
</div>
<a id="ga9b760e38efd5f348b77e582954f0b141"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga9b760e38efd5f348b77e582954f0b141">&#9670;&nbsp;</a></span>vfs_bind_stdio()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void vfs_bind_stdio </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Allocate and bind file descriptors for STDIN, STDERR, and STDOUT. </p>
<p>This function is meant to be called once during system initialization time. It is typically called from the initialization of the selected STDIO implementation. </p>

</div>
</div>
<a id="ga60d1dba40888b0dadfbb4f0a30e1cb89"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga60d1dba40888b0dadfbb4f0a30e1cb89">&#9670;&nbsp;</a></span>vfs_close()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int vfs_close </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>fd</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Close an open file. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">fd</td><td>fd number to close</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 on success </dd>
<dd>
&lt;0 on error </dd></dl>

</div>
</div>
<a id="gaf3ffccb04f73042f1b1bdb63ca770e73"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaf3ffccb04f73042f1b1bdb63ca770e73">&#9670;&nbsp;</a></span>vfs_closedir()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int vfs_closedir </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structvfs__DIR.html">vfs_DIR</a> *&#160;</td>
          <td class="paramname"><em>dirp</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Close an open directory. </p>
<dl class="section attention"><dt>Attention</dt><dd>Calling vfs_closedir on an uninitialized <code><a class="el" href="structvfs__DIR.html" title="Internal representation of a file system directory entry. ">vfs_DIR</a></code> is forbidden and may lead to file system corruption and random system failures.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">dirp</td><td>pointer to open directory</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 on success </dd>
<dd>
&lt;0 on error, the directory stream dirp should be considered invalid </dd></dl>

</div>
</div>
<a id="gac8053fc8b584ba894953565b345f0d16"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gac8053fc8b584ba894953565b345f0d16">&#9670;&nbsp;</a></span>vfs_dstatvfs()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int vfs_dstatvfs </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structvfs__DIR.html">vfs_DIR</a> *&#160;</td>
          <td class="paramname"><em>dirp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="structstatvfs.html">statvfs</a> *&#160;</td>
          <td class="paramname"><em>buf</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get file system status of the file system containing an open directory. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">dirp</td><td>pointer to open directory </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">buf</td><td>pointer to statvfs struct to fill</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 on success </dd>
<dd>
&lt;0 on error </dd></dl>

</div>
</div>
<a id="gacfac67f4d58f160ca165336b95e14c76"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gacfac67f4d58f160ca165336b95e14c76">&#9670;&nbsp;</a></span>vfs_fcntl()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int vfs_fcntl </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>fd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>cmd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>arg</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Query/set options on an open file. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">fd</td><td>fd number to operate on </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">cmd</td><td>fcntl command, see man 3p fcntl </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">arg</td><td>argument to fcntl command, see man 3p fcntl</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 on success </dd>
<dd>
&lt;0 on error </dd></dl>

</div>
</div>
<a id="gaa717194c0d9d055711196323dd5cb8aa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaa717194c0d9d055711196323dd5cb8aa">&#9670;&nbsp;</a></span>vfs_file_get()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="structvfs__file__t.html">vfs_file_t</a>* vfs_file_get </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>fd</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get information about the file for internal purposes. </p>
<dl class="section attention"><dt>Attention</dt><dd>Not thread safe! Do not modify any of the fields in the returned struct. </dd></dl>
<dl class="section note"><dt>Note</dt><dd>For file descriptor internal usage only. </dd></dl>

</div>
</div>
<a id="ga85c6c8cab631ccd9ad61badb54d8ba10"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga85c6c8cab631ccd9ad61badb54d8ba10">&#9670;&nbsp;</a></span>vfs_format()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int vfs_format </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__sys__vfs.html#ga9fc6f9bb8f8b2f401e2bd7181cc4018f">vfs_mount_t</a> *&#160;</td>
          <td class="paramname"><em>mountp</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Format a file system. </p>
<p><code>mountp</code> should have been populated in advance with a file system driver, a mount point, and private_data (if the file system driver uses one).</p>
<dl class="section pre"><dt>Precondition</dt><dd><code>mountp</code> must not be mounted</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">mountp</td><td>pointer to the mount structure of the filesystem to format</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 on success </dd>
<dd>
&lt;0 on error </dd></dl>

</div>
</div>
<a id="ga8c6143529d99c05c153dc97147721104"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga8c6143529d99c05c153dc97147721104">&#9670;&nbsp;</a></span>vfs_format_by_path()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int vfs_format_by_path </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>path</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Format a file system. </p>
<p>The file system must not be mounted in order to be formatted. Call <a class="el" href="group__sys__vfs.html#gafe07bef032f76c753c773a7e7ee11e03">vfs_unmount_by_path</a> first if necessary.</p>
<dl class="section note"><dt>Note</dt><dd>This assumes mount points have been configured with <a class="el" href="group__sys__vfs.html#ga74c1713a82cbe6a385e552ed6427f0bb">VFS_AUTO_MOUNT</a>.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">path</td><td>Path of the pre-configured mount point</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 on success </dd>
<dd>
&lt;0 on error </dd></dl>

</div>
</div>
<a id="gad4649a984a7aa0643d157f8467d9c4ee"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gad4649a984a7aa0643d157f8467d9c4ee">&#9670;&nbsp;</a></span>vfs_fstat()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int vfs_fstat </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>fd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct stat *&#160;</td>
          <td class="paramname"><em>buf</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get status of an open file. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">fd</td><td>fd number obtained from vfs_open </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">buf</td><td>pointer to stat struct to fill</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 on success </dd>
<dd>
&lt;0 on error </dd></dl>

</div>
</div>
<a id="gaf67facc4f466ae49d9eef46437a47581"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaf67facc4f466ae49d9eef46437a47581">&#9670;&nbsp;</a></span>vfs_fstatvfs()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int vfs_fstatvfs </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>fd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="structstatvfs.html">statvfs</a> *&#160;</td>
          <td class="paramname"><em>buf</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get file system status of the file system containing an open file. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">fd</td><td>fd number obtained from vfs_open </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">buf</td><td>pointer to statvfs struct to fill</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 on success </dd>
<dd>
&lt;0 on error </dd></dl>

</div>
</div>
<a id="gab2566aeb152e97175242bf6edb45d0cc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gab2566aeb152e97175242bf6edb45d0cc">&#9670;&nbsp;</a></span>vfs_fsync()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int vfs_fsync </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>fd</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Synchronize a file on storage Any pending writes are written out to storage. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">fd</td><td>fd number obtained from vfs_open</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 on success </dd>
<dd>
&lt;0 on error </dd></dl>

</div>
</div>
<a id="gae972dfeffadbdccd3c878b279446baaa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gae972dfeffadbdccd3c878b279446baaa">&#9670;&nbsp;</a></span>vfs_iterate_mount_dirs()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool vfs_iterate_mount_dirs </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structvfs__DIR.html">vfs_DIR</a> *&#160;</td>
          <td class="paramname"><em>dir</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Iterate through all mounted file systems by their root directories. </p>
<p>Unlike <a class="el" href="group__sys__vfs.html#gafdbefec3679da1fed038f1fc42e8e821">vfs_iterate_mounts</a>, this is thread safe, and allows thread safe access to the mount point's stats through <a class="el" href="group__sys__vfs.html#gac8053fc8b584ba894953565b345f0d16">vfs_dstatvfs</a>. If mounts or unmounts happen while iterating, this is guaranteed to report all file systems that stayed mounted, and may report any that are transiently mounted for up to as often as they are (re)mounted. Note that the volume being reported can not be unmounted as <code>dir</code> is an open directory.</p>
<p>Zero-initialize <code>dir</code> to start. As long as <code>true</code> is returned, <code>dir</code> is a valid directory on which the user can call <a class="el" href="group__sys__vfs.html#ga81bb503b1aa7bb77d1d91170a0ea1b6d">vfs_readdir</a> or <a class="el" href="group__sys__vfs.html#gac8053fc8b584ba894953565b345f0d16">vfs_dstatvfs</a> (or even peek at its <code>.mp</code> if they dare ignore the warning in <a class="el" href="structvfs__DIR.html">vfs_DIR</a>).</p>
<p>Users MUST NOT call <a class="el" href="group__sys__vfs.html#gaf3ffccb04f73042f1b1bdb63ca770e73">vfs_closedir</a> if they intend to keep iterating, but MUST call it when aborting iteration.</p>
<p>Note that this requires all enumerated file systems to support the <code>opendir</code> <a class="el" href="structvfs__dir__ops.html">vfs_dir_ops</a>; any file system that does not support that will prematurely terminate the mount point enumeration.</p>
<dl class="section see"><dt>See also</dt><dd><code>sc_vfs.c</code> (<code>df</code> command) for a usage example</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">dir</td><td>The root directory of the discovered mount point</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if another file system is mounted; <code>dir</code> then contains an open directory. </dd>
<dd>
<code>false</code> if the file system list is exhausted; <code>dir</code> is uninitialized then. </dd></dl>

</div>
</div>
<a id="gafdbefec3679da1fed038f1fc42e8e821"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gafdbefec3679da1fed038f1fc42e8e821">&#9670;&nbsp;</a></span>vfs_iterate_mounts()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="group__sys__vfs.html#ga9fc6f9bb8f8b2f401e2bd7181cc4018f">vfs_mount_t</a>* vfs_iterate_mounts </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="group__sys__vfs.html#ga9fc6f9bb8f8b2f401e2bd7181cc4018f">vfs_mount_t</a> *&#160;</td>
          <td class="paramname"><em>cur</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Iterate through all mounted file systems. </p>
<dl class="section attention"><dt>Attention</dt><dd>Not thread safe! Do not mix calls to this function with other calls which modify the mount table, such as <a class="el" href="group__sys__vfs.html#ga188e99ea85dc9923550473e7e7b81500" title="Mount a file system. ">vfs_mount()</a> and <a class="el" href="group__sys__vfs.html#ga47aaf69f968a163cc65a2805d76c2bd9" title="Unmount a mounted file system. ">vfs_umount()</a></dd></dl>
<p>Set <code>cur</code> to <code>NULL</code> to start from the beginning</p>
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000035">Deprecated:</a></b></dt><dd>This will become an internal-only function after the 2022.04 release, use <a class="el" href="group__sys__vfs.html#gae972dfeffadbdccd3c878b279446baaa">vfs_iterate_mount_dirs</a> instead.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">cur</td><td>current iterator value</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Pointer to next mounted file system in list after <code>cur</code> </dd>
<dd>
NULL if <code>cur</code> is the last element in the list </dd></dl>

</div>
</div>
<a id="ga8280218c31e2cc294019433319c2d5aa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga8280218c31e2cc294019433319c2d5aa">&#9670;&nbsp;</a></span>vfs_lseek()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">off_t vfs_lseek </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>fd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">off_t&#160;</td>
          <td class="paramname"><em>off</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>whence</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Seek to position in file. </p>
<p><code>whence</code> determines the function of the seek and should be set to one of the following values:</p>
<ul>
<li><code>SEEK_SET:</code> Seek to absolute offset <code>off</code> </li>
<li><code>SEEK_CUR:</code> Seek to current location + <code>off</code> </li>
<li><code>SEEK_END:</code> Seek to end of file + <code>off</code> </li>
</ul>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">fd</td><td>fd number obtained from vfs_open </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">off</td><td>seek offset </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">whence</td><td>determines the seek method, see detailed description</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the new seek location in the file on success </dd>
<dd>
&lt;0 on error </dd></dl>

</div>
</div>
<a id="ga4351778a74bb39fd68256847b6a22c8c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga4351778a74bb39fd68256847b6a22c8c">&#9670;&nbsp;</a></span>vfs_mkdir()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int vfs_mkdir </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">mode_t&#160;</td>
          <td class="paramname"><em>mode</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create a directory on the file system. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">name</td><td>name of the directory to create </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">mode</td><td>file creation mode bits</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 on success </dd>
<dd>
&lt;0 on error </dd></dl>

</div>
</div>
<a id="ga188e99ea85dc9923550473e7e7b81500"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga188e99ea85dc9923550473e7e7b81500">&#9670;&nbsp;</a></span>vfs_mount()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int vfs_mount </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__sys__vfs.html#ga9fc6f9bb8f8b2f401e2bd7181cc4018f">vfs_mount_t</a> *&#160;</td>
          <td class="paramname"><em>mountp</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Mount a file system. </p>
<p><code>mountp</code> should have been populated in advance with a file system driver, a mount point, and private_data (if the file system driver uses one).</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">mountp</td><td>pointer to the mount structure of the file system to mount</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 on success </dd>
<dd>
&lt;0 on error </dd></dl>

</div>
</div>
<a id="gafe0112ee960e58b9216399294b87df08"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gafe0112ee960e58b9216399294b87df08">&#9670;&nbsp;</a></span>vfs_mount_by_path()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int vfs_mount_by_path </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>path</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Mount a file system with a pre-configured mount path. </p>
<dl class="section note"><dt>Note</dt><dd>This assumes mount points have been configured with <a class="el" href="group__sys__vfs.html#ga74c1713a82cbe6a385e552ed6427f0bb">VFS_AUTO_MOUNT</a>.</dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>If the <a class="el" href="group__pseudomodule__vfs__auto__format.html">vfs_auto_format</a> is used a format attempt will be made if the mount fails.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">path</td><td>Path of the pre-configured mount point</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 on success </dd>
<dd>
&lt;0 on error </dd></dl>

</div>
</div>
<a id="ga1a43fdb3d5de4d23eef9f39dccf90cae"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga1a43fdb3d5de4d23eef9f39dccf90cae">&#9670;&nbsp;</a></span>vfs_normalize_path()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int vfs_normalize_path </td>
          <td>(</td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>buf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>path</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>buflen</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Normalize a path. </p>
<p>Normalizing a path means to remove all relative components ("..", ".") and any double slashes.</p>
<dl class="section note"><dt>Note</dt><dd><code>buf</code> is allowed to overlap <code>path</code> if <code>&amp;buf</code>[0] &lt;= <code>&amp;path</code>[0]</dd></dl>
<dl class="section attention"><dt>Attention</dt><dd><code>path</code> must be an absolute path (starting with <code>/</code> )</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">buf</td><td>buffer to store normalized path </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">path</td><td>path to normalize </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">buflen</td><td>available space in <code>buf</code> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>number of path components in the normalized path on success </dd>
<dd>
&lt;0 on error </dd></dl>

</div>
</div>
<a id="ga208458bdb4b5da7c1330e5fa160e7fee"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga208458bdb4b5da7c1330e5fa160e7fee">&#9670;&nbsp;</a></span>vfs_open()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int vfs_open </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>flags</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">mode_t&#160;</td>
          <td class="paramname"><em>mode</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Open a file. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">name</td><td>file name to open </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">flags</td><td>flags for opening, see man 3p open </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">mode</td><td>file mode</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>fd number on success (&gt;= 0) </dd>
<dd>
&lt;0 on error </dd></dl>

</div>
</div>
<a id="gab28e72f381ff98931d9c2db584781162"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gab28e72f381ff98931d9c2db584781162">&#9670;&nbsp;</a></span>vfs_opendir()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int vfs_opendir </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structvfs__DIR.html">vfs_DIR</a> *&#160;</td>
          <td class="paramname"><em>dirp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>dirname</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Open a directory for reading with readdir. </p>
<p>The data in <code>*dirp</code> will be initialized by <code>vfs_opendir</code> </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">dirp</td><td>pointer to directory stream struct for storing the state </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">dirname</td><td>null-terminated name of the dir to open, absolute file system path</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 on success </dd>
<dd>
&lt;0 on error </dd></dl>

</div>
</div>
<a id="gae56830870bc891bd8617d08bc621c5ea"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gae56830870bc891bd8617d08bc621c5ea">&#9670;&nbsp;</a></span>vfs_read()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ssize_t vfs_read </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>fd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>dest</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>count</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Read bytes from an open file. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">fd</td><td>fd number obtained from vfs_open </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">dest</td><td>destination buffer to hold the file contents </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">count</td><td>maximum number of bytes to read</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>number of bytes read on success </dd>
<dd>
&lt;0 on error</dd></dl>
<p>For simple cases of only a single read from a file, the <a class="el" href="group__sys__vfs__util.html#gabc5fef30100a0c4fddd111bd05675543">vfs_file_to_buffer</a> function can be used. </p>

</div>
</div>
<a id="ga81bb503b1aa7bb77d1d91170a0ea1b6d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga81bb503b1aa7bb77d1d91170a0ea1b6d">&#9670;&nbsp;</a></span>vfs_readdir()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int vfs_readdir </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structvfs__DIR.html">vfs_DIR</a> *&#160;</td>
          <td class="paramname"><em>dirp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structvfs__dirent__t.html">vfs_dirent_t</a> *&#160;</td>
          <td class="paramname"><em>entry</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Read a single entry from the open directory dirp and advance the read position by one. </p>
<p><code>entry</code> will be populated with information about the next entry in the directory stream <code>dirp</code> </p>
<dl class="section attention"><dt>Attention</dt><dd>Calling vfs_readdir on an uninitialized <code><a class="el" href="structvfs__DIR.html" title="Internal representation of a file system directory entry. ">vfs_DIR</a></code> is forbidden and may lead to file system corruption and random system failures.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">dirp</td><td>pointer to open directory </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">entry</td><td>directory entry information</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>1 if <code>entry</code> was updated </dd>
<dd>
0 if <code>dirp</code> has reached the end of the directory index </dd>
<dd>
&lt;0 on error </dd></dl>

</div>
</div>
<a id="ga9ce2d59faff599decefb5fb9848fddca"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga9ce2d59faff599decefb5fb9848fddca">&#9670;&nbsp;</a></span>vfs_readline()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ssize_t vfs_readline </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>fd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>dest</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>count</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Read a line from an open text file. </p>
<p>Reads from a file until a <code>\r</code> or <code>\n</code> character is found.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">fd</td><td>fd number obtained from vfs_open </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">dest</td><td>destination buffer to hold the line </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">count</td><td>maximum number of characters to read</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>number of bytes read on success </dd>
<dd>
&lt;0 on error </dd></dl>

</div>
</div>
<a id="ga8d018700b625ff53592d50f4ef1c69a1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga8d018700b625ff53592d50f4ef1c69a1">&#9670;&nbsp;</a></span>vfs_rename()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int vfs_rename </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>from_path</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>to_path</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Rename a file. </p>
<p>The file <code>from_path</code> will be renamed to <code>to_path</code> </p>
<dl class="section note"><dt>Note</dt><dd>it is not possible to rename files across different file system</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">from_path</td><td>absolute path to existing file </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">to_path</td><td>absolute path to destination</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 on success </dd>
<dd>
&lt;0 on error </dd></dl>

</div>
</div>
<a id="gac9e6c31f4d15ed832cb5c61e0c6e9659"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gac9e6c31f4d15ed832cb5c61e0c6e9659">&#9670;&nbsp;</a></span>vfs_rmdir()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int vfs_rmdir </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>name</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Remove a directory from the file system. </p>
<p>Only empty directories may be removed.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">name</td><td>name of the directory to remove</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 on success </dd>
<dd>
&lt;0 on error </dd></dl>

</div>
</div>
<a id="ga9a4ef5ceb298c288b544cce1f7736aec"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga9a4ef5ceb298c288b544cce1f7736aec">&#9670;&nbsp;</a></span>vfs_stat()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int vfs_stat </td>
          <td>(</td>
          <td class="paramtype">const char *restrict&#160;</td>
          <td class="paramname"><em>path</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct stat *restrict&#160;</td>
          <td class="paramname"><em>buf</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get file status. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">path</td><td>path to file being queried </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">buf</td><td>pointer to stat struct to fill</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 on success </dd>
<dd>
&lt;0 on error </dd></dl>

</div>
</div>
<a id="ga2dd77a30a2ea9cc4531f40d089483b8e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga2dd77a30a2ea9cc4531f40d089483b8e">&#9670;&nbsp;</a></span>vfs_statvfs()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int vfs_statvfs </td>
          <td>(</td>
          <td class="paramtype">const char *restrict&#160;</td>
          <td class="paramname"><em>path</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="structstatvfs.html">statvfs</a> *restrict&#160;</td>
          <td class="paramname"><em>buf</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get file system status. </p>
<p><code>path</code> can be any path that resolves to the file system being queried, it does not have to be an existing file.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">path</td><td>path to a file on the file system being queried </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">buf</td><td>pointer to statvfs struct to fill</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 on success </dd>
<dd>
&lt;0 on error </dd></dl>

</div>
</div>
<a id="ga77f919082a5f2e395ad60fac39a821b9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga77f919082a5f2e395ad60fac39a821b9">&#9670;&nbsp;</a></span>vfs_sysop_stat_from_fstat()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int vfs_sysop_stat_from_fstat </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__sys__vfs.html#ga9fc6f9bb8f8b2f401e2bd7181cc4018f">vfs_mount_t</a> *&#160;</td>
          <td class="paramname"><em>mountp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *restrict&#160;</td>
          <td class="paramname"><em>path</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct stat *restrict&#160;</td>
          <td class="paramname"><em>buf</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Implementation of <code>stat</code> using <code>fstat</code> </p>
<p>This helper can be used by file system drivers that do not have any more efficient implementation of <code>fs_op::stat</code> than opening the file and running <code>f_op::fstat</code> on it.</p>
<p>It can be set as <code>fs_op::stat</code> by a file system driver, provided it implements <code>f_op::open</code> and <code>f_op::fstat</code> and <code>f_op::close</code>, and its <code>open</code> accepts <code>NULL</code> in the <code>abs_path</code> position. </p>

</div>
</div>
<a id="ga47aaf69f968a163cc65a2805d76c2bd9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga47aaf69f968a163cc65a2805d76c2bd9">&#9670;&nbsp;</a></span>vfs_umount()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int vfs_umount </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__sys__vfs.html#ga9fc6f9bb8f8b2f401e2bd7181cc4018f">vfs_mount_t</a> *&#160;</td>
          <td class="paramname"><em>mountp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>force</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Unmount a mounted file system. </p>
<p>This will fail if there are any open files or directories on the mounted file system</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">mountp</td><td>pointer to the mount structure of the file system to unmount </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">force</td><td>Unmount the filesystem even if there are still open files</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 on success </dd>
<dd>
&lt;0 on error </dd></dl>

</div>
</div>
<a id="gaadef8ee16be7695b8be4c151331df79c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaadef8ee16be7695b8be4c151331df79c">&#9670;&nbsp;</a></span>vfs_unlink()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int vfs_unlink </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>name</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Unlink (delete) a file from a mounted file system. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">name</td><td>name of file to delete</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 on success </dd>
<dd>
&lt;0 on error </dd></dl>

</div>
</div>
<a id="gafe07bef032f76c753c773a7e7ee11e03"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gafe07bef032f76c753c773a7e7ee11e03">&#9670;&nbsp;</a></span>vfs_unmount_by_path()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int vfs_unmount_by_path </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>path</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>force</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Unmount a file system with a pre-configured mount path. </p>
<dl class="section note"><dt>Note</dt><dd>This assumes mount points have been configured with <a class="el" href="group__sys__vfs.html#ga74c1713a82cbe6a385e552ed6427f0bb">VFS_AUTO_MOUNT</a>.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">path</td><td>Path of the pre-configured mount point </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">force</td><td>Unmount the filesystem even if there are still open files</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 on success </dd>
<dd>
&lt;0 on error </dd></dl>

</div>
</div>
<a id="ga3ab340fc28c34361e2b8206693e049d6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga3ab340fc28c34361e2b8206693e049d6">&#9670;&nbsp;</a></span>vfs_write()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ssize_t vfs_write </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>fd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>count</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Write bytes to an open file. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">fd</td><td>fd number obtained from vfs_open </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">src</td><td>pointer to source buffer </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">count</td><td>maximum number of bytes to write</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>number of bytes written on success </dd>
<dd>
&lt;0 on error</dd></dl>
<p>For simple cases of only a single write to a file, the <a class="el" href="group__sys__vfs__util.html#ga689f452ed167671ffc58ecd095a39967">vfs_file_from_buffer</a> function can be used. </p>

</div>
</div>
<a id="ga97f6250e54e0c0aa22d1d9efaaa67fc7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga97f6250e54e0c0aa22d1d9efaaa67fc7">&#9670;&nbsp;</a></span>vfs_write_iol()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ssize_t vfs_write_iol </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>fd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group__sys__iolist.html#gaa17f91ef26edec149cd806d8457aa3a0">iolist_t</a> *&#160;</td>
          <td class="paramname"><em>iolist</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Write bytes from an iolist to an open file. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">fd</td><td>fd number obtained from vfs_open </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">iolist</td><td>iolist to read from</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>number of bytes written on success </dd>
<dd>
&lt;0 on error </dd></dl>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
    <div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
        <ul>
            <li class="footer">Generated on Thu Mar 13 2025 10:38:35 by <a href="http://www.doxygen.org/index.html">
                       <img class="footer" src="doxygen.png" alt="doxygen"></a> 1.8.14</li>
        </ul>
    </div>
    <!-- Include all compiled plugins (below), or include individual files as needed -->
    <script src="bootstrap.min.js"></script>
    <script src="jquery.smartmenus.min.js"></script>
    <script src="jquery.smartmenus.bootstrap.min.js"></script>
    <script src="riot-doxy.js"></script>
  </body>
</html>
