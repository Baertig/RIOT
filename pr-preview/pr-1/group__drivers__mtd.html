<!DOCTYPE html>
<html lang="en">
  <head>
    <link rel="icon" type="image/png" href="favicon.png">
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <!-- The above 3 meta tags *must* come first in the head; any other head content must come *after* these tags -->
    <title>Memory Technology Device</title>
    <!-- jQuery (necessary for Bootstrap's JavaScript plugins) -->
    <script src="jquery.min.js"></script>
    <script src="jquery.powertip.min.js"></script>
    <script src="jquery-ui.min.js"></script>
    <script src="jquery.scrollTo.min.js"></script>
    <script src="doxy-jquery.js"></script>
    <script src="dynsections.js"></script>
    <link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
  $(document).ready(initResizable);
/* @license-end */</script>
    <link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
    <!-- Bootstrap -->
    <link href="doxygen.css" rel="stylesheet">
    <link href="fonts.css" rel="stylesheet">
    <link href="bootstrap.min.css" rel="stylesheet">
    <link href="jquery.smartmenus.bootstrap.css" rel="stylesheet">
    <link href="riot.css" rel="stylesheet">
    <!-- HTML5 shim and Respond.js for IE8 support of HTML5 elements and media queries -->
    <!-- WARNING: Respond.js doesn't work if you view the page via file:// -->
    <!--[if lt IE 9]>
      <script src="https://oss.maxcdn.com/html5shiv/3.7.3/html5shiv.min.js"></script>
      <script src="https://oss.maxcdn.com/respond/1.4.2/respond.min.js"></script>
    <![endif]-->
        <script>
            function displaySR(){
            searchBox.Search();
            var rhtml=(document.getElementById('MSearchResults').contentWindow.document.body.innerHTML).replace(/href=\"\.\.\//g,'href="');
            document.getElementById('MSearchResultsWindow').style.display='none';
            document.getElementById('top').append(document.getElementById('MSearchSelectWindow'));
            document.getElementById('top').append(document.getElementById('MSearchResultsWindow'));
            document.getElementById('doc-content').innerHTML=rhtml;
            }
            function modSearch(){
            if(!searchBox.doxySearch){
                searchBox.doxySearch=searchBox.Search
                searchBox.Search= function(){this.doxySearch();
                var r=document.getElementById('MSearchResultsWindow');console.log(r.style);
                if(parseInt(r.style.left)<0)r.style.left=0;
                var x=document.getElementById('MSearchResults');
                if(x.scrollWidth>window.screen.width)x.style.width=window.screen.width-2+'px';
                var f=document.getElementById('riot-searchform');
                if(parseInt( r.style.top) < f.offsetTop+f.scrollHeight) r.style.top = f.offsetTop+f.scrollHeight+'px';}
            }
            }
        </script>
  </head>
  <body>
      <div id="top">
        <nav class="navbar navbar-inverse">
          <div class="container-fluid">
            <!-- Brand and toggle get grouped for better mobile display -->
            <div class="navbar-header">
              <button type="button" class="navbar-toggle collapsed" data-toggle="collapse" data-target="#navbar-collapse" aria-expanded="false">
                <span class="sr-only">Toggle navigation</span>
                <span class="icon-bar"></span>
                <span class="icon-bar"></span>
                <span class="icon-bar"></span>
              </button>
              <a class="navbar-brand" id="brand-logo" href="http://riot-os.org"><img height="40px" src="riot-logo.svg" /></a>
              <p class="navbar-text text-center visible-xs">Documentation</p>
            </div>
            <!-- Collect the nav links, forms, and other content for toggling -->
            <div class="collapse navbar-collapse" id="navbar-collapse">
              <p class="navbar-text navbar-left"><span id="projectbrief">The friendly Operating System for the Internet of Things</span></p>
              <ul id="riot-navlist" class="nav navbar-nav"></ul>
              <form id="riot-searchform" class="navbar-form navbar-left navbar-right" action="https://duckduckgo.com/" method="get">
                 <input type="hidden" name="sites" value="doc.riot-os.org"/>
                 <input type="hidden" name="kt" value="h"/>
                 <div class="form-group">
                   <div id="MSearchBox" class="MSearchBoxActive">
                     <div class="input-group">
                       <div class="input-group-addon">
                         <span id="MSearchSelect" class="glyphicon glyphicon-search" aria-hidden="true" onmouseover="return searchBox.OnSearchSelectShow()" onmouseout="return searchBox.OnSearchSelectHide()"></span>
                       </div>
                       <input class="form-control" type="text" name="q" id="MSearchField" placeholder="Search" accesskey="S" onfocus="searchBox.OnSearchFieldFocus(true)" onblur="searchBox.OnSearchFieldFocus(false)" onkeyup="searchBox.OnSearchFieldChange(event); modSearch();">
                       <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()">
                         <span id="search-reset" class="glyphicon glyphicon-remove-circle" aria-hidden="true"></span>
                       </a>
                     </div>
                   </div>
                 </div>
              </form>
            </div><!-- /.navbar-collapse -->
          </div><!-- /.container-fluid -->
        </nav>
      </div>
<!-- Generated by Doxygen 1.8.14 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(document).ready(function(){initNavTree('group__drivers__mtd.html','');});
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#groups">Modules</a> &#124;
<a href="#files">Files</a> &#124;
<a href="#nested-classes">Data Structures</a> &#124;
<a href="#define-members">Macros</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#enum-members">Enumerations</a> &#124;
<a href="#func-members">Functions</a> &#124;
<a href="#var-members">Variables</a>  </div>
  <div class="headertitle">
<div class="title">Memory Technology Device<div class="ingroups"><a class="el" href="group__drivers.html">Drivers</a> &raquo; <a class="el" href="group__drivers__storage.html">Storage Device Drivers</a></div></div>  </div>
</div><!--header-->
<div class="contents">

<p>Low level Memory Technology Device interface.  
<a href="#details">More...</a></p>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<p>Low level Memory Technology Device interface. </p>
<p>Generic memory technology device interface</p>
<p>Unlike the <a class="el" href="group__drivers__periph__flashpage.html">Flash page driver</a>, this is device driver based (i.e. all functions take a <a class="el" href="structmtd__dev__t.html">mtd_dev_t</a> as a first argument), so that SPI based EEPROMs (e.g. <a class="el" href="group__drivers__mtd__at25xxx.html">AT25xxx</a>) can be accessed the same way as <a class="el" href="group__drivers__mtd__flashpage.html">internal flash</a> or <a class="el" href="group__drivers__mtd__sdcard.html">SD cards</a>), all inside the same application.</p>
<p>MTD devices expose a block based erase and write interface. In that, they are the distinct from block devices (like hard disks) on which individual bytes can be overwritten. The <a href="http://www.linux-mtd.infradead.org/faq/general.html">Linux MTD FAQ</a> has a convenient comparison (beware though of terminology differences outlined below). They can be erased (with some granularity, often wearing out the erased area a bit), and erased areas can be written to (sometimes multiple times).</p>
<p>MTD devices are described in terms of sectors, pages and feature flags:</p>
<ul>
<li><p class="startli">A <b>sector</b> is the device's erase unit. Calls to <a class="el" href="group__drivers__mtd.html#gaabab7f7b0b1cfcdbe2b32d2e26bbf4d7">mtd_erase</a> need to work in alignment with this number (commonly somewhere around 1kiB).</p>
<p class="startli">(Note that this corresponds to the term "page" as used in the flashpage API, and the term "eraseblock" in Linux's MTD).</p>
</li>
<li><p class="startli">A <b>page</b> is the largest a device can write in one transfer.</p>
<p class="startli">Applications rarely need to deal with this; it offers no guarantees on atomicity, but writing within a page is generally faster than across page boundaries.</p>
<p class="startli">Pages are a subdivision of sectors.</p>
</li>
<li><p class="startli">The <b>write size</b> is the minimum size of writes to the device, and also the required alignment of writes.</p>
<p class="startli">The write size is a divider of the page. It is often between 1 to 4 bytes long, but may be up to the full page size.</p>
</li>
<li>The device's <b>flags</b> indicate features, eg. whether a memory location can be overwritten without erasing it first.</li>
</ul>
<p>Unless a flag (such as <a class="el" href="group__drivers__mtd.html#gacd32ebfc4ee09f64d7e2490c4f5504fb">MTD_DRIVER_FLAG_DIRECT_WRITE</a> or <a class="el" href="group__drivers__mtd.html#ga08bad3026290086a5215b85bd1c62f51">MTD_DRIVER_FLAG_CLEARING_OVERWRITE</a>) allows it, this MTD API does not allow memory areas to be written to twice between erase operations. Drivers are not expected to count write accesses, and neither do this module's functions: The performance impact would be too great. It is up to the application to only write to erased memory once. Failure to do so may damage hardware.</p>
<p>This MTD API currently does not specify which value will be read from an erased sector. </p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="groups"></a>
Modules</h2></td></tr>
<tr class="memitem:group__drivers__mtd__emulated"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__drivers__mtd__emulated.html">MTD wrapper for emulated MTD devices</a></td></tr>
<tr class="memdesc:group__drivers__mtd__emulated"><td class="mdescLeft">&#160;</td><td class="mdescRight">MTD device that is emulated in RAM for test purposes. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:group__drivers__mtd__native"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__drivers__mtd__native.html">Native MTD</a></td></tr>
<tr class="memdesc:group__drivers__mtd__native"><td class="mdescLeft">&#160;</td><td class="mdescRight">mtd flash emulation for native <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="files"></a>
Files</h2></td></tr>
<tr class="memitem:mtd_8h"><td class="memItemLeft" align="right" valign="top">file &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="mtd_8h.html">mtd.h</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Data Structures</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmtd__dev__t.html">mtd_dev_t</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">MTD device descriptor.  <a href="structmtd__dev__t.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmtd__desc.html">mtd_desc</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">MTD driver interface.  <a href="structmtd__desc.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="define-members"></a>
Macros</h2></td></tr>
<tr class="memitem:gaf0ba0e302d3f3711c691fdfbda1461ac"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__drivers__mtd.html#gaf0ba0e302d3f3711c691fdfbda1461ac">MTD_XFA_ADD</a>(dev,  idx)&#160;&#160;&#160;<a class="el" href="xfa_8h.html#a9b3e8f506ebeefc418799a13904fec38">XFA_CONST</a>(<a class="el" href="structmtd__dev__t.html">mtd_dev_t</a>, <a class="el" href="group__drivers__mtd.html#ga290552e29a4074f1b34c0067e39886df">mtd_dev_xfa</a>, idx) *mtd ## idx = (<a class="el" href="structmtd__dev__t.html">mtd_dev_t</a> *)&amp;(dev)</td></tr>
<tr class="memdesc:gaf0ba0e302d3f3711c691fdfbda1461ac"><td class="mdescLeft">&#160;</td><td class="mdescRight">Define MTD device pointer variable <code>mtd&lt;idx&gt;</code>  <a href="#gaf0ba0e302d3f3711c691fdfbda1461ac">More...</a><br /></td></tr>
<tr class="separator:gaf0ba0e302d3f3711c691fdfbda1461ac"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaed6dda925a94ee38ebfa0b6105461893"><td class="memItemLeft" align="right" valign="top"><a id="gaed6dda925a94ee38ebfa0b6105461893"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__drivers__mtd.html#gaed6dda925a94ee38ebfa0b6105461893">MTD_NUMOF</a>&#160;&#160;&#160;<a class="el" href="xfa_8h.html#ad15d5dae13c2d1ffdab3fd64d78e1b4b">XFA_LEN</a>(<a class="el" href="structmtd__dev__t.html">mtd_dev_t</a> *, <a class="el" href="group__drivers__mtd.html#ga290552e29a4074f1b34c0067e39886df">mtd_dev_xfa</a>)</td></tr>
<tr class="memdesc:gaed6dda925a94ee38ebfa0b6105461893"><td class="mdescLeft">&#160;</td><td class="mdescRight">Number of MTDs defined in the MTD device array in XFA. <br /></td></tr>
<tr class="separator:gaed6dda925a94ee38ebfa0b6105461893"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gacd32ebfc4ee09f64d7e2490c4f5504fb"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__drivers__mtd.html#gacd32ebfc4ee09f64d7e2490c4f5504fb">MTD_DRIVER_FLAG_DIRECT_WRITE</a>&#160;&#160;&#160;(1 &lt;&lt; 0)</td></tr>
<tr class="memdesc:gacd32ebfc4ee09f64d7e2490c4f5504fb"><td class="mdescLeft">&#160;</td><td class="mdescRight">MTD driver can write any data to the storage without erasing it first.  <a href="#gacd32ebfc4ee09f64d7e2490c4f5504fb">More...</a><br /></td></tr>
<tr class="separator:gacd32ebfc4ee09f64d7e2490c4f5504fb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga08bad3026290086a5215b85bd1c62f51"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__drivers__mtd.html#ga08bad3026290086a5215b85bd1c62f51">MTD_DRIVER_FLAG_CLEARING_OVERWRITE</a>&#160;&#160;&#160;(1 &lt;&lt; 1)</td></tr>
<tr class="memdesc:ga08bad3026290086a5215b85bd1c62f51"><td class="mdescLeft">&#160;</td><td class="mdescRight">MTD driver supports arbitrary clearing overwrites.  <a href="#ga08bad3026290086a5215b85bd1c62f51">More...</a><br /></td></tr>
<tr class="separator:ga08bad3026290086a5215b85bd1c62f51"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:ga016431acc3cc8d6f5a40149225dabc05"><td class="memItemLeft" align="right" valign="top">typedef struct <a class="el" href="structmtd__desc.html">mtd_desc</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__drivers__mtd.html#ga016431acc3cc8d6f5a40149225dabc05">mtd_desc_t</a></td></tr>
<tr class="memdesc:ga016431acc3cc8d6f5a40149225dabc05"><td class="mdescLeft">&#160;</td><td class="mdescRight">MTD driver interface.  <a href="#ga016431acc3cc8d6f5a40149225dabc05">More...</a><br /></td></tr>
<tr class="separator:ga016431acc3cc8d6f5a40149225dabc05"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="enum-members"></a>
Enumerations</h2></td></tr>
<tr class="memitem:ga2e588df22ed1a520ba154adbd93b1455"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__drivers__mtd.html#ga2e588df22ed1a520ba154adbd93b1455">mtd_power_state</a> { <a class="el" href="group__drivers__mtd.html#gga2e588df22ed1a520ba154adbd93b1455a860be5ff4a3cfb933b479391d2538939">MTD_POWER_UP</a>, 
<a class="el" href="group__drivers__mtd.html#gga2e588df22ed1a520ba154adbd93b1455a81eb56a249bbf2eebd5cfbd8ef2c7ce8">MTD_POWER_DOWN</a>
 }</td></tr>
<tr class="memdesc:ga2e588df22ed1a520ba154adbd93b1455"><td class="mdescLeft">&#160;</td><td class="mdescRight">MTD power states.  <a href="group__drivers__mtd.html#ga2e588df22ed1a520ba154adbd93b1455">More...</a><br /></td></tr>
<tr class="separator:ga2e588df22ed1a520ba154adbd93b1455"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:ga6bcf582eaf56330ea31c1162ea535076"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__drivers__mtd.html#ga6bcf582eaf56330ea31c1162ea535076">mtd_init</a> (<a class="el" href="structmtd__dev__t.html">mtd_dev_t</a> *mtd)</td></tr>
<tr class="memdesc:ga6bcf582eaf56330ea31c1162ea535076"><td class="mdescLeft">&#160;</td><td class="mdescRight">mtd_init Initialize a MTD device  <a href="#ga6bcf582eaf56330ea31c1162ea535076">More...</a><br /></td></tr>
<tr class="separator:ga6bcf582eaf56330ea31c1162ea535076"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga74ffca1da0436aada58ef3f18f469e36"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__drivers__mtd.html#ga74ffca1da0436aada58ef3f18f469e36">mtd_read</a> (<a class="el" href="structmtd__dev__t.html">mtd_dev_t</a> *mtd, void *dest, uint32_t addr, uint32_t count)</td></tr>
<tr class="memdesc:ga74ffca1da0436aada58ef3f18f469e36"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read data from a MTD device.  <a href="#ga74ffca1da0436aada58ef3f18f469e36">More...</a><br /></td></tr>
<tr class="separator:ga74ffca1da0436aada58ef3f18f469e36"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8b72c0b58ed1f5a3ff4cc7cd4965dd83"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__drivers__mtd.html#ga8b72c0b58ed1f5a3ff4cc7cd4965dd83">mtd_read_page</a> (<a class="el" href="structmtd__dev__t.html">mtd_dev_t</a> *mtd, void *dest, uint32_t page, uint32_t offset, uint32_t size)</td></tr>
<tr class="memdesc:ga8b72c0b58ed1f5a3ff4cc7cd4965dd83"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read data from a MTD device with pagewise addressing.  <a href="#ga8b72c0b58ed1f5a3ff4cc7cd4965dd83">More...</a><br /></td></tr>
<tr class="separator:ga8b72c0b58ed1f5a3ff4cc7cd4965dd83"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5f36fb25e0daada2e9a873475c532d94"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__drivers__mtd.html#ga5f36fb25e0daada2e9a873475c532d94">mtd_write</a> (<a class="el" href="structmtd__dev__t.html">mtd_dev_t</a> *mtd, const void *src, uint32_t addr, uint32_t count)</td></tr>
<tr class="memdesc:ga5f36fb25e0daada2e9a873475c532d94"><td class="mdescLeft">&#160;</td><td class="mdescRight">Write data to a MTD device.  <a href="#ga5f36fb25e0daada2e9a873475c532d94">More...</a><br /></td></tr>
<tr class="separator:ga5f36fb25e0daada2e9a873475c532d94"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6cb5d1eed19f88f4e4b970541f7dcbf6"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__drivers__mtd.html#ga6cb5d1eed19f88f4e4b970541f7dcbf6">mtd_write_page_raw</a> (<a class="el" href="structmtd__dev__t.html">mtd_dev_t</a> *mtd, const void *src, uint32_t page, uint32_t offset, uint32_t size)</td></tr>
<tr class="memdesc:ga6cb5d1eed19f88f4e4b970541f7dcbf6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Write data to a MTD device with pagewise addressing.  <a href="#ga6cb5d1eed19f88f4e4b970541f7dcbf6">More...</a><br /></td></tr>
<tr class="separator:ga6cb5d1eed19f88f4e4b970541f7dcbf6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad52a5002206227b278f6cbb1efb605d3"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__drivers__mtd.html#gad52a5002206227b278f6cbb1efb605d3">mtd_write_page</a> (<a class="el" href="structmtd__dev__t.html">mtd_dev_t</a> *mtd, const void *src, uint32_t page, uint32_t offset, uint32_t size)</td></tr>
<tr class="memdesc:gad52a5002206227b278f6cbb1efb605d3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Write data to a MTD device with pagewise addressing.  <a href="#gad52a5002206227b278f6cbb1efb605d3">More...</a><br /></td></tr>
<tr class="separator:gad52a5002206227b278f6cbb1efb605d3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaabab7f7b0b1cfcdbe2b32d2e26bbf4d7"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__drivers__mtd.html#gaabab7f7b0b1cfcdbe2b32d2e26bbf4d7">mtd_erase</a> (<a class="el" href="structmtd__dev__t.html">mtd_dev_t</a> *mtd, uint32_t addr, uint32_t count)</td></tr>
<tr class="memdesc:gaabab7f7b0b1cfcdbe2b32d2e26bbf4d7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Erase sectors of a MTD device.  <a href="#gaabab7f7b0b1cfcdbe2b32d2e26bbf4d7">More...</a><br /></td></tr>
<tr class="separator:gaabab7f7b0b1cfcdbe2b32d2e26bbf4d7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf9c761bda55271360e1797491ef2ef7f"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__drivers__mtd.html#gaf9c761bda55271360e1797491ef2ef7f">mtd_erase_sector</a> (<a class="el" href="structmtd__dev__t.html">mtd_dev_t</a> *mtd, uint32_t sector, uint32_t num)</td></tr>
<tr class="memdesc:gaf9c761bda55271360e1797491ef2ef7f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Erase sectors of a MTD device.  <a href="#gaf9c761bda55271360e1797491ef2ef7f">More...</a><br /></td></tr>
<tr class="separator:gaf9c761bda55271360e1797491ef2ef7f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga40c7db24bb97158581694edc4eaf20aa"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__drivers__mtd.html#ga40c7db24bb97158581694edc4eaf20aa">mtd_write_sector</a> (<a class="el" href="structmtd__dev__t.html">mtd_dev_t</a> *mtd, const void *src, uint32_t sector, uint32_t num)</td></tr>
<tr class="memdesc:ga40c7db24bb97158581694edc4eaf20aa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Write data to a MTD device with whole sector writes.  <a href="#ga40c7db24bb97158581694edc4eaf20aa">More...</a><br /></td></tr>
<tr class="separator:ga40c7db24bb97158581694edc4eaf20aa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf44f35470c2180ebd4b772f3b25d31fc"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__drivers__mtd.html#gaf44f35470c2180ebd4b772f3b25d31fc">mtd_power</a> (<a class="el" href="structmtd__dev__t.html">mtd_dev_t</a> *mtd, enum <a class="el" href="group__drivers__mtd.html#ga2e588df22ed1a520ba154adbd93b1455">mtd_power_state</a> power)</td></tr>
<tr class="memdesc:gaf44f35470c2180ebd4b772f3b25d31fc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set power mode on a MTD device.  <a href="#gaf44f35470c2180ebd4b772f3b25d31fc">More...</a><br /></td></tr>
<tr class="separator:gaf44f35470c2180ebd4b772f3b25d31fc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1bc58d81d002e150ccb418701d38b43e"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="structmtd__dev__t.html">mtd_dev_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__drivers__mtd.html#ga1bc58d81d002e150ccb418701d38b43e">mtd_dev_get</a> (unsigned idx)</td></tr>
<tr class="memdesc:ga1bc58d81d002e150ccb418701d38b43e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get an MTD device by index.  <a href="#ga1bc58d81d002e150ccb418701d38b43e">More...</a><br /></td></tr>
<tr class="separator:ga1bc58d81d002e150ccb418701d38b43e"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="var-members"></a>
Variables</h2></td></tr>
<tr class="memitem:ga290552e29a4074f1b34c0067e39886df"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structmtd__dev__t.html">mtd_dev_t</a> *const&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__drivers__mtd.html#ga290552e29a4074f1b34c0067e39886df">mtd_dev_xfa</a> []</td></tr>
<tr class="memdesc:ga290552e29a4074f1b34c0067e39886df"><td class="mdescLeft">&#160;</td><td class="mdescRight">MTD device array as XFA.  <a href="#ga290552e29a4074f1b34c0067e39886df">More...</a><br /></td></tr>
<tr class="separator:ga290552e29a4074f1b34c0067e39886df"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac78b5f9518323fccc3a6b9c16d0a6261"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="structmtd__dev__t.html">mtd_dev_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__drivers__mtd.html#gac78b5f9518323fccc3a6b9c16d0a6261">mtd_default_get_dev</a> (unsigned idx)</td></tr>
<tr class="memdesc:gac78b5f9518323fccc3a6b9c16d0a6261"><td class="mdescLeft">&#160;</td><td class="mdescRight">Default MTD device configuration.  <a href="#gac78b5f9518323fccc3a6b9c16d0a6261">More...</a><br /></td></tr>
<tr class="separator:gac78b5f9518323fccc3a6b9c16d0a6261"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Macro Definition Documentation</h2>
<a id="ga08bad3026290086a5215b85bd1c62f51"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga08bad3026290086a5215b85bd1c62f51">&#9670;&nbsp;</a></span>MTD_DRIVER_FLAG_CLEARING_OVERWRITE</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define MTD_DRIVER_FLAG_CLEARING_OVERWRITE&#160;&#160;&#160;(1 &lt;&lt; 1)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>MTD driver supports arbitrary clearing overwrites. </p>
<p>If this is set, (arbitrarily) many writes are permitted per write size, and the result is the old value bitwise-AND the written value.</p>
<p>This property is common for managed flash memories. (By comparison, the raw flash often used internally by MCUs may not allow overwrites, or may allow them with the same semantics, but only for a limited number of writes between erasures; there is currently no flag describing these any further). </p>

<p class="definition">Definition at line <a class="el" href="mtd_8h_source.html#l00192">192</a> of file <a class="el" href="mtd_8h_source.html">mtd.h</a>.</p>

</div>
</div>
<a id="gacd32ebfc4ee09f64d7e2490c4f5504fb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gacd32ebfc4ee09f64d7e2490c4f5504fb">&#9670;&nbsp;</a></span>MTD_DRIVER_FLAG_DIRECT_WRITE</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define MTD_DRIVER_FLAG_DIRECT_WRITE&#160;&#160;&#160;(1 &lt;&lt; 0)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>MTD driver can write any data to the storage without erasing it first. </p>
<p>If this is set, a write completely overrides the previous values. </p>

<p class="definition">Definition at line <a class="el" href="mtd_8h_source.html#l00179">179</a> of file <a class="el" href="mtd_8h_source.html">mtd.h</a>.</p>

</div>
</div>
<a id="gaf0ba0e302d3f3711c691fdfbda1461ac"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaf0ba0e302d3f3711c691fdfbda1461ac">&#9670;&nbsp;</a></span>MTD_XFA_ADD</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define MTD_XFA_ADD</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">dev, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">idx&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td>&#160;&#160;&#160;<a class="el" href="xfa_8h.html#a9b3e8f506ebeefc418799a13904fec38">XFA_CONST</a>(<a class="el" href="structmtd__dev__t.html">mtd_dev_t</a>, <a class="el" href="group__drivers__mtd.html#ga290552e29a4074f1b34c0067e39886df">mtd_dev_xfa</a>, idx) *mtd ## idx = (<a class="el" href="structmtd__dev__t.html">mtd_dev_t</a> *)&amp;(dev)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Define MTD device pointer variable <code>mtd&lt;idx&gt;</code> </p>
<p>The macro defines the MTD device pointer variable <code>mtd&lt;idx&gt;</code>, sets it to the address of the MTD device specified by the <code>dev</code> parameter, and adds it to the XFA of MTD device pointers <a class="el" href="group__drivers__mtd.html#ga290552e29a4074f1b34c0067e39886df">mtd_dev_xfa</a>. For example </p><div class="fragment"><div class="line"><a class="code" href="group__drivers__mtd.html#gaf0ba0e302d3f3711c691fdfbda1461ac">MTD_XFA_ADD</a>(my_dev, 1);</div></div><!-- fragment --><p> defines the variable <code>mtd1</code> pointing to the device <code>my_dev</code>.</p>
<p>The parameter <code>idx</code> is used as priority of the MTD device pointer within the XFA. That means it determines the order of the MTD device pointers within <a class="el" href="group__drivers__mtd.html#ga290552e29a4074f1b34c0067e39886df">mtd_dev_xfa</a>.</p>
<dl class="section note"><dt>Note</dt><dd>Only if each MTD device is added with a unique priority and only if the priorities start at 0 and are used in consecutive order, the parameter <code>idx</code> corresponds to the position of the MTD device pointer within the <a class="el" href="group__drivers__mtd.html#ga290552e29a4074f1b34c0067e39886df">mtd_dev_xfa</a> XFA and <code>mtd_dev_xfa[i]</code> points to the i-th MTD device.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dev</td><td>MTD device </td></tr>
    <tr><td class="paramname">idx</td><td>Priority of the MTD device pointer within the XFA </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="mtd_8h_source.html#l00166">166</a> of file <a class="el" href="mtd_8h_source.html">mtd.h</a>.</p>

</div>
</div>
<h2 class="groupheader">Typedef Documentation</h2>
<a id="ga016431acc3cc8d6f5a40149225dabc05"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga016431acc3cc8d6f5a40149225dabc05">&#9670;&nbsp;</a></span>mtd_desc_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef struct <a class="el" href="structmtd__desc.html">mtd_desc</a> <a class="el" href="group__drivers__mtd.html#ga016431acc3cc8d6f5a40149225dabc05">mtd_desc_t</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>MTD driver interface. </p>
<p>This define the functions to access a MTD.</p>
<p>A MTD is composed of pages combined into sectors. A sector is the smallest erasable unit. The number of pages in a sector must be constant for the whole MTD.</p>
<p>The erase operation is available only for entire sectors. </p>

<p class="definition">Definition at line <a class="el" href="mtd_8h_source.html#l00104">104</a> of file <a class="el" href="mtd_8h_source.html">mtd.h</a>.</p>

</div>
</div>
<h2 class="groupheader">Enumeration Type Documentation</h2>
<a id="ga2e588df22ed1a520ba154adbd93b1455"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga2e588df22ed1a520ba154adbd93b1455">&#9670;&nbsp;</a></span>mtd_power_state</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="group__drivers__mtd.html#ga2e588df22ed1a520ba154adbd93b1455">mtd_power_state</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>MTD power states. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="gga2e588df22ed1a520ba154adbd93b1455a860be5ff4a3cfb933b479391d2538939"></a>MTD_POWER_UP&#160;</td><td class="fielddoc"><p>Power up. </p>
</td></tr>
<tr><td class="fieldname"><a id="gga2e588df22ed1a520ba154adbd93b1455a81eb56a249bbf2eebd5cfbd8ef2c7ce8"></a>MTD_POWER_DOWN&#160;</td><td class="fielddoc"><p>Power down. </p>
</td></tr>
</table>

<p class="definition">Definition at line <a class="el" href="mtd_8h_source.html#l00089">89</a> of file <a class="el" href="mtd_8h_source.html">mtd.h</a>.</p>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a id="gac78b5f9518323fccc3a6b9c16d0a6261"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gac78b5f9518323fccc3a6b9c16d0a6261">&#9670;&nbsp;</a></span>mtd_default_get_dev()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="structmtd__dev__t.html">mtd_dev_t</a>* mtd_default_get_dev </td>
          <td>(</td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>idx</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Default MTD device configuration. </p>
<p>Helpers for generic MTD use.</p>
<dl class="section author"><dt>Author</dt><dd>Benjamin Valentin <a href="#" onclick="location.href='mai'+'lto:'+'ben'+'ja'+'min'+'.v'+'ale'+'nt'+'in@'+'ml'+'-pa'+'.c'+'om'; return false;">benja<span style="display: none;">.nosp@m.</span>min.<span style="display: none;">.nosp@m.</span>valen<span style="display: none;">.nosp@m.</span>tin@<span style="display: none;">.nosp@m.</span>ml-pa<span style="display: none;">.nosp@m.</span>.com</a> Get the default MTD device by index</dd></dl>
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000007">Deprecated:</a></b></dt><dd>Use <a class="el" href="group__drivers__mtd.html#ga1bc58d81d002e150ccb418701d38b43e">mtd_dev_get</a> instead</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">idx</td><td>Index of the MTD device</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>MTD_0 for <code>idx</code> 0 and so on NULL if no MTD device exists for the given index </dd></dl>

<p class="definition">Definition at line <a class="el" href="mtd__default_8h_source.html#l00054">54</a> of file <a class="el" href="mtd__default_8h_source.html">mtd_default.h</a>.</p>

</div>
</div>
<a id="ga1bc58d81d002e150ccb418701d38b43e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga1bc58d81d002e150ccb418701d38b43e">&#9670;&nbsp;</a></span>mtd_dev_get()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="structmtd__dev__t.html">mtd_dev_t</a>* mtd_dev_get </td>
          <td>(</td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>idx</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get an MTD device by index. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">idx</td><td>Index of the MTD device</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>MTD_0 for <code>idx</code> 0 and so on NULL if no MTD device exists for the given index </dd></dl>

<p class="definition">Definition at line <a class="el" href="mtd_8h_source.html#l00535">535</a> of file <a class="el" href="mtd_8h_source.html">mtd.h</a>.</p>

</div>
</div>
<a id="gaabab7f7b0b1cfcdbe2b32d2e26bbf4d7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaabab7f7b0b1cfcdbe2b32d2e26bbf4d7">&#9670;&nbsp;</a></span>mtd_erase()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int mtd_erase </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structmtd__dev__t.html">mtd_dev_t</a> *&#160;</td>
          <td class="paramname"><em>mtd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>addr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>count</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Erase sectors of a MTD device. </p>
<p><code>addr</code> must be aligned on a sector boundary. <code>count</code> must be a multiple of a sector size.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">mtd</td><td>the device to erase </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">addr</td><td>the address of the first sector to erase </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">count</td><td>the number of bytes to erase</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">0</td><td>if erase successful </td></tr>
    <tr><td class="paramname">&lt;0</td><td>if an error occurred </td></tr>
    <tr><td class="paramname">-ENODEV</td><td>if <code>mtd</code> is not a valid device </td></tr>
    <tr><td class="paramname">-ENOTSUP</td><td>if operation is not supported on <code>mtd</code> </td></tr>
    <tr><td class="paramname">-EOVERFLOW</td><td>if <code>addr</code> or <code>count</code> are not valid, i.e. outside memory </td></tr>
    <tr><td class="paramname">-EIO</td><td>if I/O error occurred </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gaf9c761bda55271360e1797491ef2ef7f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaf9c761bda55271360e1797491ef2ef7f">&#9670;&nbsp;</a></span>mtd_erase_sector()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int mtd_erase_sector </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structmtd__dev__t.html">mtd_dev_t</a> *&#160;</td>
          <td class="paramname"><em>mtd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>sector</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>num</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Erase sectors of a MTD device. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">mtd</td><td>the device to erase </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">sector</td><td>the first sector number to erase </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">num</td><td>the number of sectors to erase</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">0</td><td>if erase successful </td></tr>
    <tr><td class="paramname">&lt;0</td><td>if an error occurred </td></tr>
    <tr><td class="paramname">-ENODEV</td><td>if <code>mtd</code> is not a valid device </td></tr>
    <tr><td class="paramname">-ENOTSUP</td><td>if operation is not supported on <code>mtd</code> </td></tr>
    <tr><td class="paramname">-EOVERFLOW</td><td>if <code>addr</code> or <code>sector</code> are not valid, i.e. outside memory </td></tr>
    <tr><td class="paramname">-EIO</td><td>if I/O error occurred </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga6bcf582eaf56330ea31c1162ea535076"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga6bcf582eaf56330ea31c1162ea535076">&#9670;&nbsp;</a></span>mtd_init()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int mtd_init </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structmtd__dev__t.html">mtd_dev_t</a> *&#160;</td>
          <td class="paramname"><em>mtd</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>mtd_init Initialize a MTD device </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">mtd</td><td>the device to initialize</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">0</td><td>on success </td></tr>
    <tr><td class="paramname">&lt;0</td><td>on error probably errno </td></tr>
    <tr><td class="paramname">-ENODEV</td><td>if no device if given or no driver is set </td></tr>
    <tr><td class="paramname">-ENOTSUP</td><td>if device has no init function </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gaf44f35470c2180ebd4b772f3b25d31fc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaf44f35470c2180ebd4b772f3b25d31fc">&#9670;&nbsp;</a></span>mtd_power()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int mtd_power </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structmtd__dev__t.html">mtd_dev_t</a> *&#160;</td>
          <td class="paramname"><em>mtd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">enum <a class="el" href="group__drivers__mtd.html#ga2e588df22ed1a520ba154adbd93b1455">mtd_power_state</a>&#160;</td>
          <td class="paramname"><em>power</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set power mode on a MTD device. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">mtd</td><td>the device to access </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">power</td><td>the power mode to set</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">0</td><td>if power mode successfully set </td></tr>
    <tr><td class="paramname">&lt;0</td><td>if an error occurred </td></tr>
    <tr><td class="paramname">-ENODEV</td><td>if <code>mtd</code> is not a valid device </td></tr>
    <tr><td class="paramname">-ENOTSUP</td><td>if operation or <code>power</code> state is not supported on <code>mtd</code> </td></tr>
    <tr><td class="paramname">-EIO</td><td>if I/O error occurred </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga74ffca1da0436aada58ef3f18f469e36"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga74ffca1da0436aada58ef3f18f469e36">&#9670;&nbsp;</a></span>mtd_read()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int mtd_read </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structmtd__dev__t.html">mtd_dev_t</a> *&#160;</td>
          <td class="paramname"><em>mtd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>dest</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>addr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>count</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Read data from a MTD device. </p>
<p>No alignment is required on <code>addr</code> and <code>count</code>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">mtd</td><td>the device to read from </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">dest</td><td>the buffer to fill in </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">addr</td><td>the start address to read from </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">count</td><td>the number of bytes to read</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">0</td><td>on success </td></tr>
    <tr><td class="paramname">&lt;0</td><td>if an error occurred </td></tr>
    <tr><td class="paramname">-ENODEV</td><td>if <code>mtd</code> is not a valid device </td></tr>
    <tr><td class="paramname">-ENOTSUP</td><td>if operation is not supported on <code>mtd</code> </td></tr>
    <tr><td class="paramname">-EOVERFLOW</td><td>if <code>addr</code> or <code>count</code> are not valid, i.e. outside memory </td></tr>
    <tr><td class="paramname">-EIO</td><td>if I/O error occurred </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga8b72c0b58ed1f5a3ff4cc7cd4965dd83"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga8b72c0b58ed1f5a3ff4cc7cd4965dd83">&#9670;&nbsp;</a></span>mtd_read_page()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int mtd_read_page </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structmtd__dev__t.html">mtd_dev_t</a> *&#160;</td>
          <td class="paramname"><em>mtd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>dest</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>page</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>offset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Read data from a MTD device with pagewise addressing. </p>
<p>The MTD layer will take care of splitting up the transaction into multiple reads if it is required by the underlying storage media.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">mtd</td><td>the device to read from </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">dest</td><td>the buffer to fill in </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">page</td><td>Page number to start reading from </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">offset</td><td>offset from the start of the page (in bytes) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">size</td><td>the number of bytes to read</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">0</td><td>on success </td></tr>
    <tr><td class="paramname">&lt;0</td><td>value on error </td></tr>
    <tr><td class="paramname">-ENODEV</td><td>if <code>mtd</code> is not a valid device </td></tr>
    <tr><td class="paramname">-ENOTSUP</td><td>if operation is not supported on <code>mtd</code> </td></tr>
    <tr><td class="paramname">-EOVERFLOW</td><td>if <code>addr</code> or <code>count</code> are not valid, i.e. outside memory </td></tr>
    <tr><td class="paramname">-EIO</td><td>if I/O error occurred </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga5f36fb25e0daada2e9a873475c532d94"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga5f36fb25e0daada2e9a873475c532d94">&#9670;&nbsp;</a></span>mtd_write()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int mtd_write </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structmtd__dev__t.html">mtd_dev_t</a> *&#160;</td>
          <td class="paramname"><em>mtd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>addr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>count</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Write data to a MTD device. </p>
<p><code>addr</code> + <code>count</code> must be inside a page boundary. <code>addr</code> can be anywhere but the buffer cannot overlap two pages.</p>
<p>Both parameters must be multiples of the device's write size.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">mtd</td><td>the device to write to </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">src</td><td>the buffer to write </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">addr</td><td>the start address to write to </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">count</td><td>the number of bytes to write</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">0</td><td>on success </td></tr>
    <tr><td class="paramname">&lt;0</td><td>if an error occurred </td></tr>
    <tr><td class="paramname">-ENODEV</td><td>if <code>mtd</code> is not a valid device </td></tr>
    <tr><td class="paramname">-ENOTSUP</td><td>if operation is not supported on <code>mtd</code> </td></tr>
    <tr><td class="paramname">-EOVERFLOW</td><td>if <code>addr</code> or <code>count</code> are not valid, i.e. outside memory, or overlapping two pages </td></tr>
    <tr><td class="paramname">-EIO</td><td>if I/O error occurred </td></tr>
    <tr><td class="paramname">-EINVAL</td><td>if parameters are invalid (invalid alignment for instance) </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gad52a5002206227b278f6cbb1efb605d3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gad52a5002206227b278f6cbb1efb605d3">&#9670;&nbsp;</a></span>mtd_write_page()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int mtd_write_page </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structmtd__dev__t.html">mtd_dev_t</a> *&#160;</td>
          <td class="paramname"><em>mtd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>page</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>offset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Write data to a MTD device with pagewise addressing. </p>
<p>The MTD layer will take care of splitting up the transaction into multiple writes if it is required by the underlying storage media.</p>
<p>If the underlying sector needs to be erased before it can be written, the MTD layer will take care of the read-modify-write operation.</p>
<p><code>offset</code> must be smaller than the page size</p>
<dl class="section note"><dt>Note</dt><dd>this requires the <code>mtd_write_page</code> module</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">mtd</td><td>the device to write to </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">src</td><td>the buffer to write </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">page</td><td>Page number to start writing to </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">offset</td><td>byte offset from the start of the page </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">size</td><td>the number of bytes to write</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">0</td><td>on success </td></tr>
    <tr><td class="paramname">&lt;0</td><td>value on error </td></tr>
    <tr><td class="paramname">-ENODEV</td><td>if <code>mtd</code> is not a valid device </td></tr>
    <tr><td class="paramname">-ENOTSUP</td><td>if operation is not supported on <code>mtd</code> </td></tr>
    <tr><td class="paramname">-EOVERFLOW</td><td>if <code>addr</code> or <code>count</code> are not valid, i.e. outside memory, </td></tr>
    <tr><td class="paramname">-EIO</td><td>if I/O error occurred </td></tr>
    <tr><td class="paramname">-EINVAL</td><td>if parameters are invalid </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga6cb5d1eed19f88f4e4b970541f7dcbf6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga6cb5d1eed19f88f4e4b970541f7dcbf6">&#9670;&nbsp;</a></span>mtd_write_page_raw()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int mtd_write_page_raw </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structmtd__dev__t.html">mtd_dev_t</a> *&#160;</td>
          <td class="paramname"><em>mtd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>page</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>offset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Write data to a MTD device with pagewise addressing. </p>
<p>The MTD layer will take care of splitting up the transaction into multiple writes if it is required by the underlying storage media.</p>
<p>This performs a raw write, no automatic read-modify-write cycle is performed.</p>
<p>Both <code>offset</code> and <code>size</code> must be multiples of the device's write size.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">mtd</td><td>the device to write to </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">src</td><td>the buffer to write </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">page</td><td>Page number to start writing to </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">offset</td><td>byte offset from the start of the page </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">size</td><td>the number of bytes to write</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">0</td><td>on success </td></tr>
    <tr><td class="paramname">&lt;0</td><td>value on error </td></tr>
    <tr><td class="paramname">-ENODEV</td><td>if <code>mtd</code> is not a valid device </td></tr>
    <tr><td class="paramname">-ENOTSUP</td><td>if operation is not supported on <code>mtd</code> </td></tr>
    <tr><td class="paramname">-EOVERFLOW</td><td>if <code>addr</code> or <code>count</code> are not valid, i.e. outside memory, </td></tr>
    <tr><td class="paramname">-EIO</td><td>if I/O error occurred </td></tr>
    <tr><td class="paramname">-EINVAL</td><td>if parameters are invalid </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga40c7db24bb97158581694edc4eaf20aa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga40c7db24bb97158581694edc4eaf20aa">&#9670;&nbsp;</a></span>mtd_write_sector()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int mtd_write_sector </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structmtd__dev__t.html">mtd_dev_t</a> *&#160;</td>
          <td class="paramname"><em>mtd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>sector</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>num</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Write data to a MTD device with whole sector writes. </p>
<p>The MTD layer will take care of splitting up the transaction into multiple writes if it is required by the underlying storage media.</p>
<p>The sectors will be erased before writing if needed.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">mtd</td><td>Device to write to </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">src</td><td>Buffer to write </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">sector</td><td>Sector number to start writing to </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">num</td><td>Number of sectors to write</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">0</td><td>on success </td></tr>
    <tr><td class="paramname">&lt;0</td><td>value on error </td></tr>
    <tr><td class="paramname">-ENODEV</td><td>if <code>mtd</code> is not a valid device </td></tr>
    <tr><td class="paramname">-ENOTSUP</td><td>if operation is not supported on <code>mtd</code> </td></tr>
    <tr><td class="paramname">-EOVERFLOW</td><td>if <code>addr</code> or <code>count</code> are not valid, i.e. outside memory, </td></tr>
    <tr><td class="paramname">-EIO</td><td>if I/O error occurred </td></tr>
    <tr><td class="paramname">-EINVAL</td><td>if parameters are invalid </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<h2 class="groupheader">Variable Documentation</h2>
<a id="ga290552e29a4074f1b34c0067e39886df"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga290552e29a4074f1b34c0067e39886df">&#9670;&nbsp;</a></span>mtd_dev_xfa</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structmtd__dev__t.html">mtd_dev_t</a>* const mtd_dev_xfa[]</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>MTD device array as XFA. </p>
<p>The array contains the addresses of all MTD devices that are defined using the <a class="el" href="group__drivers__mtd.html#gaf0ba0e302d3f3711c691fdfbda1461ac">MTD_XFA_ADD</a> macro, for example: </p><div class="fragment"><div class="line"><a class="code" href="group__drivers__mtd.html#gaf0ba0e302d3f3711c691fdfbda1461ac">MTD_XFA_ADD</a>(my_dev, 0);</div></div><!-- fragment --><p> The MTD devices in this array can be used for automatic functions such as with the <code>mtd_default</code> module. The i-th device in this array can then be accessed with <code>mtd_dev_xfa[i]</code>. The number of MTDs defined in this array is <code><a class="el" href="xfa_8h.html#ad15d5dae13c2d1ffdab3fd64d78e1b4b" title="Calculate number of entries in cross-file array. ">XFA_LEN(mtd_dev_xfa)</a></code>. </p>

<p class="definition">Definition at line <a class="el" href="mtd_8h_source.html#l00139">139</a> of file <a class="el" href="mtd_8h_source.html">mtd.h</a>.</p>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
    <div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
        <ul>
            <li class="footer">Generated on Thu Mar 13 2025 10:38:32 by <a href="http://www.doxygen.org/index.html">
                       <img class="footer" src="doxygen.png" alt="doxygen"></a> 1.8.14</li>
        </ul>
    </div>
    <!-- Include all compiled plugins (below), or include individual files as needed -->
    <script src="bootstrap.min.js"></script>
    <script src="jquery.smartmenus.min.js"></script>
    <script src="jquery.smartmenus.bootstrap.min.js"></script>
    <script src="riot-doxy.js"></script>
  </body>
</html>
