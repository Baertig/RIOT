<!DOCTYPE html>
<html lang="en">
  <head>
    <link rel="icon" type="image/png" href="favicon.png">
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <!-- The above 3 meta tags *must* come first in the head; any other head content must come *after* these tags -->
    <title>cpu/esp32/include/periph_cpu.h File Reference</title>
    <!-- jQuery (necessary for Bootstrap's JavaScript plugins) -->
    <script src="jquery.min.js"></script>
    <script src="jquery.powertip.min.js"></script>
    <script src="jquery-ui.min.js"></script>
    <script src="jquery.scrollTo.min.js"></script>
    <script src="doxy-jquery.js"></script>
    <script src="dynsections.js"></script>
    <link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
  $(document).ready(initResizable);
/* @license-end */</script>
    <link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
    <!-- Bootstrap -->
    <link href="doxygen.css" rel="stylesheet">
    <link href="fonts.css" rel="stylesheet">
    <link href="bootstrap.min.css" rel="stylesheet">
    <link href="jquery.smartmenus.bootstrap.css" rel="stylesheet">
    <link href="riot.css" rel="stylesheet">
    <!-- HTML5 shim and Respond.js for IE8 support of HTML5 elements and media queries -->
    <!-- WARNING: Respond.js doesn't work if you view the page via file:// -->
    <!--[if lt IE 9]>
      <script src="https://oss.maxcdn.com/html5shiv/3.7.3/html5shiv.min.js"></script>
      <script src="https://oss.maxcdn.com/respond/1.4.2/respond.min.js"></script>
    <![endif]-->
        <script>
            function displaySR(){
            searchBox.Search();
            var rhtml=(document.getElementById('MSearchResults').contentWindow.document.body.innerHTML).replace(/href=\"\.\.\//g,'href="');
            document.getElementById('MSearchResultsWindow').style.display='none';
            document.getElementById('top').append(document.getElementById('MSearchSelectWindow'));
            document.getElementById('top').append(document.getElementById('MSearchResultsWindow'));
            document.getElementById('doc-content').innerHTML=rhtml;
            }
            function modSearch(){
            if(!searchBox.doxySearch){
                searchBox.doxySearch=searchBox.Search
                searchBox.Search= function(){this.doxySearch();
                var r=document.getElementById('MSearchResultsWindow');console.log(r.style);
                if(parseInt(r.style.left)<0)r.style.left=0;
                var x=document.getElementById('MSearchResults');
                if(x.scrollWidth>window.screen.width)x.style.width=window.screen.width-2+'px';
                var f=document.getElementById('riot-searchform');
                if(parseInt( r.style.top) < f.offsetTop+f.scrollHeight) r.style.top = f.offsetTop+f.scrollHeight+'px';}
            }
            }
        </script>
  </head>
  <body>
      <div id="top">
        <nav class="navbar navbar-inverse">
          <div class="container-fluid">
            <!-- Brand and toggle get grouped for better mobile display -->
            <div class="navbar-header">
              <button type="button" class="navbar-toggle collapsed" data-toggle="collapse" data-target="#navbar-collapse" aria-expanded="false">
                <span class="sr-only">Toggle navigation</span>
                <span class="icon-bar"></span>
                <span class="icon-bar"></span>
                <span class="icon-bar"></span>
              </button>
              <a class="navbar-brand" id="brand-logo" href="http://riot-os.org"><img height="40px" src="riot-logo.svg" /></a>
              <p class="navbar-text text-center visible-xs">Documentation</p>
            </div>
            <!-- Collect the nav links, forms, and other content for toggling -->
            <div class="collapse navbar-collapse" id="navbar-collapse">
              <p class="navbar-text navbar-left"><span id="projectbrief">The friendly Operating System for the Internet of Things</span></p>
              <ul id="riot-navlist" class="nav navbar-nav"></ul>
              <form id="riot-searchform" class="navbar-form navbar-left navbar-right" action="https://duckduckgo.com/" method="get">
                 <input type="hidden" name="sites" value="doc.riot-os.org"/>
                 <input type="hidden" name="kt" value="h"/>
                 <div class="form-group">
                   <div id="MSearchBox" class="MSearchBoxActive">
                     <div class="input-group">
                       <div class="input-group-addon">
                         <span id="MSearchSelect" class="glyphicon glyphicon-search" aria-hidden="true" onmouseover="return searchBox.OnSearchSelectShow()" onmouseout="return searchBox.OnSearchSelectHide()"></span>
                       </div>
                       <input class="form-control" type="text" name="q" id="MSearchField" placeholder="Search" accesskey="S" onfocus="searchBox.OnSearchFieldFocus(true)" onblur="searchBox.OnSearchFieldFocus(false)" onkeyup="searchBox.OnSearchFieldChange(event); modSearch();">
                       <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()">
                         <span id="search-reset" class="glyphicon glyphicon-remove-circle" aria-hidden="true"></span>
                       </a>
                     </div>
                   </div>
                 </div>
              </form>
            </div><!-- /.navbar-collapse -->
          </div><!-- /.container-fluid -->
        </nav>
      </div>
<!-- Generated by Doxygen 1.8.14 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(document).ready(function(){initNavTree('esp32_2include_2periph__cpu_8h.html','');});
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#nested-classes">Data Structures</a> &#124;
<a href="#define-members">Macros</a>  </div>
  <div class="headertitle">
<div class="title">periph_cpu.h File Reference<div class="ingroups"><a class="el" href="group__cpu.html">CPU</a> &raquo; <a class="el" href="group__cpu__esp32.html">ESP32 SoC Series</a></div></div>  </div>
</div><!--header-->
<div class="contents">

<p>Peripheral configuration that is common for all ESP32x SoCs.  
<a href="#details">More...</a></p>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Peripheral configuration that is common for all ESP32x SoCs. </p>
<dl class="section author"><dt>Author</dt><dd>Gunar Schorcht <a href="#" onclick="location.href='mai'+'lto:'+'gun'+'ar'+'@sc'+'ho'+'rch'+'t.'+'net'; return false;">gunar<span style="display: none;">.nosp@m.</span>@sch<span style="display: none;">.nosp@m.</span>orcht<span style="display: none;">.nosp@m.</span>.net</a> </dd></dl>

<p class="definition">Definition in file <a class="el" href="esp32_2include_2periph__cpu_8h_source.html">periph_cpu.h</a>.</p>
</div><div class="textblock"><code>#include &lt;stdbool.h&gt;</code><br />
<code>#include &lt;stdint.h&gt;</code><br />
<code>#include &quot;<a class="el" href="cpu_2esp32_2include_2sdkconfig_8h_source.html">sdkconfig.h</a>&quot;</code><br />
<code>#include &quot;hal/ledc_types.h&quot;</code><br />
<code>#include &quot;hal/spi_types.h&quot;</code><br />
<code>#include &quot;soc/ledc_struct.h&quot;</code><br />
<code>#include &quot;soc/periph_defs.h&quot;</code><br />
<code>#include &quot;soc/soc_caps.h&quot;</code><br />
<code>#include &quot;<a class="el" href="usbdev__synopsys__dwc2_8h_source.html">usbdev_synopsys_dwc2.h</a>&quot;</code><br />
</div><div class="textblock"><div id="dynsection-0" onclick="return toggleVisibility(this)" class="dynheader closed" style="cursor:pointer;">
  <img id="dynsection-0-trigger" src="closed.png" alt="+"/> Include dependency graph for periph_cpu.h:</div>
<div id="dynsection-0-summary" class="dynsummary" style="display:block;">
</div>
<div id="dynsection-0-content" class="dyncontent" style="display:none;">
<div class="center"><iframe scrolling="no" frameborder="0" src="esp32_2include_2periph__cpu_8h__incl.svg" width="1132" height="202"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
</div>
</div>
<p><a href="esp32_2include_2periph__cpu_8h_source.html">Go to the source code of this file.</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Data Structures</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">union &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="uniongpio__conf__esp32.html">gpio_conf_esp32</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">GPIO pin configuration for ESP32/ESP32Cx/ESP32Sx MCUs.  <a href="uniongpio__conf__esp32.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structi2c__conf__t.html">i2c_conf_t</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">I2C configuration structure.  <a href="structi2c__conf__t.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structpwm__config__t.html">pwm_config_t</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">PWM configuration structure type.  <a href="structpwm__config__t.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structrmt__channel__config__t.html">rmt_channel_config_t</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">RMT channel configuration.  <a href="structrmt__channel__config__t.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structsdmmc__conf__t.html">sdmmc_conf_t</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">SDMMC slot configuration.  <a href="structsdmmc__conf__t.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structspi__conf__t.html">spi_conf_t</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">SPI device configuration.  <a href="structspi__conf__t.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structuart__conf__t.html">uart_conf_t</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">UART device configuration.  <a href="structuart__conf__t.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="define-members"></a>
Macros</h2></td></tr>
<tr class="memitem:a1943715eaeaa63e28b7b4e207f655fca"><td class="memItemLeft" align="right" valign="top"><a id="a1943715eaeaa63e28b7b4e207f655fca"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="esp32_2include_2periph__cpu_8h.html#a1943715eaeaa63e28b7b4e207f655fca">CPUID_LEN</a>&#160;&#160;&#160;(6U)</td></tr>
<tr class="memdesc:a1943715eaeaa63e28b7b4e207f655fca"><td class="mdescLeft">&#160;</td><td class="mdescRight">Length of the CPU_ID in octets. <br /></td></tr>
<tr class="separator:a1943715eaeaa63e28b7b4e207f655fca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afd04a76b55e9fef358e904400cde4db7"><td class="memItemLeft" align="right" valign="top"><a id="afd04a76b55e9fef358e904400cde4db7"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="esp32_2include_2periph__cpu_8h.html#afd04a76b55e9fef358e904400cde4db7">PERIPH_TIMER_PROVIDES_SET</a></td></tr>
<tr class="memdesc:afd04a76b55e9fef358e904400cde4db7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Prevent shared timer functions from being used. <br /></td></tr>
<tr class="separator:afd04a76b55e9fef358e904400cde4db7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a81935d479349dc2ce0a416bcb0e6beda"><td class="memItemLeft" align="right" valign="top"><a id="a81935d479349dc2ce0a416bcb0e6beda"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="esp32_2include_2periph__cpu_8h.html#a81935d479349dc2ce0a416bcb0e6beda">STDIO_UART_DEV</a>&#160;&#160;&#160;CONFIG_ESP_CONSOLE_UART_NUM</td></tr>
<tr class="memdesc:a81935d479349dc2ce0a416bcb0e6beda"><td class="mdescLeft">&#160;</td><td class="mdescRight">UART device used for STDIO. <br /></td></tr>
<tr class="separator:a81935d479349dc2ce0a416bcb0e6beda"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="member-group"></a>
Power management configuration</h2></td></tr>
<tr class="memitem:a04211208eb7863ce1c522440a91c745c"><td class="memItemLeft" align="right" valign="top"><a id="a04211208eb7863ce1c522440a91c745c"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>PROVIDES_PM_SET_LOWEST</b></td></tr>
<tr class="separator:a04211208eb7863ce1c522440a91c745c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abb8775ffe47b6ea299c337d2de369e13"><td class="memItemLeft" align="right" valign="top"><a id="abb8775ffe47b6ea299c337d2de369e13"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>PROVIDES_PM_RESTART</b></td></tr>
<tr class="separator:abb8775ffe47b6ea299c337d2de369e13"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a19d28a07b2898cf543c068c890ab7da0"><td class="memItemLeft" align="right" valign="top"><a id="a19d28a07b2898cf543c068c890ab7da0"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>PROVIDES_PM_OFF</b></td></tr>
<tr class="separator:a19d28a07b2898cf543c068c890ab7da0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0c0ac9ba49fa45f1faab835edc15d5ed"><td class="memItemLeft" align="right" valign="top"><a id="a0c0ac9ba49fa45f1faab835edc15d5ed"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>PROVIDES_PM_LAYERED_OFF</b></td></tr>
<tr class="separator:a0c0ac9ba49fa45f1faab835edc15d5ed"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3d1931627629f3c43bd898da0be6075b"><td class="memItemLeft" align="right" valign="top"><a id="a3d1931627629f3c43bd898da0be6075b"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="esp32_2include_2periph__cpu_8h.html#a3d1931627629f3c43bd898da0be6075b">PM_NUM_MODES</a>&#160;&#160;&#160;(3U)</td></tr>
<tr class="memdesc:a3d1931627629f3c43bd898da0be6075b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Number of usable low power modes. <br /></td></tr>
<tr class="separator:a3d1931627629f3c43bd898da0be6075b"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="member-group"></a>
Power modes</h2></td></tr>
<tr class="memitem:aa46086d6003b622e23e6123974d8dffc"><td class="memItemLeft" align="right" valign="top"><a id="aa46086d6003b622e23e6123974d8dffc"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>ESP_PM_MODEM_SLEEP</b>&#160;&#160;&#160;(2U)</td></tr>
<tr class="separator:aa46086d6003b622e23e6123974d8dffc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae2376d94f6767ae6e7602687fcff12c4"><td class="memItemLeft" align="right" valign="top"><a id="ae2376d94f6767ae6e7602687fcff12c4"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>ESP_PM_LIGHT_SLEEP</b>&#160;&#160;&#160;(1U)</td></tr>
<tr class="separator:ae2376d94f6767ae6e7602687fcff12c4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae3553a08e62f0817da0df1c1683295a0"><td class="memItemLeft" align="right" valign="top"><a id="ae3553a08e62f0817da0df1c1683295a0"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>ESP_PM_DEEP_SLEEP</b>&#160;&#160;&#160;(0U)</td></tr>
<tr class="separator:ae3553a08e62f0817da0df1c1683295a0"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="member-group"></a>
GPIO configuration</h2></td></tr>
<tr class="memitem:a759f553fbddd2915b49e50c967661fb1"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="esp32_2include_2periph__cpu_8h.html#a759f553fbddd2915b49e50c967661fb1">HAVE_GPIO_T</a></td></tr>
<tr class="memdesc:a759f553fbddd2915b49e50c967661fb1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Override the default gpio_t type definition.  <a href="#a759f553fbddd2915b49e50c967661fb1">More...</a><br /></td></tr>
<tr class="separator:a759f553fbddd2915b49e50c967661fb1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adacfc0deb08affff1e88f9549c8e2823"><td class="memItemLeft" align="right" valign="top"><a id="adacfc0deb08affff1e88f9549c8e2823"></a>
typedef unsigned int&#160;</td><td class="memItemRight" valign="bottom"><b>gpio_t</b></td></tr>
<tr class="separator:adacfc0deb08affff1e88f9549c8e2823"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3969ce1e494a72d3c2925b10ddeb4604"><td class="memItemLeft" align="right" valign="top"><a id="a3969ce1e494a72d3c2925b10ddeb4604"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="esp32_2include_2periph__cpu_8h.html#a3969ce1e494a72d3c2925b10ddeb4604">GPIO_UNDEF</a>&#160;&#160;&#160;(0xffffffff)</td></tr>
<tr class="memdesc:a3969ce1e494a72d3c2925b10ddeb4604"><td class="mdescLeft">&#160;</td><td class="mdescRight">Definition of a fitting UNDEF value. <br /></td></tr>
<tr class="separator:a3969ce1e494a72d3c2925b10ddeb4604"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae29846b3ecd19a0b7c44ff80a37ae7c1"><td class="memItemLeft" align="right" valign="top"><a id="ae29846b3ecd19a0b7c44ff80a37ae7c1"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="esp32_2include_2periph__cpu_8h.html#ae29846b3ecd19a0b7c44ff80a37ae7c1">GPIO_PIN</a>(x,  y)&#160;&#160;&#160;((x &lt;&lt; 5) | y)</td></tr>
<tr class="memdesc:ae29846b3ecd19a0b7c44ff80a37ae7c1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Define a CPU specific GPIO pin generator macro. <br /></td></tr>
<tr class="separator:ae29846b3ecd19a0b7c44ff80a37ae7c1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a77546a5cc91deda999da3cb862fc3f98"><td class="memItemLeft" align="right" valign="top"><a id="a77546a5cc91deda999da3cb862fc3f98"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="esp32_2include_2periph__cpu_8h.html#a77546a5cc91deda999da3cb862fc3f98">PORT_GPIO</a>&#160;&#160;&#160;(0)</td></tr>
<tr class="memdesc:a77546a5cc91deda999da3cb862fc3f98"><td class="mdescLeft">&#160;</td><td class="mdescRight">Available GPIO ports on ESP32. <br /></td></tr>
<tr class="separator:a77546a5cc91deda999da3cb862fc3f98"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a868f2d79bdced071714fb44a357c0018"><td class="memItemLeft" align="right" valign="top"><a id="a868f2d79bdced071714fb44a357c0018"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="esp32_2include_2periph__cpu_8h.html#a868f2d79bdced071714fb44a357c0018">GPIO_PIN_NUMOF</a>&#160;&#160;&#160;(SOC_GPIO_PIN_COUNT)</td></tr>
<tr class="memdesc:a868f2d79bdced071714fb44a357c0018"><td class="mdescLeft">&#160;</td><td class="mdescRight">Define CPU specific number of GPIO pins. <br /></td></tr>
<tr class="separator:a868f2d79bdced071714fb44a357c0018"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="member-group"></a>
ADC configuration</h2></td></tr>
<tr><td class="ititle" colspan="2"><p><a class="anchor" id="amgrp469c0c7aaf26a1bfe51046c19f57492d"></a>ESP32x SoCs integrate two SAR ADCs (ADC1 and ADC2).</p>
<p>The bit width of the ADC devices, the number of channels per device and the GPIOs that can be used as ADC channels depend on the respective ESP32x SoC family. For details, see:</p>
<ul>
<li><a class="el" href="group__cpu__esp32__esp32.html#esp32_adc_channels_esp32">ESP32</a></li>
<li><a class="el" href="group__cpu__esp32__esp32c3.html#esp32_adc_channels_esp32c3">ESP32-C3</a></li>
<li><a class="el" href="group__cpu__esp32__esp32s3.html#esp32_adc_channels_esp32s3">ESP32-S3</a></li>
</ul>
<p><a class="el" href="boards_2esp32s3-usb-otg_2include_2periph__conf_8h.html#ac93ef90877386721589730c2219fde48" title="Declaration of GPIOs that can be used as ADC channels. ">ADC_GPIOS</a> in the board-specific peripheral configuration defines the list of GPIOs that can be used as ADC channels on the board, for example: </p><div class="fragment"><div class="line"><span class="preprocessor">#define ADC_GPIOS   { GPIO0, GPIO2, GPIO4 }</span></div></div><!-- fragment --><p>Thereby the order of the listed GPIOs determines the mapping between the ADC lines of the RIOT and the GPIOs. The maximum number of GPIOs in the list is <a class="el" href="esp32_2include_2periph__cpu_8h.html#aea6c293fdfb3bbb0f41e759577366d6f" title="Number of ADC channels that could be used at maximum. ">ADC_NUMOF_MAX</a>. The board specific configuration of <a class="el" href="boards_2esp32s3-usb-otg_2include_2periph__conf_8h.html#ac93ef90877386721589730c2219fde48" title="Declaration of GPIOs that can be used as ADC channels. ">ADC_GPIOS</a> can be overridden by <a href="#esp32_application_specific_configurations">Application specific configurations</a>.</p>
<p>The number of defined ADC channels <a class="el" href="boards_2stm32l496g-disco_2include_2periph__conf_8h.html#a2f0c741db24aa2ccded869ba53f6a302" title="Number of ADC devices. ">ADC_NUMOF</a> is determined automatically from the <a class="el" href="boards_2esp32s3-usb-otg_2include_2periph__conf_8h.html#ac93ef90877386721589730c2219fde48" title="Declaration of GPIOs that can be used as ADC channels. ">ADC_GPIOS</a> definition.</p>
<dl class="section note"><dt>Note</dt><dd>As long as the GPIOs listed in <a class="el" href="boards_2esp32s3-usb-otg_2include_2periph__conf_8h.html#ac93ef90877386721589730c2219fde48" title="Declaration of GPIOs that can be used as ADC channels. ">ADC_GPIOS</a> are not initialized as ADC channels with the <a class="el" href="group__drivers__periph__adc.html#ga259a7b0176a8a6f5a5e61aabce3574f0" title="Initialize the given ADC line. ">adc_init</a> function, they can be used for other purposes.</dd></dl>
<p>With the function <a class="el" href="adc__arch_8h.html#a99ad2f6a0bdea91f7ca3102e5f67fb85" title="Set the attenuation for the ADC line. ">adc_set_attenuation</a> an attenuation of the input signal can be defined separately for each ADC channel. </p><div class="fragment"><div class="line"><span class="keyword">extern</span> <span class="keywordtype">int</span> <a class="code" href="adc__arch_8h.html#a99ad2f6a0bdea91f7ca3102e5f67fb85">adc_set_attenuation</a>(<a class="code" href="group__drivers__periph__adc.html#ga77e0c958e3549fef6e4067b2ca678a0b">adc_t</a> line, <a class="code" href="adc__arch_8h.html#aa71353583a04674cb8a03f8117e8ecd3">adc_attenuation_t</a> atten);</div></div><!-- fragment --><p>This leads to different measurable maximum values for the voltage at the input. The higher the attenuation is, the higher the voltage measured at the input can be.</p>
<p>The attenuation can be set to 4 fixed values 0 dB, 2.5/3 dB, 6 dB and 11/12 dB, where 11 dB respectively 12 dB is the default attenuation.</p>
<center></center><center><table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadRight">Attenuation  </th><th class="markdownTableHeadNone">Voltage Range  </th><th class="markdownTableHeadNone">Symbol --------&mdash;:   </th></tr>
<tr class="markdownTableBody" class="markdownTableRowOdd">
<td class="markdownTableBodyRight">0 dB  </td><td class="markdownTableBodyNone">0 ... 1.1V (Vref)  </td><td class="markdownTableBodyNone"><code>ADC_ATTEN_DB_0</code>   </td></tr>
<tr class="markdownTableBody" class="markdownTableRowEven">
<td class="markdownTableBodyRight">2.5 / 3 dB  </td><td class="markdownTableBodyNone">0 ... 1.5V  </td><td class="markdownTableBodyNone"><code>ADC_ATTEN_DB_2_5</code>   </td></tr>
<tr class="markdownTableBody" class="markdownTableRowOdd">
<td class="markdownTableBodyRight">6 dB  </td><td class="markdownTableBodyNone">0 ... 2.2V  </td><td class="markdownTableBodyNone"><code>ADC_ATTEN_DB_6</code>   </td></tr>
<tr class="markdownTableBody" class="markdownTableRowEven">
<td class="markdownTableBodyRight">11 / 12 dB  </td><td class="markdownTableBodyNone">0 ... 3.3V  </td><td class="markdownTableBodyNone"><code>ADC_ATTEN_DB_11</code> (default)   </td></tr>
</table>
</center><center></center><p><br />
</p>
<dl class="section note"><dt>Note</dt><dd>The reference voltage Vref can vary from device to device in the range of 1.0V and 1.2V.</dd></dl>
<p>The Vref of a device can be read at a predefined GPIO with the function <a class="el" href="adc__arch_8h.html#a1ebca9a3af2ed9a9416949f539ba56b4" title="Output reference voltage of a ADC line to GPIO n. ">adc_line_vref_to_gpio</a>. The results of the ADC input can then be adjusted accordingly. </p><div class="fragment"><div class="line"><span class="keyword">extern</span> <span class="keywordtype">int</span> <a class="code" href="adc__arch_8h.html#a1ebca9a3af2ed9a9416949f539ba56b4">adc_line_vref_to_gpio</a>(<a class="code" href="group__drivers__periph__adc.html#ga77e0c958e3549fef6e4067b2ca678a0b">adc_t</a> line, gpio_t gpio);</div></div><!-- fragment --><p> For the GPIO that can be used with this function, see:</p>
<ul>
<li><a class="el" href="group__cpu__esp32__esp32.html#esp32_adc_channels_esp32">ESP32</a></li>
<li><a class="el" href="group__cpu__esp32__esp32c3.html#esp32_adc_channels_esp32c3">ESP32-C3</a></li>
<li><a class="el" href="group__cpu__esp32__esp32s3.html#esp32_adc_channels_esp32s3">ESP32-S3</a> </li>
</ul>
</td></tr>
<tr class="memitem:aea6c293fdfb3bbb0f41e759577366d6f"><td class="memItemLeft" align="right" valign="top"><a id="aea6c293fdfb3bbb0f41e759577366d6f"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="esp32_2include_2periph__cpu_8h.html#aea6c293fdfb3bbb0f41e759577366d6f">ADC_NUMOF_MAX</a>&#160;&#160;&#160;(SOC_ADC_CHANNEL_NUM(0) + SOC_ADC_CHANNEL_NUM(1))</td></tr>
<tr class="memdesc:aea6c293fdfb3bbb0f41e759577366d6f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Number of ADC channels that could be used at maximum. <br /></td></tr>
<tr class="separator:aea6c293fdfb3bbb0f41e759577366d6f"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="member-group"></a>
DAC configuration</h2></td></tr>
<tr><td class="ititle" colspan="2"><p><a class="anchor" id="amgrpc243b37b1a6e34fa74b2dd89caadd44d"></a>Some ESP32x SoCs support 2 DAC lines at predefined GPIOs, depending on the respective ESP32x SoC family.</p>
<p>These DACs have a width of 8 bits and produce voltages in the range from 0 V to 3.3 V (VDD_A). The 16 bit DAC values given as parameter of function <a class="el" href="group__drivers__periph__dac.html#ga179ae55de04d356cd6fbb63e9e3f51f6" title="Write a value onto DAC Device on a given Channel. ">dac_set</a> are down-scaled to 8 bit.</p>
<p>The GPIOs that can be used as DAC channels for a given board are defined by the <code><a class="el" href="boards_2esp32s2-wemos-mini_2include_2periph__conf_8h.html#a377e83c8834eecbb7aa5f355da2ae9da" title="Declaration of GPIOs that can be used as DAC channels. ">DAC_GPIOS</a></code> macro in the board-specific peripheral configuration. The specified GPIOs in the list must match the predefined GPIOs that can be used as DAC channels on the respective ESP32x SoC.</p>
<div class="fragment"><div class="line"><span class="preprocessor">#define DAC_GPIOS   { GPIO25, GPIO26 }</span></div></div><!-- fragment --><p>This configuration can be changed by <a href="#esp32_application_specific_configurations">application-specific configurations</a>.</p>
<p>The order of the listed GPIOs determines the mapping between the RIOT's DAC lines and the GPIOs. The maximum number of GPIOs in the list is <a class="el" href="esp32_2include_2periph__cpu_8h.html#afe6215885cf4c6bc1cbbbefdf19ccc80" title="Number of DAC channels that could be used at maximum. ">DAC_NUMOF_MAX</a>.</p>
<p><a class="el" href="boards_2stm32l496g-disco_2include_2periph__conf_8h.html#a2d6ae6694d0a51952fb26d994de93d12" title="Number of DACs. ">DAC_NUMOF</a> is determined automatically from the <a class="el" href="boards_2esp32s2-wemos-mini_2include_2periph__conf_8h.html#a377e83c8834eecbb7aa5f355da2ae9da" title="Declaration of GPIOs that can be used as DAC channels. ">DAC_GPIOS</a> definition.</p>
<dl class="section note"><dt>Note</dt><dd>As long as the GPIOs listed in <a class="el" href="boards_2esp32s2-wemos-mini_2include_2periph__conf_8h.html#a377e83c8834eecbb7aa5f355da2ae9da" title="Declaration of GPIOs that can be used as DAC channels. ">DAC_GPIOS</a> are not initialized as DAC channels with the <a class="el" href="group__drivers__periph__dac.html#gabc514d1757c59929f653c64085d3fd5d" title="Initialize the given DAC line. ">dac_init</a> function, they can be used for other purposes.</dd></dl>
<p>DACs are currently only supported for the <a class="el" href="group__cpu__esp32__esp32.html#esp32_dac_channels_esp32">ESP32 SoC</a> variant. </p>
</td></tr>
<tr class="memitem:afe6215885cf4c6bc1cbbbefdf19ccc80"><td class="memItemLeft" align="right" valign="top"><a id="afe6215885cf4c6bc1cbbbefdf19ccc80"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="esp32_2include_2periph__cpu_8h.html#afe6215885cf4c6bc1cbbbefdf19ccc80">DAC_NUMOF_MAX</a>&#160;&#160;&#160;(SOC_DAC_PERIPH_NUM)</td></tr>
<tr class="memdesc:afe6215885cf4c6bc1cbbbefdf19ccc80"><td class="mdescLeft">&#160;</td><td class="mdescRight">Number of DAC channels that could be used at maximum. <br /></td></tr>
<tr class="separator:afe6215885cf4c6bc1cbbbefdf19ccc80"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="member-group"></a>
I2C configuration</h2></td></tr>
<tr><td class="ititle" colspan="2"><p><a class="anchor" id="amgrp73fbd374b1f57149dfa859716e9864c4"></a>ESP32x SoCs integrate up to two I2C hardware interfaces.</p>
<p>The board-specific configuration of the I2C interface <a class="el" href="group__drivers__periph__i2c.html#ga9f14916eda80b19ff41d08e25eee56fb" title="Default I2C device access macro. ">I2C_DEV(n)</a> requires the definition of</p>
<p><code>I2Cn_SPEED</code>, the bus speed for <a class="el" href="group__drivers__periph__i2c.html#ga9f14916eda80b19ff41d08e25eee56fb" title="Default I2C device access macro. ">I2C_DEV(n)</a>, <code>I2Cn_SCL</code>, the GPIO used as SCL signal for <a class="el" href="group__drivers__periph__i2c.html#ga9f14916eda80b19ff41d08e25eee56fb" title="Default I2C device access macro. ">I2C_DEV(n)</a>, and <code>I2Cn_SDA</code>, the GPIO used as SDA signal for <a class="el" href="group__drivers__periph__i2c.html#ga9f14916eda80b19ff41d08e25eee56fb" title="Default I2C device access macro. ">I2C_DEV(n)</a>,</p>
<p>where <code>n</code> can be 0 or 1. If they are not defined, the I2C interface <a class="el" href="group__drivers__periph__i2c.html#ga9f14916eda80b19ff41d08e25eee56fb" title="Default I2C device access macro. ">I2C_DEV(n)</a> is not used, for example: </p><div class="fragment"><div class="line"><span class="preprocessor">#define I2C0_SPEED  I2C_SPEED_FAST</span></div><div class="line"><span class="preprocessor">#define I2C0_SCL    GPIO22</span></div><div class="line"><span class="preprocessor">#define I2C0_SDA    GPIO21</span></div><div class="line"></div><div class="line"><span class="preprocessor">#define I2C1_SPEED  I2C_SPEED_NORMAL</span></div><div class="line"><span class="preprocessor">#define I2C1_SCL    GPIO13</span></div><div class="line"><span class="preprocessor">#define I2C1_SDA    GPIO16</span></div></div><!-- fragment --><p>The board-specific pin configuration of I2C interfaces can be changed by <a href="#esp32_application_specific_configurations">application specific configurations</a> by overriding the according <code>I2Cn_*</code> symbols.</p>
<dl class="section note"><dt>Note</dt><dd><ul>
<li>To ensure that the <code>I2Cn_*</code> symbols define the configuration for <a class="el" href="group__drivers__periph__i2c.html#ga9f14916eda80b19ff41d08e25eee56fb" title="Default I2C device access macro. ">I2C_DEV(n)</a>, the definition of the configuration of I2C interfaces <a class="el" href="group__drivers__periph__i2c.html#ga9f14916eda80b19ff41d08e25eee56fb" title="Default I2C device access macro. ">I2C_DEV(n)</a> must be in continuous ascending order of <code>n</code>. That is, if <a class="el" href="group__drivers__periph__i2c.html#ga9f14916eda80b19ff41d08e25eee56fb" title="Default I2C device access macro. ">I2C_DEV(1)</a> is used by defining the <code>I2C1_*</code> symbols, <a class="el" href="group__drivers__periph__i2c.html#ga9f14916eda80b19ff41d08e25eee56fb" title="Default I2C device access macro. ">I2C_DEV(0)</a> must also be used by defining the <code>I2C0_*</code> symbols.</li>
<li>The GPIOs listed in the configuration are only initialized as I2C signals when the <code>periph_i2c</code> module is used. Otherwise they are not allocated and can be used for other purposes.</li>
<li>The same configuration is used when the I2C bit-banging software implementation is used by enabling module <code>esp_i2c_sw</code> (default).</li>
</ul>
</dd></dl>
<p>The number of used I2C interfaces <a class="el" href="boards_2rpi-pico_2include_2periph__conf_8h.html#abce62e16a6e3b3205801fed93c51692d" title="Number of I2C interfaces. ">I2C_NUMOF</a> is determined automatically from board-specific peripheral definitions of <a class="el" href="group__drivers__periph__i2c.html#ga9f14916eda80b19ff41d08e25eee56fb" title="Default I2C device access macro. ">I2C_DEV(n)</a>. </p>
</td></tr>
<tr class="memitem:aadb90ea077587669088351156a157867"><td class="memItemLeft" align="right" valign="top"><a id="aadb90ea077587669088351156a157867"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="esp32_2include_2periph__cpu_8h.html#aadb90ea077587669088351156a157867">I2C_NUMOF_MAX</a>&#160;&#160;&#160;(SOC_I2C_NUM)</td></tr>
<tr class="memdesc:aadb90ea077587669088351156a157867"><td class="mdescLeft">&#160;</td><td class="mdescRight">Maximum number of I2C interfaces that can be used by board definitions. <br /></td></tr>
<tr class="separator:aadb90ea077587669088351156a157867"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5ee5980de0aba9d9d03729b400287755"><td class="memItemLeft" align="right" valign="top"><a id="a5ee5980de0aba9d9d03729b400287755"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="esp32_2include_2periph__cpu_8h.html#a5ee5980de0aba9d9d03729b400287755">PERIPH_I2C_NEED_READ_REG</a></td></tr>
<tr class="memdesc:a5ee5980de0aba9d9d03729b400287755"><td class="mdescLeft">&#160;</td><td class="mdescRight">Implementation requires <a class="el" href="group__drivers__periph__i2c.html#gac4ab6e73e05b22c2da0c2f178da06d7b" title="Convenience function for reading one byte from a given register address. ">i2c_read_reg</a>. <br /></td></tr>
<tr class="separator:a5ee5980de0aba9d9d03729b400287755"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9df7b75f47f1d07ab97efc582ab242c6"><td class="memItemLeft" align="right" valign="top"><a id="a9df7b75f47f1d07ab97efc582ab242c6"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="esp32_2include_2periph__cpu_8h.html#a9df7b75f47f1d07ab97efc582ab242c6">PERIPH_I2C_NEED_READ_REGS</a></td></tr>
<tr class="memdesc:a9df7b75f47f1d07ab97efc582ab242c6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Implementation requires <a class="el" href="group__drivers__periph__i2c.html#ga5e65efc34a8bd77223795faadc29d304" title="Convenience function for reading several bytes from a given register address. ">i2c_read_regs</a>. <br /></td></tr>
<tr class="separator:a9df7b75f47f1d07ab97efc582ab242c6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a826c22d1182510f6ff3129f831b1107b"><td class="memItemLeft" align="right" valign="top"><a id="a826c22d1182510f6ff3129f831b1107b"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="esp32_2include_2periph__cpu_8h.html#a826c22d1182510f6ff3129f831b1107b">PERIPH_I2C_NEED_WRITE_REG</a></td></tr>
<tr class="memdesc:a826c22d1182510f6ff3129f831b1107b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Implementation requires <a class="el" href="group__drivers__periph__i2c.html#ga02b8328d5e823d972e1e1234965daab1" title="Convenience function for writing one byte to a given register address. ">i2c_write_reg</a>. <br /></td></tr>
<tr class="separator:a826c22d1182510f6ff3129f831b1107b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2d5896b5b60b2972fe3bc25ee53fa823"><td class="memItemLeft" align="right" valign="top"><a id="a2d5896b5b60b2972fe3bc25ee53fa823"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="esp32_2include_2periph__cpu_8h.html#a2d5896b5b60b2972fe3bc25ee53fa823">PERIPH_I2C_NEED_WRITE_REGS</a></td></tr>
<tr class="memdesc:a2d5896b5b60b2972fe3bc25ee53fa823"><td class="mdescLeft">&#160;</td><td class="mdescRight">Implementation requires <a class="el" href="group__drivers__periph__i2c.html#gac7e12c6df3bc117d5e46d1e98a5a7f08" title="Convenience function for writing data to a given register address. ">i2c_write_regs</a>. <br /></td></tr>
<tr class="separator:a2d5896b5b60b2972fe3bc25ee53fa823"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="member-group"></a>
PWM configuration</h2></td></tr>
<tr><td class="ititle" colspan="2"><p><a class="anchor" id="amgrp8202ae6e7ac07103d48a6453db628654"></a>The PWM peripheral driver for ESP32x SoCs uses the LED PWM Controller (LEDC) module for implementation.</p>
<p>The LEDC module has either 1 or 2 channel groups with 6 or 8 channels each, where the first channel group comprises the low-speed channels and the second channel group comprises the high-speed channels. The difference is that changes in the configuration of the high-speed channels take effect with the next PWM cycle, while the changes in the configuration of the low-speed channels must be explicitly updated by a trigger.</p>
<p>The low-speed channel group always exists while the existence of the high-speed channel group depends on respective ESP32x SoC family.</p>
<p>Each channel group has 4 timers which can be used as clock source by the channels of the respective channel group. Thus it would be possible to define a maximum of 4 virtual PWM devices in RIOT per channel group with different frequencies and resolutions. However, regardless of whether the LEDC module of the ESP32x SoC has one or two channel groups, the PWM driver implementation only allows the available channels to be organized into up to 4 virtual PWM devices.</p>
<p>The assignment of the available channels to the virtual PWM devices is done in the board-specific peripheral configuration by defining the macros <code>PWM0_GPIOS</code>, <code>PWM1_GPIOS</code>, <code>PWM2_GPIOS</code> and <code>PWM3_GPIOS</code> These macros specify the GPIOs that are used as channels for the 4 possible virtual PWM devices <a class="el" href="group__drivers__periph__pwm.html#gad7999c048ca3b0783f3fb62b93b056db" title="Default PWM access macro. ">PWM_DEV(0)</a> ... <a class="el" href="group__drivers__periph__pwm.html#gad7999c048ca3b0783f3fb62b93b056db" title="Default PWM access macro. ">PWM_DEV(3)</a> in RIOT, for example: </p><div class="fragment"><div class="line"><span class="preprocessor">#define PWM0_GPIOS  { GPIO0, GPIO2, GPIO4, GPIO16, GPIO17 }</span></div><div class="line"><span class="preprocessor">#define PWM1_GPIOS  { GPIO27, GPIO32, GPIO33 }</span></div></div><!-- fragment --><p>This configuration can be changed by <a href="#esp32_application_specific_configurations">application-specific configurations</a>.</p>
<p>The mapping of the GPIOs as channels of the available channel groups and channel group timers is organized by the driver automatically as follows:</p>
<center></center><center><table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone">Macro  </th><th class="markdownTableHeadNone">1 Channel Group  </th><th class="markdownTableHeadNone">2 Channel Groups  </th><th class="markdownTableHeadNone"><a class="el" href="structTimer.html" title="struct to get time references within mqtt paho ">Timer</a> -----&mdash;   </th></tr>
<tr class="markdownTableBody" class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><code>PWM0_GPIOS</code>  </td><td class="markdownTableBodyNone"><code>LEDC_LOW_SPEED_MODE</code>  </td><td class="markdownTableBodyNone"><code>LEDC_LOW_SPEED_MODE</code>  </td><td class="markdownTableBodyNone"><code>LEDC_TIMER_0</code>   </td></tr>
<tr class="markdownTableBody" class="markdownTableRowEven">
<td class="markdownTableBodyNone"><code>PWM1_GPIOS</code>  </td><td class="markdownTableBodyNone"><code>LEDC_LOW_SPEED_MODE</code>  </td><td class="markdownTableBodyNone"><code>LEDC_HIGH_SPEED_MODE</code>  </td><td class="markdownTableBodyNone"><code>LEDC_TIMER_1</code>   </td></tr>
<tr class="markdownTableBody" class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><code>PWM2_GPIOS</code>  </td><td class="markdownTableBodyNone"><code>LEDC_LOW_SPEED_MODE</code>  </td><td class="markdownTableBodyNone"><code>LEDC_LOW_SPEED_MODE</code>  </td><td class="markdownTableBodyNone"><code>LEDC_TIMER_2</code>   </td></tr>
<tr class="markdownTableBody" class="markdownTableRowEven">
<td class="markdownTableBodyNone"><code>PWM3_GPIOS</code>  </td><td class="markdownTableBodyNone"><code>LEDC_LOW_SPEED_MODE</code>  </td><td class="markdownTableBodyNone"><code>LEDC_HIGH_SPEED_MODE</code>  </td><td class="markdownTableBodyNone"><code>LEDC_TIMER_3</code>   </td></tr>
</table>
</center><center></center><p>For example, if the LEDC module of the ESP32x SoC has two channel groups, two virtual PWM devices with 2 x 6 (or 8) channels could be used by defining 'PWM0_GPIOS' and 'PWM1_GPIOS' with 6 (or 8) GPIOs each.</p>
<p>The number of used PWM devices <a class="el" href="boards_2nucleo-f767zi_2include_2periph__conf_8h.html#a44adbd579bb180f3cfe8ec78932eb7a1" title="Number of PWM devices. ">PWM_NUMOF</a> is determined automatically from the definition of <code>PWM0_GPIOS</code>, <code>PWM1_GPIOS</code>, <code>PWM2_GPIOS</code> and <code>PWM3_GPIOS</code>.</p>
<dl class="section note"><dt>Note</dt><dd><ul>
<li>The total number of channels defined for a channel group must not exceed <a class="el" href="esp32_2include_2periph__cpu_8h.html#a4c22b512958daca72c8cacd3e12372bd" title="Maximum number of channels per PWM device. ">PWM_CH_NUMOF_MAX</a></li>
<li>The definition of <code>PWM0_GPIOS</code>, <code>PWM1_GPIOS</code>, <code>PWM2_GPIOS</code> and <code>PWM3_GPIOS</code> can be omitted. However, to ensure that <code>PWMn_GPIOS</code> defines the configuration for <a class="el" href="group__drivers__periph__pwm.html#gad7999c048ca3b0783f3fb62b93b056db" title="Default PWM access macro. ">PWM_DEV(n)</a>, the PWM channels must be defined in continuous ascending order from <code>n</code>. That means, if <code>PWM1_GPIOS</code> is defined, <code>PWM0_GPIOS</code> must be defined before, and so on. So a minimal configuration would define all channels by <code>PWM0_GPIOS</code> as <a class="el" href="group__drivers__periph__pwm.html#gad7999c048ca3b0783f3fb62b93b056db" title="Default PWM access macro. ">PWM_DEV(0)</a>.</li>
<li>The order of the GPIOs in these macros determines the mapping between RIOT's PWM channels and the GPIOs.</li>
<li>As long as the GPIOs listed in <code>PWM0_GPIOS</code>, <code>PWM1_GPIOS</code>, <code>PWM2_GPIOS</code> and <code>PWM3_GPIOS</code> are not initialized as PWM channels with the <a class="el" href="group__drivers__periph__pwm.html#ga205eedf5331e5646b330d986f2b691f9" title="Initialize a PWM device. ">pwm_init</a> function, they can be used for other purposes. </li>
</ul>
</dd></dl>
</td></tr>
<tr class="memitem:a384d72c648cf3953b0d71fd122c57a29"><td class="memItemLeft" align="right" valign="top"><a id="a384d72c648cf3953b0d71fd122c57a29"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="esp32_2include_2periph__cpu_8h.html#a384d72c648cf3953b0d71fd122c57a29">PWM_NUMOF_MAX</a>&#160;&#160;&#160;(4)</td></tr>
<tr class="memdesc:a384d72c648cf3953b0d71fd122c57a29"><td class="mdescLeft">&#160;</td><td class="mdescRight">Maximum number of PWM devices. <br /></td></tr>
<tr class="separator:a384d72c648cf3953b0d71fd122c57a29"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4c22b512958daca72c8cacd3e12372bd"><td class="memItemLeft" align="right" valign="top"><a id="a4c22b512958daca72c8cacd3e12372bd"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="esp32_2include_2periph__cpu_8h.html#a4c22b512958daca72c8cacd3e12372bd">PWM_CH_NUMOF_MAX</a>&#160;&#160;&#160;(SOC_LEDC_CHANNEL_NUM)</td></tr>
<tr class="memdesc:a4c22b512958daca72c8cacd3e12372bd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Maximum number of channels per PWM device. <br /></td></tr>
<tr class="separator:a4c22b512958daca72c8cacd3e12372bd"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="member-group"></a>
RMT configuration</h2></td></tr>
<tr><td class="ititle" colspan="2"><p><a class="anchor" id="amgrp0fc0183808906c98b6754abe87b849d4"></a>ESP32x SoCs have a Remote Control Peripheral (RMT) that can be used to generate digital waveforms, such as NEC remote control signals or WS2812B RGB LED signals.</p>
<p>Each RMT peripheral has either 4 or 8 channels. Some ESP32x SoCs support configuring the clock sources used for each channel separately, while other ESP32x SoCs can only use a single clock source for all channels. </p>
</td></tr>
<tr class="memitem:a20377730a568815e8437e099d689e578"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="esp32_2include_2periph__cpu_8h.html#a20377730a568815e8437e099d689e578">RMT_CH_NUMOF_MAX</a>&#160;&#160;&#160;(SOC_RMT_CHANNELS_PER_GROUP)</td></tr>
<tr class="memdesc:a20377730a568815e8437e099d689e578"><td class="mdescLeft">&#160;</td><td class="mdescRight">Maximum number of RMT channels.  <a href="#a20377730a568815e8437e099d689e578">More...</a><br /></td></tr>
<tr class="separator:a20377730a568815e8437e099d689e578"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="member-group"></a>
RNG configuration</h2></td></tr>
<tr class="memitem:a1c8140ba01d43a1872af952c3e61d9b2"><td class="memItemLeft" align="right" valign="top"><a id="a1c8140ba01d43a1872af952c3e61d9b2"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="esp32_2include_2periph__cpu_8h.html#a1c8140ba01d43a1872af952c3e61d9b2">RNG_DATA_REG_ADDR</a>&#160;&#160;&#160;(WDEV_RND_REG)</td></tr>
<tr class="memdesc:a1c8140ba01d43a1872af952c3e61d9b2"><td class="mdescLeft">&#160;</td><td class="mdescRight">The address of the register for accessing the hardware RNG. <br /></td></tr>
<tr class="separator:a1c8140ba01d43a1872af952c3e61d9b2"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="member-group"></a>
RTT and RTC configuration</h2></td></tr>
<tr class="memitem:afec7c948b8c70db3c9394fc3dc145a99"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="esp32_2include_2periph__cpu_8h.html#afec7c948b8c70db3c9394fc3dc145a99">RTT_FREQUENCY</a>&#160;&#160;&#160;(32768UL)</td></tr>
<tr class="memdesc:afec7c948b8c70db3c9394fc3dc145a99"><td class="mdescLeft">&#160;</td><td class="mdescRight">RTT frequency definition.  <a href="#afec7c948b8c70db3c9394fc3dc145a99">More...</a><br /></td></tr>
<tr class="separator:afec7c948b8c70db3c9394fc3dc145a99"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a57f384110fe2e8f4b3c4b9ba246517c6"><td class="memItemLeft" align="right" valign="top"><a id="a57f384110fe2e8f4b3c4b9ba246517c6"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="esp32_2include_2periph__cpu_8h.html#a57f384110fe2e8f4b3c4b9ba246517c6">RTT_MAX_VALUE</a>&#160;&#160;&#160;(0xFFFFFFFFUL)</td></tr>
<tr class="memdesc:a57f384110fe2e8f4b3c4b9ba246517c6"><td class="mdescLeft">&#160;</td><td class="mdescRight">RTT is a 32-bit counter. <br /></td></tr>
<tr class="separator:a57f384110fe2e8f4b3c4b9ba246517c6"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="member-group"></a>
SDMMC configuration</h2></td></tr>
<tr><td class="ititle" colspan="2"><p><a class="anchor" id="amgrpf712131d3a8c7ab07a53946cc38e3348"></a>ESP32x SoC with SDMMC peripheral provide two SDMMC interfaces called slots.</p>
<p>How many slots can be used depends on the ESP32x SoC, see <a class="el" href="esp32_2include_2periph__cpu_8h.html#a1003cd6605561c65d1776afc38c0da23">sdmmc_slot_t</a>. </p>
</td></tr>
<tr class="memitem:a59763349a78797e79ed4e3a847f63430"><td class="memItemLeft" align="right" valign="top"><a id="a59763349a78797e79ed4e3a847f63430"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="esp32_2include_2periph__cpu_8h.html#a59763349a78797e79ed4e3a847f63430">SDMMC_CPU_DMA_REQUIREMENTS</a>&#160;&#160;&#160;__attribute__((aligned(<a class="el" href="sam0__common_2include_2periph__cpu__common_8h.html#af0cbbd12324a55dc975cd3a7bbcdcc24">SDMMC_CPU_DMA_ALIGNMENT</a>)))</td></tr>
<tr class="memdesc:a59763349a78797e79ed4e3a847f63430"><td class="mdescLeft">&#160;</td><td class="mdescRight">SDIO/SDMMC buffer instantiation requirement for SDHC. <br /></td></tr>
<tr class="separator:a59763349a78797e79ed4e3a847f63430"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af0cbbd12324a55dc975cd3a7bbcdcc24"><td class="memItemLeft" align="right" valign="top"><a id="af0cbbd12324a55dc975cd3a7bbcdcc24"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="esp32_2include_2periph__cpu_8h.html#af0cbbd12324a55dc975cd3a7bbcdcc24">SDMMC_CPU_DMA_ALIGNMENT</a>&#160;&#160;&#160;4</td></tr>
<tr class="memdesc:af0cbbd12324a55dc975cd3a7bbcdcc24"><td class="mdescLeft">&#160;</td><td class="mdescRight">SDIO/SDMMC buffer alignment for SDHC because of DMA/FIFO buffer restrictions. <br /></td></tr>
<tr class="separator:af0cbbd12324a55dc975cd3a7bbcdcc24"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1003cd6605561c65d1776afc38c0da23"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="esp32_2include_2periph__cpu_8h.html#a1003cd6605561c65d1776afc38c0da23">sdmmc_slot_t</a> { <a class="el" href="esp32_2include_2periph__cpu_8h.html#a1003cd6605561c65d1776afc38c0da23ac79f8c9b6bd07f92a08fcd5d2f115591">SDMMC_SLOT_0</a> = 0, 
<a class="el" href="esp32_2include_2periph__cpu_8h.html#a1003cd6605561c65d1776afc38c0da23a3ecdc8f14bd264b09cfaa7ead0ff2796">SDMMC_SLOT_1</a> = 1
 }</td></tr>
<tr class="memdesc:a1003cd6605561c65d1776afc38c0da23"><td class="mdescLeft">&#160;</td><td class="mdescRight">SDIO/SDMMC slots.  <a href="esp32_2include_2periph__cpu_8h.html#a1003cd6605561c65d1776afc38c0da23">More...</a><br /></td></tr>
<tr class="separator:a1003cd6605561c65d1776afc38c0da23"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="member-group"></a>
SPI configuration</h2></td></tr>
<tr><td class="ititle" colspan="2"><p><a class="anchor" id="amgrp5c303292f2f3a27a2c901333aa4b560c"></a>ESP32x SoCs have up to four SPI controllers dependent on the specific ESP32x SoC variant (family):</p>
<ul>
<li>Controller SPI0 is reserved for caching external memory like Flash</li>
<li>Controller SPI1 is reserved for external memories like PSRAM</li>
<li>Controller SPI2 can be used as general purpose SPI (GPSPI)</li>
<li>Controller SPI3 can be used as general purpose SPI (GPSPI)</li>
</ul>
<p>The controllers SPI0 and SPI1 share the same bus signals and can only operate in memory mode on most ESP32x SoC variants. Therefore, depending on the specific ESP32x SoC family, a maximum of two SPI controllers can be used as peripheral interfaces:</p>
<ul>
<li>Controller SPI2 is identified by <code>SPI2_HOST</code> (also called FSPI or HSPI)</li>
<li>Controller SPI3 is identified by <code>SPI3_HOST</code> (also called VSPI)</li>
</ul>
<p>In former ESP-IDF versions, SPI interfaces were identified by the alias names <code>FSPI</code>, <code>HSPI</code> and <code>VSPI</code>, which are sometimes also used in data sheets. These alias names have been declared obsolete in ESP-IDF. For source code compatibility reasons these alias names are defined here.</p>
<p>SPI interfaces could be used in quad SPI mode, but RIOT's low level device driver doesn't support it.</p>
<p>The board-specific configuration of the SPI interface <a class="el" href="group__drivers__periph__spi.html#gafb9420809bc7722e41488a090b53eaf9" title="Default SPI device access macro. ">SPI_DEV(n)</a> requires the definition of</p>
<ul>
<li><code>SPIn_CTRL</code>, the SPI controller (<code>SPI_HOST2</code>/<code>SPI_HOST3</code>) used for <a class="el" href="group__drivers__periph__spi.html#gafb9420809bc7722e41488a090b53eaf9" title="Default SPI device access macro. ">SPI_DEV(n)</a>,</li>
<li><code>SPIn_SCK</code>, the GPIO used as clock signal used for <a class="el" href="group__drivers__periph__spi.html#gafb9420809bc7722e41488a090b53eaf9" title="Default SPI device access macro. ">SPI_DEV(n)</a></li>
<li><code>SPIn_MISO</code>, the GPIO used as MISO signal used for <a class="el" href="group__drivers__periph__spi.html#gafb9420809bc7722e41488a090b53eaf9" title="Default SPI device access macro. ">SPI_DEV(n)</a></li>
<li><code>SPIn_MOSI</code>, the GPIO used as MOSI signal used for <a class="el" href="group__drivers__periph__spi.html#gafb9420809bc7722e41488a090b53eaf9" title="Default SPI device access macro. ">SPI_DEV(n)</a>, and</li>
<li><code>SPIn_CS0</code>, the GPIO used as CS signal for <a class="el" href="group__drivers__periph__spi.html#gafb9420809bc7722e41488a090b53eaf9" title="Default SPI device access macro. ">SPI_DEV(n)</a> when the <code>cs</code> parameter in <a class="el" href="group__drivers__periph__spi.html#ga31d89f231c0d6b18a71f2c8f3804e042" title="Start a new SPI transaction. ">spi_acquire</a> is <a class="el" href="group__drivers__periph__gpio.html#ga3969ce1e494a72d3c2925b10ddeb4604" title="GPIO pin not defined. ">GPIO_UNDEF</a>,</li>
</ul>
<p>where <code>n</code> can be 0 and 1. If they are not defined, the according SPI interface <a class="el" href="group__drivers__periph__spi.html#gafb9420809bc7722e41488a090b53eaf9" title="Default SPI device access macro. ">SPI_DEV(n)</a> is not used, for example: </p><div class="fragment"><div class="line"><span class="preprocessor">#define SPI0_CTRL   SPI3_HOST   // VSPI could also be used on ESP32 variant</span></div><div class="line"><span class="preprocessor">#define SPI0_SCK    GPIO18      // SCK  signal</span></div><div class="line"><span class="preprocessor">#define SPI0_MISO   GPIO19      // MISO signal</span></div><div class="line"><span class="preprocessor">#define SPI0_MOSI   GPIO23      // MOSI signal</span></div><div class="line"><span class="preprocessor">#define SPI0_CS0    GPIO5       // CS0  signal</span></div><div class="line"></div><div class="line"><span class="preprocessor">#define SPI1_CTRL   SPI2_HOST   // HSPI could also be used here on ESP32 variant</span></div><div class="line"><span class="preprocessor">#define SPI1_SCK    GPIO14      // SCK  Camera</span></div><div class="line"><span class="preprocessor">#define SPI1_MISO   GPIO12      // MISO Camera</span></div><div class="line"><span class="preprocessor">#define SPI1_MOSI   GPIO13      // MOSI Camera</span></div><div class="line"><span class="preprocessor">#define SPI1_CS0    GPIO15      // CS0  Camera</span></div></div><!-- fragment --><p>The pin configuration of SPI interfaces can be changed by <a href="#esp32_application_specific_configurations">application specific configurations</a> by overriding the according <code>SPIn_*</code> symbols.</p>
<dl class="section note"><dt>Note</dt><dd><ul>
<li>To ensure that the <code>SPIn_*</code> symbols define the configuration for <a class="el" href="group__drivers__periph__spi.html#gafb9420809bc7722e41488a090b53eaf9" title="Default SPI device access macro. ">SPI_DEV(n)</a>, the definition of the configuration of SPI interfaces <a class="el" href="group__drivers__periph__spi.html#gafb9420809bc7722e41488a090b53eaf9" title="Default SPI device access macro. ">SPI_DEV(n)</a> must be in continuous ascending order of <code>n</code>. That is, if <a class="el" href="group__drivers__periph__spi.html#gafb9420809bc7722e41488a090b53eaf9" title="Default SPI device access macro. ">SPI_DEV(1)</a> is used by defining the <code>SPI1_*</code> symbols, <a class="el" href="group__drivers__periph__spi.html#gafb9420809bc7722e41488a090b53eaf9" title="Default SPI device access macro. ">SPI_DEV(0)</a> must also be used by defining the <code>SPI0_*</code> symbols.</li>
<li>The order in which the available interfaces <code>SPI2_HOST</code> (alias <code>HSPI</code> or <code>FSPI</code>) and <code>SPI3_HOST</code> (alias <code>VPSI</code> or <code>HSPI</code>) are assigned doesn't matter.</li>
<li>The GPIOs listed in the configuration are only initialized as SPI signals when the <code>periph_spi</code> module is used. Otherwise they are not allocated and can be used for other purposes.</li>
</ul>
</dd></dl>
<p><a class="el" href="esp8266_2include_2periph__conf__common_8h.html#ab35a2b79568128efef74adf1ba1910a8" title="Number of SPI interfaces. ">SPI_NUMOF</a> is determined automatically from the board-specific peripheral configuration for <a class="el" href="group__drivers__periph__spi.html#gafb9420809bc7722e41488a090b53eaf9" title="Default SPI device access macro. ">SPI_DEV(n)</a>. </p>
</td></tr>
<tr class="memitem:a90e84d581aabaf4e2ed1683e60c8bb15"><td class="memItemLeft" align="right" valign="top"><a id="a90e84d581aabaf4e2ed1683e60c8bb15"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="esp32_2include_2periph__cpu_8h.html#a90e84d581aabaf4e2ed1683e60c8bb15">FSPI</a>&#160;&#160;&#160;SPI2_HOST</td></tr>
<tr class="memdesc:a90e84d581aabaf4e2ed1683e60c8bb15"><td class="mdescLeft">&#160;</td><td class="mdescRight">Alias name for SPI2_HOST as used in former ESP-IDF versions. <br /></td></tr>
<tr class="separator:a90e84d581aabaf4e2ed1683e60c8bb15"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4ca218aaab0f949219155ba184ee0ecf"><td class="memItemLeft" align="right" valign="top"><a id="a4ca218aaab0f949219155ba184ee0ecf"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="esp32_2include_2periph__cpu_8h.html#a4ca218aaab0f949219155ba184ee0ecf">SPI_NUMOF_MAX</a>&#160;&#160;&#160;(SOC_SPI_PERIPH_NUM - 1)</td></tr>
<tr class="memdesc:a4ca218aaab0f949219155ba184ee0ecf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Maximum number of SPI interfaces that can be used by board definitions. <br /></td></tr>
<tr class="separator:a4ca218aaab0f949219155ba184ee0ecf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af3d9c2b9cf24ed0b13807d63f5e9b11f"><td class="memItemLeft" align="right" valign="top"><a id="af3d9c2b9cf24ed0b13807d63f5e9b11f"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="esp32_2include_2periph__cpu_8h.html#af3d9c2b9cf24ed0b13807d63f5e9b11f">PERIPH_SPI_NEEDS_TRANSFER_BYTE</a></td></tr>
<tr class="memdesc:af3d9c2b9cf24ed0b13807d63f5e9b11f"><td class="mdescLeft">&#160;</td><td class="mdescRight">requires function spi_transfer_byte <br /></td></tr>
<tr class="separator:af3d9c2b9cf24ed0b13807d63f5e9b11f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac68c30cec18f4abf11cc4bb09c13df17"><td class="memItemLeft" align="right" valign="top"><a id="ac68c30cec18f4abf11cc4bb09c13df17"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="esp32_2include_2periph__cpu_8h.html#ac68c30cec18f4abf11cc4bb09c13df17">PERIPH_SPI_NEEDS_TRANSFER_REG</a></td></tr>
<tr class="memdesc:ac68c30cec18f4abf11cc4bb09c13df17"><td class="mdescLeft">&#160;</td><td class="mdescRight">requires function spi_transfer_reg <br /></td></tr>
<tr class="separator:ac68c30cec18f4abf11cc4bb09c13df17"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afeb6291046cbd0102e8c87af75e4200d"><td class="memItemLeft" align="right" valign="top"><a id="afeb6291046cbd0102e8c87af75e4200d"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="esp32_2include_2periph__cpu_8h.html#afeb6291046cbd0102e8c87af75e4200d">PERIPH_SPI_NEEDS_TRANSFER_REGS</a></td></tr>
<tr class="memdesc:afeb6291046cbd0102e8c87af75e4200d"><td class="mdescLeft">&#160;</td><td class="mdescRight">requires function spi_transfer_regs <br /></td></tr>
<tr class="separator:afeb6291046cbd0102e8c87af75e4200d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abb62d376a114a58aff9d2177bdb2c3af"><td class="memItemLeft" align="right" valign="top"><a id="abb62d376a114a58aff9d2177bdb2c3af"></a>
typedef spi_host_device_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="esp32_2include_2periph__cpu_8h.html#abb62d376a114a58aff9d2177bdb2c3af">spi_ctrl_t</a></td></tr>
<tr class="memdesc:abb62d376a114a58aff9d2177bdb2c3af"><td class="mdescLeft">&#160;</td><td class="mdescRight">Mapping of SPI controller type for source code compatibility. <br /></td></tr>
<tr class="separator:abb62d376a114a58aff9d2177bdb2c3af"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="member-group"></a>
Timer configuration depending on which implementation is used</h2></td></tr>
<tr><td class="ititle" colspan="2"><p><a class="anchor" id="amgrp438fdd28830d01cfac54cf94bc933428"></a>There are two different implementations for hardware timers.</p>
<ul>
<li><b><a class="el" href="structTimer.html" title="struct to get time references within mqtt paho ">Timer</a> Module implementation</b> Depending on the ESP32x SoC variant (family) it provides up to 4 high speed timers, where 1 timer is used for system time. The remaining timer devices with <b>1 channel</b> each can be used as RIOT timer devices with a clock rate of 1 MHz.</li>
<li><b>Counter implementation</b> Dependent on the ESP32x SoC variant (family), the MCU has up to 3 CCOMPARE (cycle compare) registers. Two of them can be used to implement up to <b>2 timer devices</b> with <b>1 channel</b> each and a clock rate of 1 MHz. This is a feature of Xtensa-based ESP32x SoC variants.</li>
</ul>
<p>By default, the timer module is used. To use the counter implementation, add </p><div class="fragment"><div class="line">USEMODULE += esp_hw_counter</div></div><!-- fragment --><p> to application's makefile.</p>
<p>Timers are MCU built-in features and not board-specific. There is nothing to be configured. </p>
</td></tr>
<tr class="memitem:a6e2f66f5b6f5c835dd11f9766c4ed897"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="esp32_2include_2periph__cpu_8h.html#a6e2f66f5b6f5c835dd11f9766c4ed897">TIMER_NUMOF</a>&#160;&#160;&#160;(SOC_TIMER_GROUP_TOTAL_TIMERS - 1)</td></tr>
<tr class="memdesc:a6e2f66f5b6f5c835dd11f9766c4ed897"><td class="mdescLeft">&#160;</td><td class="mdescRight">Hardware timer modules are used for timer implementation (default)  <a href="#a6e2f66f5b6f5c835dd11f9766c4ed897">More...</a><br /></td></tr>
<tr class="separator:a6e2f66f5b6f5c835dd11f9766c4ed897"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4b87241cfc8f0eb706ef97888f30ed0d"><td class="memItemLeft" align="right" valign="top"><a id="a4b87241cfc8f0eb706ef97888f30ed0d"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>TIMER_CHANNEL_NUMOF</b>&#160;&#160;&#160;(1)</td></tr>
<tr class="separator:a4b87241cfc8f0eb706ef97888f30ed0d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af358407f5bd779fefcae45a13654ad34"><td class="memItemLeft" align="right" valign="top"><a id="af358407f5bd779fefcae45a13654ad34"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="esp32_2include_2periph__cpu_8h.html#af358407f5bd779fefcae45a13654ad34">TIMER_SYSTEM_GROUP</a>&#160;&#160;&#160;TIMER_GROUP_0</td></tr>
<tr class="memdesc:af358407f5bd779fefcae45a13654ad34"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structTimer.html" title="struct to get time references within mqtt paho ">Timer</a> group used for system time. <br /></td></tr>
<tr class="separator:af358407f5bd779fefcae45a13654ad34"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2d974d23c4edaf8358df025174b010ff"><td class="memItemLeft" align="right" valign="top"><a id="a2d974d23c4edaf8358df025174b010ff"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="esp32_2include_2periph__cpu_8h.html#a2d974d23c4edaf8358df025174b010ff">TIMER_SYSTEM_INDEX</a>&#160;&#160;&#160;TIMER_0</td></tr>
<tr class="memdesc:a2d974d23c4edaf8358df025174b010ff"><td class="mdescLeft">&#160;</td><td class="mdescRight">Index of the timer in the timer timer group used for system time. <br /></td></tr>
<tr class="separator:a2d974d23c4edaf8358df025174b010ff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afd27eb6fae4c08ffde8ac7c3e4a0de3b"><td class="memItemLeft" align="right" valign="top"><a id="afd27eb6fae4c08ffde8ac7c3e4a0de3b"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="esp32_2include_2periph__cpu_8h.html#afd27eb6fae4c08ffde8ac7c3e4a0de3b">TIMER_SYSTEM_INT_SRC</a>&#160;&#160;&#160;ETS_TG0_T0_LEVEL_INTR_SOURCE</td></tr>
<tr class="memdesc:afd27eb6fae4c08ffde8ac7c3e4a0de3b"><td class="mdescLeft">&#160;</td><td class="mdescRight">System time interrupt source. <br /></td></tr>
<tr class="separator:afd27eb6fae4c08ffde8ac7c3e4a0de3b"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="member-group"></a>
UART configuration</h2></td></tr>
<tr><td class="ititle" colspan="2"><p><a class="anchor" id="amgrp407a5b3e285fd5f1acd0d75745831cfa"></a>ESP32x SoCs integrate up to three UART devices, depending on the specific ESP32x SoC variant (family).</p>
<p>The pin configuration of the UART device <a class="el" href="group__drivers__periph__uart.html#gafc5afd63560d27731d2517b3005f3294" title="Default UART device access macro. ">UART_DEV(n)</a> is defined in the board-specific peripheral configuration by</p>
<ul>
<li><code>UARTn_TXD</code>, the GPIO used as TxD signal for <a class="el" href="group__drivers__periph__uart.html#gafc5afd63560d27731d2517b3005f3294" title="Default UART device access macro. ">UART_DEV(n)</a>, and</li>
<li><code>UARTn_RXD</code>, the GPIO used as RxD signal for <a class="el" href="group__drivers__periph__uart.html#gafc5afd63560d27731d2517b3005f3294" title="Default UART device access macro. ">UART_DEV(n)</a>,</li>
</ul>
<p>where <code>n</code> can be in range of 0 and UART_NUMOF_MAX-1. If they are not defined, the according UART interface <a class="el" href="group__drivers__periph__uart.html#gafc5afd63560d27731d2517b3005f3294" title="Default UART device access macro. ">UART_DEV(n)</a> is not used, for example: </p><div class="fragment"><div class="line"><span class="preprocessor">#define UART1_TX    GPIO10  // TxD signal of UART_DEV(1)</span></div><div class="line"><span class="preprocessor">#define UART1_RX    GPIO9   // RxD signal of UART_DEV(1)</span></div></div><!-- fragment --><p>The pin configuration of UART interfaces can be changed by <a href="#esp32_application_specific_configurations">application specific configurations</a> by overriding the according <code>UARTn_*</code> symbols.</p>
<dl class="section note"><dt>Note</dt><dd>To ensure that the <code>UARTn_*</code> symbols define the configuration for <a class="el" href="group__drivers__periph__uart.html#gafc5afd63560d27731d2517b3005f3294" title="Default UART device access macro. ">UART_DEV(n)</a>, the configuration of the UART interfaces <a class="el" href="group__drivers__periph__uart.html#gafc5afd63560d27731d2517b3005f3294" title="Default UART device access macro. ">UART_DEV(n)</a> must be in continuous ascending order of <code>n</code>. That is, if <a class="el" href="group__drivers__periph__uart.html#gafc5afd63560d27731d2517b3005f3294" title="Default UART device access macro. ">UART_DEV(1)</a> is to be used by defining the <code>UART1_*</code> symbols, <a class="el" href="group__drivers__periph__uart.html#gafc5afd63560d27731d2517b3005f3294" title="Default UART device access macro. ">UART_DEV(0)</a> must also be used by defining the <code>UART0_*</code> symbols, and if <a class="el" href="group__drivers__periph__uart.html#gafc5afd63560d27731d2517b3005f3294" title="Default UART device access macro. ">UART_DEV(2)</a> is to be used by defining the <code>UART2_*</code> symbols, <a class="el" href="group__drivers__periph__uart.html#gafc5afd63560d27731d2517b3005f3294" title="Default UART device access macro. ">UART_DEV(0)</a> and <a class="el" href="group__drivers__periph__uart.html#gafc5afd63560d27731d2517b3005f3294" title="Default UART device access macro. ">UART_DEV(1)</a> must also be used by defining the <code>UART0_*</code> and <code>UART1_*</code> symbols</dd></dl>
<p><a class="el" href="boards_2nrf9160dk_2include_2periph__conf_8h.html#a850405f2aaa352ad264346531f0e6230" title="UART configuration NUMOF. ">UART_NUMOF</a> is determined automatically from the board-specific peripheral configuration for <a class="el" href="group__drivers__periph__uart.html#gafc5afd63560d27731d2517b3005f3294" title="Default UART device access macro. ">UART_DEV(n)</a>.</p>
<p><a class="el" href="group__drivers__periph__uart.html#gafc5afd63560d27731d2517b3005f3294" title="Default UART device access macro. ">UART_DEV(0)</a> has usually a fixed pin configuration that is used by all ESP32x boards as standard configuration for the console. The GPIOs used for <a class="el" href="group__drivers__periph__uart.html#gafc5afd63560d27731d2517b3005f3294" title="Default UART device access macro. ">UART_DEV(0)</a> depend on the ESP32x SoC family. </p>
</td></tr>
<tr class="memitem:a1045548f8795e9aa17f4cda6f630576a"><td class="memItemLeft" align="right" valign="top"><a id="a1045548f8795e9aa17f4cda6f630576a"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="esp32_2include_2periph__cpu_8h.html#a1045548f8795e9aa17f4cda6f630576a">UART_NUMOF_MAX</a>&#160;&#160;&#160;(SOC_UART_NUM)</td></tr>
<tr class="memdesc:a1045548f8795e9aa17f4cda6f630576a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Maximum number of UART interfaces. <br /></td></tr>
<tr class="separator:a1045548f8795e9aa17f4cda6f630576a"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="member-group"></a>
USB device configuration</h2></td></tr>
<tr><td class="ititle" colspan="2"><p><a class="anchor" id="amgrp0cbe7d23260aad1925ca1257919200c6"></a>ESP32x SoCs integrate depending on the specific ESP32x SoC variant (family) an USB OTG FS controller based on the Synopsys DWC2 IP core. </p>
</td></tr>
<tr class="memitem:af582e2ad4760b1efafd8548d683351b3"><td class="memItemLeft" align="right" valign="top"><a id="af582e2ad4760b1efafd8548d683351b3"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="esp32_2include_2periph__cpu_8h.html#af582e2ad4760b1efafd8548d683351b3">USBDEV_NUMOF_MAX</a>&#160;&#160;&#160;(SOC_USB_PERIPH_NUM)</td></tr>
<tr class="memdesc:af582e2ad4760b1efafd8548d683351b3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Maximum number of USB OTG FS interfaces. <br /></td></tr>
<tr class="separator:af582e2ad4760b1efafd8548d683351b3"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Macro Definition Documentation</h2>
<a id="a759f553fbddd2915b49e50c967661fb1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a759f553fbddd2915b49e50c967661fb1">&#9670;&nbsp;</a></span>HAVE_GPIO_T</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define HAVE_GPIO_T</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Override the default gpio_t type definition. </p>
<p>This is required here to have gpio_t defined in this file. </p>

<p class="definition">Definition at line <a class="el" href="esp32_2include_2periph__cpu_8h_source.html#l00081">81</a> of file <a class="el" href="esp32_2include_2periph__cpu_8h_source.html">periph_cpu.h</a>.</p>

</div>
</div>
<a id="a20377730a568815e8437e099d689e578"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a20377730a568815e8437e099d689e578">&#9670;&nbsp;</a></span>RMT_CH_NUMOF_MAX</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define RMT_CH_NUMOF_MAX&#160;&#160;&#160;(SOC_RMT_CHANNELS_PER_GROUP)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Maximum number of RMT channels. </p>
<p>The number of configured channels must be less or equal. </p>

<p class="definition">Definition at line <a class="el" href="esp32_2include_2periph__cpu_8h_source.html#l00626">626</a> of file <a class="el" href="esp32_2include_2periph__cpu_8h_source.html">periph_cpu.h</a>.</p>

</div>
</div>
<a id="afec7c948b8c70db3c9394fc3dc145a99"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afec7c948b8c70db3c9394fc3dc145a99">&#9670;&nbsp;</a></span>RTT_FREQUENCY</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define RTT_FREQUENCY&#160;&#160;&#160;(32768UL)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>RTT frequency definition. </p>
<p>The RTT frequency is always 32.768 kHz even if no external crystal is connected. In this case the RTT value counted with the internal 150 kHz RC oscillator is converted to a value for an RTT with 32.768 kHz. </p>

<p class="definition">Definition at line <a class="el" href="esp32_2include_2periph__cpu_8h_source.html#l00653">653</a> of file <a class="el" href="esp32_2include_2periph__cpu_8h_source.html">periph_cpu.h</a>.</p>

</div>
</div>
<a id="a6e2f66f5b6f5c835dd11f9766c4ed897"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6e2f66f5b6f5c835dd11f9766c4ed897">&#9670;&nbsp;</a></span>TIMER_NUMOF</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define TIMER_NUMOF&#160;&#160;&#160;(SOC_TIMER_GROUP_TOTAL_TIMERS - 1)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Hardware timer modules are used for timer implementation (default) </p>
<p>Since one timer is used for the system time, there is one timer less than the total number of timers. </p>

<p class="definition">Definition at line <a class="el" href="esp32_2include_2periph__cpu_8h_source.html#l00913">913</a> of file <a class="el" href="esp32_2include_2periph__cpu_8h_source.html">periph_cpu.h</a>.</p>

</div>
</div>
<h2 class="groupheader">Enumeration Type Documentation</h2>
<a id="a1003cd6605561c65d1776afc38c0da23"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1003cd6605561c65d1776afc38c0da23">&#9670;&nbsp;</a></span>sdmmc_slot_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="esp32_2include_2periph__cpu_8h.html#a1003cd6605561c65d1776afc38c0da23">sdmmc_slot_t</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>SDIO/SDMMC slots. </p>
<p>ESP32x SoCs that have a SDMMC peripheral provide two SDMMC interfaces called slots.</p>
<dl class="section note"><dt>Note</dt><dd>If the ESP32x variant uses direct I/O functions for the SDMMC signals (i.e. <code>SOC_SDMMC_USE_IOMUX</code> is defined in SoC capabilities), the GPIOs used for the SDMMC slots are fixed. In this case, slot 0 can't be used because the GPIOs are defined for Slot 0 are the same as those used for the Flash. If the ESP32x variant uses the GPIO matrix to route the SDMMC signals to arbitrary pins (i.e. <code>SOC_SDMMC_USE_GPIO_MATRIX</code> is defined in SoC capabilities), slot 0 can be used but the GPIOs used for the slot have to be different from those used for the Flash. </dd></dl>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="a1003cd6605561c65d1776afc38c0da23ac79f8c9b6bd07f92a08fcd5d2f115591"></a>SDMMC_SLOT_0&#160;</td><td class="fielddoc"><p>SD/MMC host controller slot 0 (not usable on ESP32 variant) </p>
</td></tr>
<tr><td class="fieldname"><a id="a1003cd6605561c65d1776afc38c0da23a3ecdc8f14bd264b09cfaa7ead0ff2796"></a>SDMMC_SLOT_1&#160;</td><td class="fielddoc"><p>SD/MMC host controller slot 1. </p>
</td></tr>
</table>

<p class="definition">Definition at line <a class="el" href="esp32_2include_2periph__cpu_8h_source.html#l00686">686</a> of file <a class="el" href="esp32_2include_2periph__cpu_8h_source.html">periph_cpu.h</a>.</p>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
    <div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
        <ul>
            <li class="footer">Generated on Thu Mar 13 2025 10:38:25 by <a href="http://www.doxygen.org/index.html">
                       <img class="footer" src="doxygen.png" alt="doxygen"></a> 1.8.14</li>
        </ul>
    </div>
    <!-- Include all compiled plugins (below), or include individual files as needed -->
    <script src="bootstrap.min.js"></script>
    <script src="jquery.smartmenus.min.js"></script>
    <script src="jquery.smartmenus.bootstrap.min.js"></script>
    <script src="riot-doxy.js"></script>
  </body>
</html>
