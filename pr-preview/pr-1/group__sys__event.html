<!DOCTYPE html>
<html lang="en">
  <head>
    <link rel="icon" type="image/png" href="favicon.png">
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <!-- The above 3 meta tags *must* come first in the head; any other head content must come *after* these tags -->
    <title>Event Queue</title>
    <!-- jQuery (necessary for Bootstrap's JavaScript plugins) -->
    <script src="jquery.min.js"></script>
    <script src="jquery.powertip.min.js"></script>
    <script src="jquery-ui.min.js"></script>
    <script src="jquery.scrollTo.min.js"></script>
    <script src="doxy-jquery.js"></script>
    <script src="dynsections.js"></script>
    <link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
  $(document).ready(initResizable);
/* @license-end */</script>
    <link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
    <!-- Bootstrap -->
    <link href="doxygen.css" rel="stylesheet">
    <link href="fonts.css" rel="stylesheet">
    <link href="bootstrap.min.css" rel="stylesheet">
    <link href="jquery.smartmenus.bootstrap.css" rel="stylesheet">
    <link href="riot.css" rel="stylesheet">
    <!-- HTML5 shim and Respond.js for IE8 support of HTML5 elements and media queries -->
    <!-- WARNING: Respond.js doesn't work if you view the page via file:// -->
    <!--[if lt IE 9]>
      <script src="https://oss.maxcdn.com/html5shiv/3.7.3/html5shiv.min.js"></script>
      <script src="https://oss.maxcdn.com/respond/1.4.2/respond.min.js"></script>
    <![endif]-->
        <script>
            function displaySR(){
            searchBox.Search();
            var rhtml=(document.getElementById('MSearchResults').contentWindow.document.body.innerHTML).replace(/href=\"\.\.\//g,'href="');
            document.getElementById('MSearchResultsWindow').style.display='none';
            document.getElementById('top').append(document.getElementById('MSearchSelectWindow'));
            document.getElementById('top').append(document.getElementById('MSearchResultsWindow'));
            document.getElementById('doc-content').innerHTML=rhtml;
            }
            function modSearch(){
            if(!searchBox.doxySearch){
                searchBox.doxySearch=searchBox.Search
                searchBox.Search= function(){this.doxySearch();
                var r=document.getElementById('MSearchResultsWindow');console.log(r.style);
                if(parseInt(r.style.left)<0)r.style.left=0;
                var x=document.getElementById('MSearchResults');
                if(x.scrollWidth>window.screen.width)x.style.width=window.screen.width-2+'px';
                var f=document.getElementById('riot-searchform');
                if(parseInt( r.style.top) < f.offsetTop+f.scrollHeight) r.style.top = f.offsetTop+f.scrollHeight+'px';}
            }
            }
        </script>
  </head>
  <body>
      <div id="top">
        <nav class="navbar navbar-inverse">
          <div class="container-fluid">
            <!-- Brand and toggle get grouped for better mobile display -->
            <div class="navbar-header">
              <button type="button" class="navbar-toggle collapsed" data-toggle="collapse" data-target="#navbar-collapse" aria-expanded="false">
                <span class="sr-only">Toggle navigation</span>
                <span class="icon-bar"></span>
                <span class="icon-bar"></span>
                <span class="icon-bar"></span>
              </button>
              <a class="navbar-brand" id="brand-logo" href="http://riot-os.org"><img height="40px" src="riot-logo.svg" /></a>
              <p class="navbar-text text-center visible-xs">Documentation</p>
            </div>
            <!-- Collect the nav links, forms, and other content for toggling -->
            <div class="collapse navbar-collapse" id="navbar-collapse">
              <p class="navbar-text navbar-left"><span id="projectbrief">The friendly Operating System for the Internet of Things</span></p>
              <ul id="riot-navlist" class="nav navbar-nav"></ul>
              <form id="riot-searchform" class="navbar-form navbar-left navbar-right" action="https://duckduckgo.com/" method="get">
                 <input type="hidden" name="sites" value="doc.riot-os.org"/>
                 <input type="hidden" name="kt" value="h"/>
                 <div class="form-group">
                   <div id="MSearchBox" class="MSearchBoxActive">
                     <div class="input-group">
                       <div class="input-group-addon">
                         <span id="MSearchSelect" class="glyphicon glyphicon-search" aria-hidden="true" onmouseover="return searchBox.OnSearchSelectShow()" onmouseout="return searchBox.OnSearchSelectHide()"></span>
                       </div>
                       <input class="form-control" type="text" name="q" id="MSearchField" placeholder="Search" accesskey="S" onfocus="searchBox.OnSearchFieldFocus(true)" onblur="searchBox.OnSearchFieldFocus(false)" onkeyup="searchBox.OnSearchFieldChange(event); modSearch();">
                       <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()">
                         <span id="search-reset" class="glyphicon glyphicon-remove-circle" aria-hidden="true"></span>
                       </a>
                     </div>
                   </div>
                 </div>
              </form>
            </div><!-- /.navbar-collapse -->
          </div><!-- /.container-fluid -->
        </nav>
      </div>
<!-- Generated by Doxygen 1.8.14 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(document).ready(function(){initNavTree('group__sys__event.html','');});
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#files">Files</a> &#124;
<a href="#nested-classes">Data Structures</a> &#124;
<a href="#define-members">Macros</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">Event Queue<div class="ingroups"><a class="el" href="group__sys.html">System</a></div></div>  </div>
</div><!--header-->
<div class="contents">

<p>Provides an Event loop.  
<a href="#details">More...</a></p>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<p>Provides an Event loop. </p>
<p>This module offers an event queue framework like libevent or libuev.</p>
<p>An event queue is basically a FIFO queue of events, with some functions to efficiently and safely handle adding and getting events to / from such a queue.</p>
<p>An event queue is bound to a thread, but any thread or ISR can put events into a queue. In most cases, the owning thread of a queue is set during the queue's initialization. But it is also possible to initialize a queue in a detached state from a different context and to set the owning thread at a later point of time using the <a class="el" href="group__sys__event.html#ga901462dc0093b6da40ec2fa787ac704f" title="Bind an event queue to the calling thread. ">event_queue_claim()</a> function.</p>
<p>An event is a structure containing a pointer to an event handler. It can be extended to provide context or arguments to the handler. It can also be embedded into existing structures (see examples).</p>
<p>Compared to msg or mbox, this some fundamental differences:</p>
<ol type="1">
<li>events are "sender allocated". Unlike <a class="el" href="group__core__msg.html#gac5347725c3d203ac72604c0ab8b7d6d8" title="Send a message (blocking). ">msg_send()</a>, <a class="el" href="group__sys__event.html#ga2053ce1facf709fffd024bee9e2383ba" title="Queue an event. ">event_post()</a> never blocks or fails.</li>
<li>events contain everything necessary to handle them, thus a thread processing the events of an event queue doesn't need to be changed in order to support new event types.</li>
<li>events can be safely used (and actually perform best) when used within one thread, e.g., in order to create a state-machine like process flow. This is not (easily) possible using msg queues, as they might fill up.</li>
<li>an event can only be queued in one event queue at the same time. Notifying many queues using only one event object is not possible with this implementation.</li>
</ol>
<p>At the core, <a class="el" href="group__sys__event.html#ga1a8c9a1fbf3ffc656a1ab53ab1585df3" title="Get next event from event queue, blocking. ">event_wait()</a> uses thread flags to implement waiting for events to be queued. Thus event queues can be used safely and efficiently in combination with thread flags and msg queues.</p>
<p>Examples:</p>
<div class="fragment"><div class="line"><span class="comment">// simple event handler</span></div><div class="line"><span class="keyword">static</span> <span class="keywordtype">void</span> handler(<a class="code" href="structevent.html">event_t</a> *<a class="code" href="structevent.html">event</a>)</div><div class="line">{</div><div class="line">   <a class="code" href="group__cpu__avr8__common__stdio__wrapper.html#gad2eb277496af160238e7306fff780ad2">printf</a>(<span class="stringliteral">&quot;triggered 0x%08x\n&quot;</span>, (<span class="keywordtype">unsigned</span>)<a class="code" href="structevent.html">event</a>);</div><div class="line">}</div><div class="line"></div><div class="line"><span class="keyword">static</span> <a class="code" href="structevent.html">event_t</a> <span class="keyword">event</span> = { .<a class="code" href="structevent.html#a09014dfe22d45e0d11b3d71f0361dbb7">handler</a> = handler };</div><div class="line"><span class="keyword">static</span> <a class="code" href="structPTRTAG.html">event_queue_t</a> queue;</div><div class="line"></div><div class="line"><span class="keywordtype">int</span> main(<span class="keywordtype">void</span>)</div><div class="line">{</div><div class="line">    <a class="code" href="group__sys__event.html#ga609d4085b10b48c8b8725dab5b465896">event_queue_init</a>(&amp;queue);</div><div class="line">    <a class="code" href="group__sys__event.html#ga321751eb630a363f187305e098229e7d">event_loop</a>(&amp;queue);</div><div class="line">}</div><div class="line"></div><div class="line">[...] <a class="code" href="group__sys__event.html#ga2053ce1facf709fffd024bee9e2383ba">event_post</a>(&amp;queue, &amp;<a class="code" href="structevent.html">event</a>);</div><div class="line"></div><div class="line"><span class="comment">// example for event extended event struct</span></div><div class="line"><span class="keyword">typedef</span> <span class="keyword">struct </span>{</div><div class="line">    <a class="code" href="structevent.html">event_t</a> super;</div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">char</span> *text;</div><div class="line">} custom_event_t;</div><div class="line"></div><div class="line"><span class="keyword">static</span> <span class="keywordtype">void</span> custom_handler(<a class="code" href="structevent.html">event_t</a> *<a class="code" href="structevent.html">event</a>)</div><div class="line">{</div><div class="line">    custom_event_t *custom_event = <a class="code" href="container_8h.html#aa06910d90372b14a0756bf14cdc64811">container_of</a>(<a class="code" href="structevent.html">event</a>, custom_event_t, super);</div><div class="line">    <a class="code" href="group__cpu__avr8__common__stdio__wrapper.html#gad2eb277496af160238e7306fff780ad2">printf</a>(<span class="stringliteral">&quot;triggered custom event with text: \&quot;%s\&quot;\n&quot;</span>, custom_event-&gt;text);</div><div class="line">}</div><div class="line"></div><div class="line"><span class="keyword">static</span> custom_event_t custom_event = { .super.handler = custom_handler, .text = <span class="stringliteral">&quot;CUSTOM EVENT&quot;</span> };</div><div class="line"></div><div class="line">[...] <a class="code" href="group__sys__event.html#ga2053ce1facf709fffd024bee9e2383ba">event_post</a>(&amp;queue, &amp;custom_event.super)</div></div><!-- fragment --> <table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="files"></a>
Files</h2></td></tr>
<tr class="memitem:callback_8h"><td class="memItemLeft" align="right" valign="top">file &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="callback_8h.html">callback.h</a></td></tr>
<tr class="memdesc:callback_8h"><td class="mdescLeft">&#160;</td><td class="mdescRight">Provides a callback-with-argument event type. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:deferred__callback_8h"><td class="memItemLeft" align="right" valign="top">file &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="deferred__callback_8h.html">deferred_callback.h</a></td></tr>
<tr class="memdesc:deferred__callback_8h"><td class="mdescLeft">&#160;</td><td class="mdescRight">Trigger an event callback after a timeout. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:event_2periodic_8h"><td class="memItemLeft" align="right" valign="top">file &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="event_2periodic_8h.html">periodic.h</a></td></tr>
<tr class="memdesc:event_2periodic_8h"><td class="mdescLeft">&#160;</td><td class="mdescRight">Provides functionality to trigger periodic events. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:periodic__callback_8h"><td class="memItemLeft" align="right" valign="top">file &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="periodic__callback_8h.html">periodic_callback.h</a></td></tr>
<tr class="memdesc:periodic__callback_8h"><td class="mdescLeft">&#160;</td><td class="mdescRight">Provides functionality to trigger periodic event callbacks. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:source_8h"><td class="memItemLeft" align="right" valign="top">file &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="source_8h.html">source.h</a></td></tr>
<tr class="memdesc:source_8h"><td class="mdescLeft">&#160;</td><td class="mdescRight">Provides functionality to trigger multiple events at once. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:sys_2include_2event_2thread_8h"><td class="memItemLeft" align="right" valign="top">file &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sys_2include_2event_2thread_8h.html">thread.h</a></td></tr>
<tr class="memdesc:sys_2include_2event_2thread_8h"><td class="mdescLeft">&#160;</td><td class="mdescRight">Provides utility functions for event handler threads. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:event_2timeout_8h"><td class="memItemLeft" align="right" valign="top">file &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="event_2timeout_8h.html">timeout.h</a></td></tr>
<tr class="memdesc:event_2timeout_8h"><td class="mdescLeft">&#160;</td><td class="mdescRight">Provides functionality to trigger events after timeout. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:event_8h"><td class="memItemLeft" align="right" valign="top">file &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="event_8h.html">event.h</a></td></tr>
<tr class="memdesc:event_8h"><td class="mdescLeft">&#160;</td><td class="mdescRight">Event API. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Data Structures</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structevent.html">event</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">event structure  <a href="structevent.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structPTRTAG.html">PTRTAG</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">event queue structure  <a href="structPTRTAG.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="define-members"></a>
Macros</h2></td></tr>
<tr class="memitem:gaafa9b96ad0e2d68d166b6ba394660a4b"><td class="memItemLeft" align="right" valign="top"><a id="gaafa9b96ad0e2d68d166b6ba394660a4b"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__sys__event.html#gaafa9b96ad0e2d68d166b6ba394660a4b">THREAD_FLAG_EVENT</a>&#160;&#160;&#160;(0x1)</td></tr>
<tr class="memdesc:gaafa9b96ad0e2d68d166b6ba394660a4b"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structThread.html" title="Thread struct within mqtt paho. ">Thread</a> flag use to notify available events in an event queue. <br /></td></tr>
<tr class="separator:gaafa9b96ad0e2d68d166b6ba394660a4b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gafbc0919266554541d5723bed79b1e3ed"><td class="memItemLeft" align="right" valign="top"><a id="gafbc0919266554541d5723bed79b1e3ed"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__sys__event.html#gafbc0919266554541d5723bed79b1e3ed">EVENT_QUEUE_INIT</a>&#160;&#160;&#160;{ .waiter = <a class="el" href="group__core__thread.html#ga605ef75cf40c9116339ba8ef54193e4c">thread_get_active</a>() }</td></tr>
<tr class="memdesc:gafbc0919266554541d5723bed79b1e3ed"><td class="mdescLeft">&#160;</td><td class="mdescRight">event_queue_t static initializer <br /></td></tr>
<tr class="separator:gafbc0919266554541d5723bed79b1e3ed"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4e41a0654cf42441ef0a640053894911"><td class="memItemLeft" align="right" valign="top"><a id="ga4e41a0654cf42441ef0a640053894911"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__sys__event.html#ga4e41a0654cf42441ef0a640053894911">EVENT_QUEUE_INIT_DETACHED</a>&#160;&#160;&#160;{ .waiter = NULL }</td></tr>
<tr class="memdesc:ga4e41a0654cf42441ef0a640053894911"><td class="mdescLeft">&#160;</td><td class="mdescRight">static initializer for detached event queues <br /></td></tr>
<tr class="separator:ga4e41a0654cf42441ef0a640053894911"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:gad0c066ffb009d3286186a124d37a0c2d"><td class="memItemLeft" align="right" valign="top"><a id="gad0c066ffb009d3286186a124d37a0c2d"></a>
typedef struct <a class="el" href="structevent.html">event</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__sys__event.html#gad0c066ffb009d3286186a124d37a0c2d">event_t</a></td></tr>
<tr class="memdesc:gad0c066ffb009d3286186a124d37a0c2d"><td class="mdescLeft">&#160;</td><td class="mdescRight">event structure forward declaration <br /></td></tr>
<tr class="separator:gad0c066ffb009d3286186a124d37a0c2d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga60c9f34f565c834ed82a585d154d0010"><td class="memItemLeft" align="right" valign="top"><a id="ga60c9f34f565c834ed82a585d154d0010"></a>
typedef void(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__sys__event.html#ga60c9f34f565c834ed82a585d154d0010">event_handler_t</a>) (<a class="el" href="group__sys__event.html#gad0c066ffb009d3286186a124d37a0c2d">event_t</a> *)</td></tr>
<tr class="memdesc:ga60c9f34f565c834ed82a585d154d0010"><td class="mdescLeft">&#160;</td><td class="mdescRight">event handler type definition <br /></td></tr>
<tr class="separator:ga60c9f34f565c834ed82a585d154d0010"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab46c611438815de2e758821bfaab6d04"><td class="memItemLeft" align="right" valign="top"><a id="gab46c611438815de2e758821bfaab6d04"></a>
typedef struct <a class="el" href="structPTRTAG.html">PTRTAG</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__sys__event.html#gab46c611438815de2e758821bfaab6d04">event_queue_t</a></td></tr>
<tr class="memdesc:gab46c611438815de2e758821bfaab6d04"><td class="mdescLeft">&#160;</td><td class="mdescRight">event queue structure <br /></td></tr>
<tr class="separator:gab46c611438815de2e758821bfaab6d04"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:gad0b53659c2fbf312ff1a47782a42e0cb"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__sys__event.html#gad0b53659c2fbf312ff1a47782a42e0cb">event_queues_init</a> (<a class="el" href="group__sys__event.html#gab46c611438815de2e758821bfaab6d04">event_queue_t</a> *queues, size_t n_queues)</td></tr>
<tr class="memdesc:gad0b53659c2fbf312ff1a47782a42e0cb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initialize an array of event queues.  <a href="#gad0b53659c2fbf312ff1a47782a42e0cb">More...</a><br /></td></tr>
<tr class="separator:gad0b53659c2fbf312ff1a47782a42e0cb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga609d4085b10b48c8b8725dab5b465896"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__sys__event.html#ga609d4085b10b48c8b8725dab5b465896">event_queue_init</a> (<a class="el" href="group__sys__event.html#gab46c611438815de2e758821bfaab6d04">event_queue_t</a> *queue)</td></tr>
<tr class="memdesc:ga609d4085b10b48c8b8725dab5b465896"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initialize an event queue.  <a href="#ga609d4085b10b48c8b8725dab5b465896">More...</a><br /></td></tr>
<tr class="separator:ga609d4085b10b48c8b8725dab5b465896"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaba3402e5ea1b6f2682b7e4f6a8294150"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__sys__event.html#gaba3402e5ea1b6f2682b7e4f6a8294150">event_queues_init_detached</a> (<a class="el" href="group__sys__event.html#gab46c611438815de2e758821bfaab6d04">event_queue_t</a> *queues, size_t n_queues)</td></tr>
<tr class="memdesc:gaba3402e5ea1b6f2682b7e4f6a8294150"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initialize an array of event queues not binding it to a thread.  <a href="#gaba3402e5ea1b6f2682b7e4f6a8294150">More...</a><br /></td></tr>
<tr class="separator:gaba3402e5ea1b6f2682b7e4f6a8294150"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7abb6e200225ac747dcccc071add6a24"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__sys__event.html#ga7abb6e200225ac747dcccc071add6a24">event_queue_init_detached</a> (<a class="el" href="group__sys__event.html#gab46c611438815de2e758821bfaab6d04">event_queue_t</a> *queue)</td></tr>
<tr class="memdesc:ga7abb6e200225ac747dcccc071add6a24"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initialize an event queue not binding it to a thread.  <a href="#ga7abb6e200225ac747dcccc071add6a24">More...</a><br /></td></tr>
<tr class="separator:ga7abb6e200225ac747dcccc071add6a24"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa3f1745747ef9c13022aa925eead68cd"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__sys__event.html#gaa3f1745747ef9c13022aa925eead68cd">event_queues_claim</a> (<a class="el" href="group__sys__event.html#gab46c611438815de2e758821bfaab6d04">event_queue_t</a> *queues, size_t n_queues)</td></tr>
<tr class="memdesc:gaa3f1745747ef9c13022aa925eead68cd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Bind an array of event queues to the calling thread.  <a href="#gaa3f1745747ef9c13022aa925eead68cd">More...</a><br /></td></tr>
<tr class="separator:gaa3f1745747ef9c13022aa925eead68cd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga901462dc0093b6da40ec2fa787ac704f"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__sys__event.html#ga901462dc0093b6da40ec2fa787ac704f">event_queue_claim</a> (<a class="el" href="group__sys__event.html#gab46c611438815de2e758821bfaab6d04">event_queue_t</a> *queue)</td></tr>
<tr class="memdesc:ga901462dc0093b6da40ec2fa787ac704f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Bind an event queue to the calling thread.  <a href="#ga901462dc0093b6da40ec2fa787ac704f">More...</a><br /></td></tr>
<tr class="separator:ga901462dc0093b6da40ec2fa787ac704f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2053ce1facf709fffd024bee9e2383ba"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__sys__event.html#ga2053ce1facf709fffd024bee9e2383ba">event_post</a> (<a class="el" href="group__sys__event.html#gab46c611438815de2e758821bfaab6d04">event_queue_t</a> *queue, <a class="el" href="group__sys__event.html#gad0c066ffb009d3286186a124d37a0c2d">event_t</a> *<a class="el" href="structevent.html">event</a>)</td></tr>
<tr class="memdesc:ga2053ce1facf709fffd024bee9e2383ba"><td class="mdescLeft">&#160;</td><td class="mdescRight">Queue an event.  <a href="#ga2053ce1facf709fffd024bee9e2383ba">More...</a><br /></td></tr>
<tr class="separator:ga2053ce1facf709fffd024bee9e2383ba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga696280baa5719e3c5ef75fec41e81b3a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__sys__event.html#ga696280baa5719e3c5ef75fec41e81b3a">event_cancel</a> (<a class="el" href="group__sys__event.html#gab46c611438815de2e758821bfaab6d04">event_queue_t</a> *queue, <a class="el" href="group__sys__event.html#gad0c066ffb009d3286186a124d37a0c2d">event_t</a> *<a class="el" href="structevent.html">event</a>)</td></tr>
<tr class="memdesc:ga696280baa5719e3c5ef75fec41e81b3a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Cancel a queued event.  <a href="#ga696280baa5719e3c5ef75fec41e81b3a">More...</a><br /></td></tr>
<tr class="separator:ga696280baa5719e3c5ef75fec41e81b3a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae22c0ded4bec448dacb780e8948f416a"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__sys__event.html#gae22c0ded4bec448dacb780e8948f416a">event_is_queued</a> (const <a class="el" href="group__sys__event.html#gab46c611438815de2e758821bfaab6d04">event_queue_t</a> *queue, const <a class="el" href="group__sys__event.html#gad0c066ffb009d3286186a124d37a0c2d">event_t</a> *<a class="el" href="structevent.html">event</a>)</td></tr>
<tr class="memdesc:gae22c0ded4bec448dacb780e8948f416a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if an event is already queued.  <a href="#gae22c0ded4bec448dacb780e8948f416a">More...</a><br /></td></tr>
<tr class="separator:gae22c0ded4bec448dacb780e8948f416a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae5b6336946a171046f7626f476fba292"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__sys__event.html#gad0c066ffb009d3286186a124d37a0c2d">event_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__sys__event.html#gae5b6336946a171046f7626f476fba292">event_get</a> (<a class="el" href="group__sys__event.html#gab46c611438815de2e758821bfaab6d04">event_queue_t</a> *queue)</td></tr>
<tr class="memdesc:gae5b6336946a171046f7626f476fba292"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get next event from event queue, non-blocking.  <a href="#gae5b6336946a171046f7626f476fba292">More...</a><br /></td></tr>
<tr class="separator:gae5b6336946a171046f7626f476fba292"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf549606f1a9059f0b1b0cef87ca6a95b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__sys__event.html#gad0c066ffb009d3286186a124d37a0c2d">event_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__sys__event.html#gaf549606f1a9059f0b1b0cef87ca6a95b">event_wait_multi</a> (<a class="el" href="group__sys__event.html#gab46c611438815de2e758821bfaab6d04">event_queue_t</a> *queues, size_t n_queues)</td></tr>
<tr class="memdesc:gaf549606f1a9059f0b1b0cef87ca6a95b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get next event from the given event queues, blocking.  <a href="#gaf549606f1a9059f0b1b0cef87ca6a95b">More...</a><br /></td></tr>
<tr class="separator:gaf549606f1a9059f0b1b0cef87ca6a95b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1a8c9a1fbf3ffc656a1ab53ab1585df3"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="group__sys__event.html#gad0c066ffb009d3286186a124d37a0c2d">event_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__sys__event.html#ga1a8c9a1fbf3ffc656a1ab53ab1585df3">event_wait</a> (<a class="el" href="group__sys__event.html#gab46c611438815de2e758821bfaab6d04">event_queue_t</a> *queue)</td></tr>
<tr class="memdesc:ga1a8c9a1fbf3ffc656a1ab53ab1585df3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get next event from event queue, blocking.  <a href="#ga1a8c9a1fbf3ffc656a1ab53ab1585df3">More...</a><br /></td></tr>
<tr class="separator:ga1a8c9a1fbf3ffc656a1ab53ab1585df3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf979ad68f1d4ef379de1f0da0644ff72"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__sys__event.html#gad0c066ffb009d3286186a124d37a0c2d">event_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__sys__event.html#gaf979ad68f1d4ef379de1f0da0644ff72">event_wait_timeout</a> (<a class="el" href="group__sys__event.html#gab46c611438815de2e758821bfaab6d04">event_queue_t</a> *queue, uint32_t timeout)</td></tr>
<tr class="memdesc:gaf979ad68f1d4ef379de1f0da0644ff72"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get next event from event queue, blocking until timeout expires.  <a href="#gaf979ad68f1d4ef379de1f0da0644ff72">More...</a><br /></td></tr>
<tr class="separator:gaf979ad68f1d4ef379de1f0da0644ff72"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga22551716e8df163590e16bf2cc5ff590"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__sys__event.html#gad0c066ffb009d3286186a124d37a0c2d">event_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__sys__event.html#ga22551716e8df163590e16bf2cc5ff590">event_wait_timeout64</a> (<a class="el" href="group__sys__event.html#gab46c611438815de2e758821bfaab6d04">event_queue_t</a> *queue, uint64_t timeout)</td></tr>
<tr class="memdesc:ga22551716e8df163590e16bf2cc5ff590"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get next event from event queue, blocking until timeout expires.  <a href="#ga22551716e8df163590e16bf2cc5ff590">More...</a><br /></td></tr>
<tr class="separator:ga22551716e8df163590e16bf2cc5ff590"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6bfc83e3b8a0fcc0ba88fc905412ca5f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__sys__event.html#gad0c066ffb009d3286186a124d37a0c2d">event_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__sys__event.html#ga6bfc83e3b8a0fcc0ba88fc905412ca5f">event_wait_timeout_ztimer</a> (<a class="el" href="group__sys__event.html#gab46c611438815de2e758821bfaab6d04">event_queue_t</a> *queue, <a class="el" href="group__sys__ztimer.html#ga3639ce794c3bd80a6e9bbe88a7db4a88">ztimer_clock_t</a> *clock, uint32_t timeout)</td></tr>
<tr class="memdesc:ga6bfc83e3b8a0fcc0ba88fc905412ca5f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get next event from event queue, blocking until timeout expires.  <a href="#ga6bfc83e3b8a0fcc0ba88fc905412ca5f">More...</a><br /></td></tr>
<tr class="separator:ga6bfc83e3b8a0fcc0ba88fc905412ca5f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1d52cdf6e7593e240311a119ca076f7e"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__sys__event.html#ga1d52cdf6e7593e240311a119ca076f7e">event_loop_multi</a> (<a class="el" href="group__sys__event.html#gab46c611438815de2e758821bfaab6d04">event_queue_t</a> *queues, size_t n_queues)</td></tr>
<tr class="memdesc:ga1d52cdf6e7593e240311a119ca076f7e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Simple event loop with multiple queues.  <a href="#ga1d52cdf6e7593e240311a119ca076f7e">More...</a><br /></td></tr>
<tr class="separator:ga1d52cdf6e7593e240311a119ca076f7e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga321751eb630a363f187305e098229e7d"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__sys__event.html#ga321751eb630a363f187305e098229e7d">event_loop</a> (<a class="el" href="group__sys__event.html#gab46c611438815de2e758821bfaab6d04">event_queue_t</a> *queue)</td></tr>
<tr class="memdesc:ga321751eb630a363f187305e098229e7d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Simple event loop.  <a href="#ga321751eb630a363f187305e098229e7d">More...</a><br /></td></tr>
<tr class="separator:ga321751eb630a363f187305e098229e7d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa4393a26ef6c5cd25f7d07edfafb2acf"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__sys__event.html#gaa4393a26ef6c5cd25f7d07edfafb2acf">event_sync</a> (<a class="el" href="group__sys__event.html#gab46c611438815de2e758821bfaab6d04">event_queue_t</a> *queue)</td></tr>
<tr class="memdesc:gaa4393a26ef6c5cd25f7d07edfafb2acf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Synchronize with the last event on the queue.  <a href="#gaa4393a26ef6c5cd25f7d07edfafb2acf">More...</a><br /></td></tr>
<tr class="separator:gaa4393a26ef6c5cd25f7d07edfafb2acf"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Function Documentation</h2>
<a id="ga696280baa5719e3c5ef75fec41e81b3a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga696280baa5719e3c5ef75fec41e81b3a">&#9670;&nbsp;</a></span>event_cancel()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void event_cancel </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__sys__event.html#gab46c611438815de2e758821bfaab6d04">event_queue_t</a> *&#160;</td>
          <td class="paramname"><em>queue</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__sys__event.html#gad0c066ffb009d3286186a124d37a0c2d">event_t</a> *&#160;</td>
          <td class="paramname"><em>event</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Cancel a queued event. </p>
<p>This will remove a queued event from an event queue.</p>
<dl class="section note"><dt>Note</dt><dd>Due to the underlying list implementation, this will run in O(n).</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">queue</td><td>event queue to remove event from </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">event</td><td>event to remove from queue </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gae5b6336946a171046f7626f476fba292"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gae5b6336946a171046f7626f476fba292">&#9670;&nbsp;</a></span>event_get()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__sys__event.html#gad0c066ffb009d3286186a124d37a0c2d">event_t</a>* event_get </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__sys__event.html#gab46c611438815de2e758821bfaab6d04">event_queue_t</a> *&#160;</td>
          <td class="paramname"><em>queue</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get next event from event queue, non-blocking. </p>
<p>In order to handle an event retrieved using this function, call event-&gt;handler(event).</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">queue</td><td>event queue to get event from</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>pointer to next event </dd>
<dd>
NULL if no event available </dd></dl>

</div>
</div>
<a id="gae22c0ded4bec448dacb780e8948f416a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gae22c0ded4bec448dacb780e8948f416a">&#9670;&nbsp;</a></span>event_is_queued()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool event_is_queued </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="group__sys__event.html#gab46c611438815de2e758821bfaab6d04">event_queue_t</a> *&#160;</td>
          <td class="paramname"><em>queue</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group__sys__event.html#gad0c066ffb009d3286186a124d37a0c2d">event_t</a> *&#160;</td>
          <td class="paramname"><em>event</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Check if an event is already queued. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">queue</td><td>event queue to check </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">event</td><td>event to check</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if <code>event</code> is in <code>queue</code> </dd>
<dd>
false otherwise </dd></dl>

</div>
</div>
<a id="ga321751eb630a363f187305e098229e7d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga321751eb630a363f187305e098229e7d">&#9670;&nbsp;</a></span>event_loop()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void event_loop </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__sys__event.html#gab46c611438815de2e758821bfaab6d04">event_queue_t</a> *&#160;</td>
          <td class="paramname"><em>queue</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Simple event loop. </p>
<p>This function will forever sit in a loop, waiting for events to be queued and executing their handlers.</p>
<p>It is pretty much defined as:</p>
<div class="fragment"><div class="line"><span class="keywordflow">while</span> ((<a class="code" href="structevent.html">event</a> = <a class="code" href="group__sys__event.html#ga1a8c9a1fbf3ffc656a1ab53ab1585df3">event_wait</a>(queue))) {</div><div class="line">    <span class="keyword">event</span>-&gt;handler(<a class="code" href="structevent.html">event</a>);</div><div class="line">}</div></div><!-- fragment --><dl class="section pre"><dt>Precondition</dt><dd>The queue must have a waiter (i.e. it should have been claimed, or initialized using <a class="el" href="group__sys__event.html#ga609d4085b10b48c8b8725dab5b465896">event_queue_init</a>, <a class="el" href="group__sys__event.html#gad0b53659c2fbf312ff1a47782a42e0cb">event_queues_init</a>)</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">queue</td><td>event queue to process </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="event_8h_source.html#l00463">463</a> of file <a class="el" href="event_8h_source.html">event.h</a>.</p>

</div>
</div>
<a id="ga1d52cdf6e7593e240311a119ca076f7e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga1d52cdf6e7593e240311a119ca076f7e">&#9670;&nbsp;</a></span>event_loop_multi()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void event_loop_multi </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__sys__event.html#gab46c611438815de2e758821bfaab6d04">event_queue_t</a> *&#160;</td>
          <td class="paramname"><em>queues</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>n_queues</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Simple event loop with multiple queues. </p>
<p>This function will forever sit in a loop, waiting for events to be queued and executing their handlers. If more than one queue contains an event, the queue with the lowest index is chosen. Thus, a lower index in the <code>queues</code> array translates into a higher priority of the queue.</p>
<p>It is pretty much defined as:</p>
<div class="fragment"><div class="line"><span class="keywordflow">while</span> ((<a class="code" href="structevent.html">event</a> = <a class="code" href="group__sys__event.html#gaf549606f1a9059f0b1b0cef87ca6a95b">event_wait_multi</a>(queues, n_queues))) {</div><div class="line">    <span class="keyword">event</span>-&gt;handler(<a class="code" href="structevent.html">event</a>);</div><div class="line">}</div></div><!-- fragment --><dl class="section see"><dt>See also</dt><dd><a class="el" href="group__sys__event.html#gaf549606f1a9059f0b1b0cef87ca6a95b" title="Get next event from the given event queues, blocking. ">event_wait_multi</a></dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd>The queue must have a waiter (i.e. it should have been claimed, or initialized using <a class="el" href="group__sys__event.html#ga609d4085b10b48c8b8725dab5b465896">event_queue_init</a>, <a class="el" href="group__sys__event.html#gad0b53659c2fbf312ff1a47782a42e0cb">event_queues_init</a>)</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">queues</td><td>Event queues to process </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">n_queues</td><td>Number of queues passed with <code>queues</code> </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="event_8h_source.html#l00435">435</a> of file <a class="el" href="event_8h_source.html">event.h</a>.</p>

</div>
</div>
<a id="ga2053ce1facf709fffd024bee9e2383ba"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga2053ce1facf709fffd024bee9e2383ba">&#9670;&nbsp;</a></span>event_post()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void event_post </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__sys__event.html#gab46c611438815de2e758821bfaab6d04">event_queue_t</a> *&#160;</td>
          <td class="paramname"><em>queue</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__sys__event.html#gad0c066ffb009d3286186a124d37a0c2d">event_t</a> *&#160;</td>
          <td class="paramname"><em>event</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Queue an event. </p>
<p>The given event will be posted on the given <code>queue</code>. If the event is already queued when calling this function, the event will not be touched and remain in the previous position on the queue. So reposting an event while it is already on the queue will have no effect.</p>
<dl class="section pre"><dt>Precondition</dt><dd>queue should be initialized</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">queue</td><td>event queue to queue event in </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">event</td><td>event to queue in event queue </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga901462dc0093b6da40ec2fa787ac704f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga901462dc0093b6da40ec2fa787ac704f">&#9670;&nbsp;</a></span>event_queue_claim()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void event_queue_claim </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__sys__event.html#gab46c611438815de2e758821bfaab6d04">event_queue_t</a> *&#160;</td>
          <td class="paramname"><em>queue</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Bind an event queue to the calling thread. </p>
<p>This function must only be called once and only if the given queue is not yet bound to a thread.</p>
<dl class="section pre"><dt>Precondition</dt><dd>(queue-&gt;waiter == NULL)</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">queue</td><td>event queue object to bind to a thread </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="event_8h_source.html#l00248">248</a> of file <a class="el" href="event_8h_source.html">event.h</a>.</p>

</div>
</div>
<a id="ga609d4085b10b48c8b8725dab5b465896"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga609d4085b10b48c8b8725dab5b465896">&#9670;&nbsp;</a></span>event_queue_init()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void event_queue_init </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__sys__event.html#gab46c611438815de2e758821bfaab6d04">event_queue_t</a> *&#160;</td>
          <td class="paramname"><em>queue</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Initialize an event queue. </p>
<p>This will set the calling thread as owner of <code>queue</code>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">queue</td><td>event queue object to initialize </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="event_8h_source.html#l00187">187</a> of file <a class="el" href="event_8h_source.html">event.h</a>.</p>

</div>
</div>
<a id="ga7abb6e200225ac747dcccc071add6a24"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga7abb6e200225ac747dcccc071add6a24">&#9670;&nbsp;</a></span>event_queue_init_detached()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void event_queue_init_detached </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__sys__event.html#gab46c611438815de2e758821bfaab6d04">event_queue_t</a> *&#160;</td>
          <td class="paramname"><em>queue</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Initialize an event queue not binding it to a thread. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">queue</td><td>event queue object to initialize </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="event_8h_source.html#l00212">212</a> of file <a class="el" href="event_8h_source.html">event.h</a>.</p>

</div>
</div>
<a id="gaa3f1745747ef9c13022aa925eead68cd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaa3f1745747ef9c13022aa925eead68cd">&#9670;&nbsp;</a></span>event_queues_claim()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void event_queues_claim </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__sys__event.html#gab46c611438815de2e758821bfaab6d04">event_queue_t</a> *&#160;</td>
          <td class="paramname"><em>queues</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>n_queues</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Bind an array of event queues to the calling thread. </p>
<p>This function must only be called once and only if the given queue is not yet bound to a thread.</p>
<dl class="section pre"><dt>Precondition</dt><dd>(queues[i].waiter == NULL for i in {0, ..., n_queues - 1})</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">queues</td><td>event queue objects to bind to a thread </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">n_queues</td><td>number of queues in <code>queues</code> </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="event_8h_source.html#l00228">228</a> of file <a class="el" href="event_8h_source.html">event.h</a>.</p>

</div>
</div>
<a id="gad0b53659c2fbf312ff1a47782a42e0cb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gad0b53659c2fbf312ff1a47782a42e0cb">&#9670;&nbsp;</a></span>event_queues_init()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void event_queues_init </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__sys__event.html#gab46c611438815de2e758821bfaab6d04">event_queue_t</a> *&#160;</td>
          <td class="paramname"><em>queues</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>n_queues</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Initialize an array of event queues. </p>
<p>This will set the calling thread as owner of each queue in <code>queues</code>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">queues</td><td>event queue objects to initialize </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">n_queues</td><td>number of queues in <code>queues</code> </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="event_8h_source.html#l00169">169</a> of file <a class="el" href="event_8h_source.html">event.h</a>.</p>

</div>
</div>
<a id="gaba3402e5ea1b6f2682b7e4f6a8294150"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaba3402e5ea1b6f2682b7e4f6a8294150">&#9670;&nbsp;</a></span>event_queues_init_detached()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void event_queues_init_detached </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__sys__event.html#gab46c611438815de2e758821bfaab6d04">event_queue_t</a> *&#160;</td>
          <td class="paramname"><em>queues</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>n_queues</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Initialize an array of event queues not binding it to a thread. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">queues</td><td>event queue objects to initialize </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">n_queues</td><td>number of queues in <code>queues</code> </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="event_8h_source.html#l00198">198</a> of file <a class="el" href="event_8h_source.html">event.h</a>.</p>

</div>
</div>
<a id="gaa4393a26ef6c5cd25f7d07edfafb2acf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaa4393a26ef6c5cd25f7d07edfafb2acf">&#9670;&nbsp;</a></span>event_sync()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void event_sync </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__sys__event.html#gab46c611438815de2e758821bfaab6d04">event_queue_t</a> *&#160;</td>
          <td class="paramname"><em>queue</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Synchronize with the last event on the queue. </p>
<p>Blocks until the last event on the queue at the moment of calling this is processed.</p>
<dl class="section warning"><dt>Warning</dt><dd>May not be called from the event queue, as it would block forever. </dd>
<dd>
If the queue has no waiter, this will block until the queue is claimed. See <a class="el" href="group__sys__event.html#ga901462dc0093b6da40ec2fa787ac704f">event_queue_claim()</a></dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">queue</td><td>event queue to sync with</td></tr>
  </table>
  </dd>
</dl>
<p>Usage example: </p><div class="fragment"><div class="line"><a class="code" href="group__sys__event.html#ga2053ce1facf709fffd024bee9e2383ba">event_post</a>(queue, my_event);</div><div class="line"><span class="comment">// When event_sync() returns, my_event will have been processed.</span></div><div class="line"><a class="code" href="group__sys__event.html#gaa4393a26ef6c5cd25f7d07edfafb2acf">event_sync</a>(queue);</div></div><!-- fragment --> 
</div>
</div>
<a id="ga1a8c9a1fbf3ffc656a1ab53ab1585df3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga1a8c9a1fbf3ffc656a1ab53ab1585df3">&#9670;&nbsp;</a></span>event_wait()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="group__sys__event.html#gad0c066ffb009d3286186a124d37a0c2d">event_t</a>* event_wait </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__sys__event.html#gab46c611438815de2e758821bfaab6d04">event_queue_t</a> *&#160;</td>
          <td class="paramname"><em>queue</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get next event from event queue, blocking. </p>
<p>This function will block until an event becomes available.</p>
<p>In order to handle an event retrieved using this function, call event-&gt;handler(event).</p>
<dl class="section warning"><dt>Warning</dt><dd>There can only be a single waiter on a queue!</dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd>The queue must have a waiter (i.e. it should have been claimed, or initialized using <a class="el" href="group__sys__event.html#ga609d4085b10b48c8b8725dab5b465896">event_queue_init</a>, <a class="el" href="group__sys__event.html#gad0b53659c2fbf312ff1a47782a42e0cb">event_queues_init</a>)</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">queue</td><td>event queue to get event from</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>pointer to next event </dd></dl>

<p class="definition">Definition at line <a class="el" href="event_8h_source.html#l00354">354</a> of file <a class="el" href="event_8h_source.html">event.h</a>.</p>

</div>
</div>
<a id="gaf549606f1a9059f0b1b0cef87ca6a95b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaf549606f1a9059f0b1b0cef87ca6a95b">&#9670;&nbsp;</a></span>event_wait_multi()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__sys__event.html#gad0c066ffb009d3286186a124d37a0c2d">event_t</a>* event_wait_multi </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__sys__event.html#gab46c611438815de2e758821bfaab6d04">event_queue_t</a> *&#160;</td>
          <td class="paramname"><em>queues</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>n_queues</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get next event from the given event queues, blocking. </p>
<p>This function will block until an event becomes available. If more than one queue contains an event, the queue with the lowest index is chosen. Thus, a lower index in the <code>queues</code> array translates into a higher priority of the queue.</p>
<p>In order to handle an event retrieved using this function, call event-&gt;handler(event).</p>
<dl class="section warning"><dt>Warning</dt><dd>There can only be a single waiter on a queue!</dd></dl>
<dl class="section note"><dt>Note</dt><dd>This function <em>can</em> be suitable for having a single thread handling both real-time and non-real-time events. However, a real time event can be delayed for the whole duration a single non-real-time event takes (in addition to all other sources of latency). Thus, the slowest to handle non-real-time event must still execute fast enough to add an amount of latency (on top of other sources of latency) that is acceptable to the real-time event with the strictest requirements.</dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd>0 &lt; <code>n_queues</code> (expect blowing <code><a class="el" href="assert_8h.html#a3153a272f18d0f805028fce7e4337b53" title="abort the program if assertion is false ">assert()</a></code> otherwise) </dd>
<dd>
The queue must have a waiter (i.e. it should have been claimed, or initialized using <a class="el" href="group__sys__event.html#ga609d4085b10b48c8b8725dab5b465896">event_queue_init</a>, <a class="el" href="group__sys__event.html#gad0b53659c2fbf312ff1a47782a42e0cb">event_queues_init</a>)</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">queues</td><td>Array of event queues to get event from </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">n_queues</td><td>Number of event queues passed in <code>queues</code> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>pointer to next event </dd></dl>

</div>
</div>
<a id="gaf979ad68f1d4ef379de1f0da0644ff72"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaf979ad68f1d4ef379de1f0da0644ff72">&#9670;&nbsp;</a></span>event_wait_timeout()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__sys__event.html#gad0c066ffb009d3286186a124d37a0c2d">event_t</a>* event_wait_timeout </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__sys__event.html#gab46c611438815de2e758821bfaab6d04">event_queue_t</a> *&#160;</td>
          <td class="paramname"><em>queue</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>timeout</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get next event from event queue, blocking until timeout expires. </p>
<dl class="section pre"><dt>Precondition</dt><dd>The queue must have a waiter (i.e. it should have been claimed, or initialized using <a class="el" href="group__sys__event.html#ga609d4085b10b48c8b8725dab5b465896">event_queue_init</a>, <a class="el" href="group__sys__event.html#gad0b53659c2fbf312ff1a47782a42e0cb">event_queues_init</a>)</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">queue</td><td>queue to query for an event </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">timeout</td><td>maximum time to wait for an event to be posted in us</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>pointer to next event if event was taken from the queue </dd>
<dd>
NULL if timeout expired before an event was posted </dd></dl>

</div>
</div>
<a id="ga22551716e8df163590e16bf2cc5ff590"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga22551716e8df163590e16bf2cc5ff590">&#9670;&nbsp;</a></span>event_wait_timeout64()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__sys__event.html#gad0c066ffb009d3286186a124d37a0c2d">event_t</a>* event_wait_timeout64 </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__sys__event.html#gab46c611438815de2e758821bfaab6d04">event_queue_t</a> *&#160;</td>
          <td class="paramname"><em>queue</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>timeout</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get next event from event queue, blocking until timeout expires. </p>
<dl class="section pre"><dt>Precondition</dt><dd>The queue must have a waiter (i.e. it should have been claimed, or initialized using <a class="el" href="group__sys__event.html#ga609d4085b10b48c8b8725dab5b465896">event_queue_init</a>, <a class="el" href="group__sys__event.html#gad0b53659c2fbf312ff1a47782a42e0cb">event_queues_init</a>)</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">queue</td><td>queue to query for an event </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">timeout</td><td>maximum time to wait for an event to be posted in us</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>pointer to next event if event was taken from the queue </dd>
<dd>
NULL if timeout expired before an event was posted </dd></dl>

</div>
</div>
<a id="ga6bfc83e3b8a0fcc0ba88fc905412ca5f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga6bfc83e3b8a0fcc0ba88fc905412ca5f">&#9670;&nbsp;</a></span>event_wait_timeout_ztimer()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__sys__event.html#gad0c066ffb009d3286186a124d37a0c2d">event_t</a>* event_wait_timeout_ztimer </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__sys__event.html#gab46c611438815de2e758821bfaab6d04">event_queue_t</a> *&#160;</td>
          <td class="paramname"><em>queue</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__sys__ztimer.html#ga3639ce794c3bd80a6e9bbe88a7db4a88">ztimer_clock_t</a> *&#160;</td>
          <td class="paramname"><em>clock</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>timeout</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get next event from event queue, blocking until timeout expires. </p>
<p>This function is the same as <a class="el" href="group__sys__event.html#gaf979ad68f1d4ef379de1f0da0644ff72" title="Get next event from event queue, blocking until timeout expires. ">event_wait_timeout()</a> with the difference that it uses ztimer instead of xtimer as timer backend.</p>
<dl class="section pre"><dt>Precondition</dt><dd>The queue must have a waiter (i.e. it should have been claimed, or initialized using <a class="el" href="group__sys__event.html#ga609d4085b10b48c8b8725dab5b465896">event_queue_init</a>, <a class="el" href="group__sys__event.html#gad0b53659c2fbf312ff1a47782a42e0cb">event_queues_init</a>)</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">queue</td><td>queue to query for an event </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">clock</td><td>ztimer clock to use </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">timeout</td><td>maximum time to wait for an event, time unit depends on the used ztimer clock</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>pointer to next event if event was taken from the queue </dd>
<dd>
NULL if timeout expired before an event was posted </dd></dl>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
    <div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
        <ul>
            <li class="footer">Generated on Thu Mar 13 2025 10:38:34 by <a href="http://www.doxygen.org/index.html">
                       <img class="footer" src="doxygen.png" alt="doxygen"></a> 1.8.14</li>
        </ul>
    </div>
    <!-- Include all compiled plugins (below), or include individual files as needed -->
    <script src="bootstrap.min.js"></script>
    <script src="jquery.smartmenus.min.js"></script>
    <script src="jquery.smartmenus.bootstrap.min.js"></script>
    <script src="riot-doxy.js"></script>
  </body>
</html>
