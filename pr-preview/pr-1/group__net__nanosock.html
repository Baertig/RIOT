<!DOCTYPE html>
<html lang="en">
  <head>
    <link rel="icon" type="image/png" href="favicon.png">
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <!-- The above 3 meta tags *must* come first in the head; any other head content must come *after* these tags -->
    <title>nanoCoAP Sock</title>
    <!-- jQuery (necessary for Bootstrap's JavaScript plugins) -->
    <script src="jquery.min.js"></script>
    <script src="jquery.powertip.min.js"></script>
    <script src="jquery-ui.min.js"></script>
    <script src="jquery.scrollTo.min.js"></script>
    <script src="doxy-jquery.js"></script>
    <script src="dynsections.js"></script>
    <link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
  $(document).ready(initResizable);
/* @license-end */</script>
    <link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
    <!-- Bootstrap -->
    <link href="doxygen.css" rel="stylesheet">
    <link href="fonts.css" rel="stylesheet">
    <link href="bootstrap.min.css" rel="stylesheet">
    <link href="jquery.smartmenus.bootstrap.css" rel="stylesheet">
    <link href="riot.css" rel="stylesheet">
    <!-- HTML5 shim and Respond.js for IE8 support of HTML5 elements and media queries -->
    <!-- WARNING: Respond.js doesn't work if you view the page via file:// -->
    <!--[if lt IE 9]>
      <script src="https://oss.maxcdn.com/html5shiv/3.7.3/html5shiv.min.js"></script>
      <script src="https://oss.maxcdn.com/respond/1.4.2/respond.min.js"></script>
    <![endif]-->
        <script>
            function displaySR(){
            searchBox.Search();
            var rhtml=(document.getElementById('MSearchResults').contentWindow.document.body.innerHTML).replace(/href=\"\.\.\//g,'href="');
            document.getElementById('MSearchResultsWindow').style.display='none';
            document.getElementById('top').append(document.getElementById('MSearchSelectWindow'));
            document.getElementById('top').append(document.getElementById('MSearchResultsWindow'));
            document.getElementById('doc-content').innerHTML=rhtml;
            }
            function modSearch(){
            if(!searchBox.doxySearch){
                searchBox.doxySearch=searchBox.Search
                searchBox.Search= function(){this.doxySearch();
                var r=document.getElementById('MSearchResultsWindow');console.log(r.style);
                if(parseInt(r.style.left)<0)r.style.left=0;
                var x=document.getElementById('MSearchResults');
                if(x.scrollWidth>window.screen.width)x.style.width=window.screen.width-2+'px';
                var f=document.getElementById('riot-searchform');
                if(parseInt( r.style.top) < f.offsetTop+f.scrollHeight) r.style.top = f.offsetTop+f.scrollHeight+'px';}
            }
            }
        </script>
  </head>
  <body>
      <div id="top">
        <nav class="navbar navbar-inverse">
          <div class="container-fluid">
            <!-- Brand and toggle get grouped for better mobile display -->
            <div class="navbar-header">
              <button type="button" class="navbar-toggle collapsed" data-toggle="collapse" data-target="#navbar-collapse" aria-expanded="false">
                <span class="sr-only">Toggle navigation</span>
                <span class="icon-bar"></span>
                <span class="icon-bar"></span>
                <span class="icon-bar"></span>
              </button>
              <a class="navbar-brand" id="brand-logo" href="http://riot-os.org"><img height="40px" src="riot-logo.svg" /></a>
              <p class="navbar-text text-center visible-xs">Documentation</p>
            </div>
            <!-- Collect the nav links, forms, and other content for toggling -->
            <div class="collapse navbar-collapse" id="navbar-collapse">
              <p class="navbar-text navbar-left"><span id="projectbrief">The friendly Operating System for the Internet of Things</span></p>
              <ul id="riot-navlist" class="nav navbar-nav"></ul>
              <form id="riot-searchform" class="navbar-form navbar-left navbar-right" action="https://duckduckgo.com/" method="get">
                 <input type="hidden" name="sites" value="doc.riot-os.org"/>
                 <input type="hidden" name="kt" value="h"/>
                 <div class="form-group">
                   <div id="MSearchBox" class="MSearchBoxActive">
                     <div class="input-group">
                       <div class="input-group-addon">
                         <span id="MSearchSelect" class="glyphicon glyphicon-search" aria-hidden="true" onmouseover="return searchBox.OnSearchSelectShow()" onmouseout="return searchBox.OnSearchSelectHide()"></span>
                       </div>
                       <input class="form-control" type="text" name="q" id="MSearchField" placeholder="Search" accesskey="S" onfocus="searchBox.OnSearchFieldFocus(true)" onblur="searchBox.OnSearchFieldFocus(false)" onkeyup="searchBox.OnSearchFieldChange(event); modSearch();">
                       <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()">
                         <span id="search-reset" class="glyphicon glyphicon-remove-circle" aria-hidden="true"></span>
                       </a>
                     </div>
                   </div>
                 </div>
              </form>
            </div><!-- /.navbar-collapse -->
          </div><!-- /.container-fluid -->
        </nav>
      </div>
<!-- Generated by Doxygen 1.8.14 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(document).ready(function(){initNavTree('group__net__nanosock.html','');});
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#files">Files</a> &#124;
<a href="#nested-classes">Data Structures</a> &#124;
<a href="#define-members">Macros</a> &#124;
<a href="#enum-members">Enumerations</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">nanoCoAP Sock<div class="ingroups"><a class="el" href="group__net.html">Networking</a></div></div>  </div>
</div><!--header-->
<div class="contents">

<p>Synchronous sock based messaging with nanocoap.  
<a href="#details">More...</a></p>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<p>Synchronous sock based messaging with nanocoap. </p>
<p>nanocoap sock uses the nanocoap CoAP library to provide a synchronous interface to RIOT's sock networking API to read and write CoAP messages. For a server, nanocoap sock accepts a list of resource paths with callbacks for writing the response. For a client, nanocoap sock provides a function to send a request and waits for the server response. nanocoap sock uses nanocoap's Buffer API to write message options.</p>
<p>See the nanocoap_server example, which is built on the <code><a class="el" href="group__net__nanosock.html#gaa8dc99f3f6c9b49ce8a4da7f15260766" title="Start a nanocoap server instance. ">nanocoap_server()</a></code> function. A server must define CoAP resources for which it responds.</p>
<p>Each <a class="el" href="structcoap__resource__t.html">coap_resource_t</a> is added to the XFA with <a class="el" href="group__net__nanocoap.html#gaf3b7751818e477148bf210c79683ae0c" title="CoAP XFA resource entry. ">NANOCOAP_RESOURCE(name)</a> followed by the declaration of the CoAP resource, e.g.:</p>
<div class="fragment"><div class="line"><a class="code" href="group__net__nanocoap.html#gaf3b7751818e477148bf210c79683ae0c">NANOCOAP_RESOURCE</a>(board) {</div><div class="line">  .path = <span class="stringliteral">&quot;/board&quot;</span>, .methods = COAP_GET, .handler = _board_handler,</div><div class="line">};</div></div><!-- fragment --><p>nanocoap itself provides the COAP_WELL_KNOWN_CORE_DEFAULT_HANDLER entry for <code>/.well-known/core</code>.</p>
<p>To use the CoAP resource XFA, enable the <code>nanocoap_resources</code> module.</p>
<p>For each resource, you must implement a <a class="el" href="group__net__nanocoap.html#ga8b44fbd36baf301f3bf531d1fcfadf9f" title="Resource handler type. ">coap_handler_t</a> handler function. nanocoap provides functions to help implement the handler. If the handler is called via <a class="el" href="group__net__nanosock.html#gaa8dc99f3f6c9b49ce8a4da7f15260766" title="Start a nanocoap server instance. ">nanocoap_server()</a>, the response buffer provided to the handler reuses the buffer for the request. So, your handler must read the request thoroughly before writing the response.</p>
<p>To read the request, use the functions in the <em>Header</em> and <em>Options Read</em> sections of the <a href="group__net__nanocoap.html">nanocoap</a> documentation. If the pkt <em>payload_len</em> attribute is a positive value, start to read it at the <em>payload</em> pointer attribute.</p>
<p>If a response does not require specific CoAP options, use <a class="el" href="group__net__nanocoap.html#gac430f1177b2576b8555bd133a2fc0835" title="Create CoAP reply (convenience function) ">coap_reply_simple()</a>. If there is a payload, it writes a Content-Format option with the provided value.</p>
<p>For a response with additional CoAP options, start by calling <a class="el" href="group__net__nanocoap.html#ga38b2f76446070e80183a13e6b33d7cff" title="Build reply to CoAP request. ">coap_build_reply()</a>. Then use the Buffer API to write the rest of the response. See the instructions in the section <em>Write Options and Payload</em> below.</p>
<p>Follow the instructions in the section <em>Write Options and Payload</em> below.</p>
<p>To send the message and await the response, see <a class="el" href="group__net__nanosock.html#ga829870b2ff3a51a4a908f86ad98303c2" title="Simple synchronous CoAP request. ">nanocoap_sock_request()</a> as well as <a class="el" href="group__net__nanosock.html#gab66959ad47fd44afa1ebdf9d44d0b394" title="Simple synchronous CoAP (confirmable) GET. ">nanocoap_sock_get()</a>, which additionally copies the response payload to a user supplied buffer. Finally, read the response as described above in the server <em>Handler functions</em> section for reading a request.</p>
<p>For both server responses and client requests, CoAP uses an Option mechanism to encode message metadata that is not required for each message. For example, the resource URI path is required only for a request, and is encoded as the Uri-Path option.</p>
<p>nanocoap sock uses the nanocoap Buffer API for options. The caller must provide the last option number written as well as the buffer position. The caller is primarily responsible for tracking and managing the space remaining in the buffer.</p>
<p>Before starting, ensure the CoAP header has been initialized with <a class="el" href="group__net__nanocoap.html#gaf0291091ff11f20539fd6835bef393fc" title="Builds a CoAP header. ">coap_build_hdr()</a>. For a response, <a class="el" href="group__net__nanocoap.html#ga38b2f76446070e80183a13e6b33d7cff" title="Build reply to CoAP request. ">coap_build_reply()</a> includes a call to <a class="el" href="group__net__nanocoap.html#gaf0291091ff11f20539fd6835bef393fc" title="Builds a CoAP header. ">coap_build_hdr()</a>. Use the returned length to track the next position in the buffer to write and remaining length.</p>
<p>Next, use the functions in the <em>Options Write Buffer API</em> section of <a href="group__net__nanocoap.html">nanocoap</a> to write each option. These functions require the position in the buffer to start writing, and return the number of bytes written. Options <em>must</em> be written in order by option number (see "CoAP option numbers" in <a href="group__net__coap.html">CoAP defines</a>).</p>
<dl class="section note"><dt>Note</dt><dd>You must ensure the buffer has enough space remaining to write each option. The API does not verify the safety of writing an option.</dd></dl>
<p>If there is a payload, append a payload marker (0xFF). Then write the payload to within the maximum length remaining in the buffer.</p>
<h1><a class="anchor" id="autotoc_md2084"></a>
Create a Block-wise Response (Block2)</h1>
<p>Block-wise is a CoAP extension (RFC 7959) to divide a large payload across multiple physical packets. This section describes how to write a block-wise payload for a response, and is known as Block2. (Block1 is for a block-wise payload in a request.) See _riot_board_handler() in the nanocoap_server example for an example handler implementation.</p>
<p>Start with <a class="el" href="group__net__nanocoap.html#ga847153f464dc80f7f015d3ccbceb71c4" title="Initialize a block2 slicer struct for writing the payload. ">coap_block2_init()</a> to read the client request and initialize a coap_slicer_t struct with the size and location for this slice of the overall payload. Then write the block2 option in the response with <a class="el" href="group__net__nanocoap.html#ga5bfad86a61eb99c3727ae624c6e2594f" title="Insert block2 option into buffer. ">coap_opt_put_block2()</a>. Use <a class="el" href="group__net__nanocoap.html#ga9a73753ea88ce8355311ff9a2f5e4dc3">coap_get_response_hdr_len</a> to get the length of the response header: This will be the offset in the buffer where you should start adding options. The Block2 option includes an indicator ("more") that a slice completes the overall payload transfer. You may not know the value for <em>more</em> at this point, but you must initialize the space in the packet for the option before writing the payload. The option is rewritten later.</p>
<p>Next, use the coap_blockwise_put_xxx() functions to write the payload content. These functions use the <a class="el" href="structcoap__block__slicer__t.html" title="Blockwise transfer helper struct. ">coap_block_slicer_t</a> to enable or disable actually writing the content, depending on the current position within the overall payload transfer.</p>
<p>Finally, use the convenience function <a class="el" href="group__net__nanocoap.html#ga6ae8281567032734a24ef7739f65c2b4" title="Build reply to CoAP block2 request. ">coap_block2_build_reply()</a>, which finalizes the packet and calls <a class="el" href="group__net__nanocoap.html#ga5d839eb2b07582ff50afb988d2e6e8c1" title="Finish a block2 response. ">coap_block2_finish()</a> internally to update the block2 option. </p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="files"></a>
Files</h2></td></tr>
<tr class="memitem:fs_8h"><td class="memItemLeft" align="right" valign="top">file &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="fs_8h.html">fs.h</a></td></tr>
<tr class="memdesc:fs_8h"><td class="mdescLeft">&#160;</td><td class="mdescRight">nanoCoAP virtual file system <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:link__format_8h"><td class="memItemLeft" align="right" valign="top">file &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="link__format_8h.html">link_format.h</a></td></tr>
<tr class="memdesc:link__format_8h"><td class="mdescLeft">&#160;</td><td class="mdescRight">NanoCoAP Link Format helper functions. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:nanocoap__sock_8h"><td class="memItemLeft" align="right" valign="top">file &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="nanocoap__sock_8h.html">nanocoap_sock.h</a></td></tr>
<tr class="memdesc:nanocoap__sock_8h"><td class="mdescLeft">&#160;</td><td class="mdescRight">nanocoap high-level API <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:nanocoap__vfs_8h"><td class="memItemLeft" align="right" valign="top">file &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="nanocoap__vfs_8h.html">nanocoap_vfs.h</a></td></tr>
<tr class="memdesc:nanocoap__vfs_8h"><td class="mdescLeft">&#160;</td><td class="mdescRight">VFS NanoCoAP helper functions. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Data Structures</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structnanocoap__sock__t.html">nanocoap_sock_t</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">NanoCoAP socket struct.  <a href="structnanocoap__sock__t.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structcoap__block__request__t.html">coap_block_request_t</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Blockwise request helper struct.  <a href="structcoap__block__request__t.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structnanocoap__server__response__ctx__t.html">nanocoap_server_response_ctx_t</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Context from CoAP request for separate response.  <a href="structnanocoap__server__response__ctx__t.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="define-members"></a>
Macros</h2></td></tr>
<tr class="memitem:ga1e6615cea509ba15c236888dc1d080a3"><td class="memItemLeft" align="right" valign="top"><a id="ga1e6615cea509ba15c236888dc1d080a3"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__net__nanosock.html#ga1e6615cea509ba15c236888dc1d080a3">CONFIG_NANOCOAP_SOCK_DTLS_TAG</a>&#160;&#160;&#160;(0xc0ab)</td></tr>
<tr class="memdesc:ga1e6615cea509ba15c236888dc1d080a3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Credman tag used for NanoCoAP Tag together with the credential type (PSK) needs to be unique. <br /></td></tr>
<tr class="separator:ga1e6615cea509ba15c236888dc1d080a3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1288882055b3987361fa829c8fc5a774"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__net__nanosock.html#ga1288882055b3987361fa829c8fc5a774">CONFIG_NANOCOAP_SERVER_BUF_SIZE</a></td></tr>
<tr class="memdesc:ga1288882055b3987361fa829c8fc5a774"><td class="mdescLeft">&#160;</td><td class="mdescRight">CoAP server work buf size Used both for RX and TX, needs to hold payload block + header.  <a href="#ga1288882055b3987361fa829c8fc5a774">More...</a><br /></td></tr>
<tr class="separator:ga1288882055b3987361fa829c8fc5a774"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga293861b7a3fe8f22fa889dc1760362bb"><td class="memItemLeft" align="right" valign="top"><a id="ga293861b7a3fe8f22fa889dc1760362bb"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__net__nanosock.html#ga293861b7a3fe8f22fa889dc1760362bb">CONFIG_NANOCOAP_SERVER_STACK_SIZE</a>&#160;&#160;&#160;<a class="el" href="native_2include_2cpu__conf_8h.html#a713ebddc00581f4d415095cdbfd8791f">THREAD_STACKSIZE_DEFAULT</a></td></tr>
<tr class="memdesc:ga293861b7a3fe8f22fa889dc1760362bb"><td class="mdescLeft">&#160;</td><td class="mdescRight">CoAP server thread stack size. <br /></td></tr>
<tr class="separator:ga293861b7a3fe8f22fa889dc1760362bb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaedbd07b2745e261ec745b46a6549c34d"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__net__nanosock.html#gaedbd07b2745e261ec745b46a6549c34d">CONFIG_NANOCOAP_SOCK_BLOCK_TOKEN</a>&#160;&#160;&#160;(0)</td></tr>
<tr class="memdesc:gaedbd07b2745e261ec745b46a6549c34d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Include a random token with block-wise transfers.  <a href="#gaedbd07b2745e261ec745b46a6549c34d">More...</a><br /></td></tr>
<tr class="separator:gaedbd07b2745e261ec745b46a6549c34d"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="enum-members"></a>
Enumerations</h2></td></tr>
<tr class="memitem:gae3e4fc820564121c86199921270c0275"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__net__nanosock.html#gae3e4fc820564121c86199921270c0275">nanocoap_socket_type_t</a> { <a class="el" href="group__net__nanosock.html#ggae3e4fc820564121c86199921270c0275a2ebef91b4b721d48214df2d32ec4cae7">COAP_SOCKET_TYPE_UDP</a>, 
<a class="el" href="group__net__nanosock.html#ggae3e4fc820564121c86199921270c0275ac0403908f2afb92fa49f3e70e6640b38">COAP_SOCKET_TYPE_DTLS</a>
 }</td></tr>
<tr class="memdesc:gae3e4fc820564121c86199921270c0275"><td class="mdescLeft">&#160;</td><td class="mdescRight">NanoCoAP socket types.  <a href="group__net__nanosock.html#gae3e4fc820564121c86199921270c0275">More...</a><br /></td></tr>
<tr class="separator:gae3e4fc820564121c86199921270c0275"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:ga531691c36ce014e57840be2a8fc76b39"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__net__nanosock.html#ga531691c36ce014e57840be2a8fc76b39">nanocoap_server_prepare_separate</a> (<a class="el" href="structnanocoap__server__response__ctx__t.html">nanocoap_server_response_ctx_t</a> *ctx, <a class="el" href="structcoap__pkt__t.html">coap_pkt_t</a> *pkt, const <a class="el" href="group__net__nanocoap.html#gaedec79122f8968eb8b04e9e9360b392a">coap_request_ctx_t</a> *req)</td></tr>
<tr class="memdesc:ga531691c36ce014e57840be2a8fc76b39"><td class="mdescLeft">&#160;</td><td class="mdescRight">Prepare the context for a separate response.  <a href="#ga531691c36ce014e57840be2a8fc76b39">More...</a><br /></td></tr>
<tr class="separator:ga531691c36ce014e57840be2a8fc76b39"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae3dab379eeb1120072ce64392874afca"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__net__nanosock.html#gae3dab379eeb1120072ce64392874afca">nanocoap_server_is_remote_in_response_ctx</a> (const <a class="el" href="structnanocoap__server__response__ctx__t.html">nanocoap_server_response_ctx_t</a> *ctx, const <a class="el" href="group__net__nanocoap.html#gaedec79122f8968eb8b04e9e9360b392a">coap_request_ctx_t</a> *req)</td></tr>
<tr class="memdesc:gae3dab379eeb1120072ce64392874afca"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if a given separate response context was prepared for the remote endpoint of a given request.  <a href="#gae3dab379eeb1120072ce64392874afca">More...</a><br /></td></tr>
<tr class="separator:gae3dab379eeb1120072ce64392874afca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaabc7cae6d9a18f2a2360d592542d67a7"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__net__nanosock.html#gaabc7cae6d9a18f2a2360d592542d67a7">nanocoap_server_send_separate</a> (const <a class="el" href="structnanocoap__server__response__ctx__t.html">nanocoap_server_response_ctx_t</a> *ctx, unsigned code, unsigned type, const void *payload, size_t len)</td></tr>
<tr class="memdesc:gaabc7cae6d9a18f2a2360d592542d67a7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Build and send a separate response to a CoAP request.  <a href="#gaabc7cae6d9a18f2a2360d592542d67a7">More...</a><br /></td></tr>
<tr class="separator:gaabc7cae6d9a18f2a2360d592542d67a7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga01062e5dfc134d6be0e205a749c2e590"><td class="memItemLeft" align="right" valign="top">ssize_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__net__nanosock.html#ga01062e5dfc134d6be0e205a749c2e590">nanocoap_server_build_separate</a> (const <a class="el" href="structnanocoap__server__response__ctx__t.html">nanocoap_server_response_ctx_t</a> *ctx, void *buf, size_t buf_len, unsigned code, unsigned type, uint16_t msg_id)</td></tr>
<tr class="memdesc:ga01062e5dfc134d6be0e205a749c2e590"><td class="mdescLeft">&#160;</td><td class="mdescRight">Build a separate response header to a CoAP request.  <a href="#ga01062e5dfc134d6be0e205a749c2e590">More...</a><br /></td></tr>
<tr class="separator:ga01062e5dfc134d6be0e205a749c2e590"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga87500394e8015fef76ab00bf9497dc28"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__net__nanosock.html#ga87500394e8015fef76ab00bf9497dc28">nanocoap_server_sendv_separate</a> (const <a class="el" href="structnanocoap__server__response__ctx__t.html">nanocoap_server_response_ctx_t</a> *ctx, const <a class="el" href="group__sys__iolist.html#gaa17f91ef26edec149cd806d8457aa3a0">iolist_t</a> *reply)</td></tr>
<tr class="memdesc:ga87500394e8015fef76ab00bf9497dc28"><td class="mdescLeft">&#160;</td><td class="mdescRight">Send an already build separate response.  <a href="#ga87500394e8015fef76ab00bf9497dc28">More...</a><br /></td></tr>
<tr class="separator:ga87500394e8015fef76ab00bf9497dc28"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0acf5a5e9dc95e1d47cf199ec5f792cc"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__net__nanosock.html#ga0acf5a5e9dc95e1d47cf199ec5f792cc">nanocoap_register_observer</a> (const <a class="el" href="group__net__nanocoap.html#gaedec79122f8968eb8b04e9e9360b392a">coap_request_ctx_t</a> *req_ctx, <a class="el" href="structcoap__pkt__t.html">coap_pkt_t</a> *req_pkt)</td></tr>
<tr class="memdesc:ga0acf5a5e9dc95e1d47cf199ec5f792cc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Register an observer.  <a href="#ga0acf5a5e9dc95e1d47cf199ec5f792cc">More...</a><br /></td></tr>
<tr class="separator:ga0acf5a5e9dc95e1d47cf199ec5f792cc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab2874f2dab04fafa03d79cedf7e54ae3"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__net__nanosock.html#gab2874f2dab04fafa03d79cedf7e54ae3">nanocoap_unregister_observer</a> (const <a class="el" href="group__net__nanocoap.html#gaedec79122f8968eb8b04e9e9360b392a">coap_request_ctx_t</a> *req_ctx, const <a class="el" href="structcoap__pkt__t.html">coap_pkt_t</a> *req_pkt)</td></tr>
<tr class="memdesc:gab2874f2dab04fafa03d79cedf7e54ae3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Unregister an observer.  <a href="#gab2874f2dab04fafa03d79cedf7e54ae3">More...</a><br /></td></tr>
<tr class="separator:gab2874f2dab04fafa03d79cedf7e54ae3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga27d7cd4c949580379d9d84f5cbfd7eeb"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__net__nanosock.html#ga27d7cd4c949580379d9d84f5cbfd7eeb">nanocoap_unregister_observer_due_to_reset</a> (const <a class="el" href="group__net__sock__udp.html#gaedc829c7973d7870c1ec078f9ffd45a1">sock_udp_ep_t</a> *ep, uint16_t msg_id)</td></tr>
<tr class="memdesc:ga27d7cd4c949580379d9d84f5cbfd7eeb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Unregister a stale observation due to a reset message received.  <a href="#ga27d7cd4c949580379d9d84f5cbfd7eeb">More...</a><br /></td></tr>
<tr class="separator:ga27d7cd4c949580379d9d84f5cbfd7eeb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1b00144ef395648226920cea3d714414"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__net__nanosock.html#ga1b00144ef395648226920cea3d714414">nanocoap_notify_observers</a> (const <a class="el" href="structcoap__resource__t.html">coap_resource_t</a> *res, const <a class="el" href="group__sys__iolist.html#gaa17f91ef26edec149cd806d8457aa3a0">iolist_t</a> *iol)</td></tr>
<tr class="memdesc:ga1b00144ef395648226920cea3d714414"><td class="mdescLeft">&#160;</td><td class="mdescRight">Notify all currently registered observers of the given resource.  <a href="#ga1b00144ef395648226920cea3d714414">More...</a><br /></td></tr>
<tr class="separator:ga1b00144ef395648226920cea3d714414"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga53869b20a9ab8e7a39d6781dd69f773d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__net__nanosock.html#ga53869b20a9ab8e7a39d6781dd69f773d">nanocoap_notify_observers_simple</a> (const <a class="el" href="structcoap__resource__t.html">coap_resource_t</a> *res, uint32_t obs, const void *payload, size_t payload_len)</td></tr>
<tr class="memdesc:ga53869b20a9ab8e7a39d6781dd69f773d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Build and send notification to observers registered to a specific resource.  <a href="#ga53869b20a9ab8e7a39d6781dd69f773d">More...</a><br /></td></tr>
<tr class="separator:ga53869b20a9ab8e7a39d6781dd69f773d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa327f4e1e000925a6e1d06b5009d05cf"><td class="memItemLeft" align="right" valign="top">static uint16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__net__nanosock.html#gaa327f4e1e000925a6e1d06b5009d05cf">nanocoap_sock_next_msg_id</a> (<a class="el" href="structnanocoap__sock__t.html">nanocoap_sock_t</a> *sock)</td></tr>
<tr class="memdesc:gaa327f4e1e000925a6e1d06b5009d05cf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get next consecutive message ID for use when building a new CoAP request.  <a href="#gaa327f4e1e000925a6e1d06b5009d05cf">More...</a><br /></td></tr>
<tr class="separator:gaa327f4e1e000925a6e1d06b5009d05cf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa8dc99f3f6c9b49ce8a4da7f15260766"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__net__nanosock.html#gaa8dc99f3f6c9b49ce8a4da7f15260766">nanocoap_server</a> (<a class="el" href="group__net__sock__udp.html#gaedc829c7973d7870c1ec078f9ffd45a1">sock_udp_ep_t</a> *local, uint8_t *buf, size_t bufsize)</td></tr>
<tr class="memdesc:gaa8dc99f3f6c9b49ce8a4da7f15260766"><td class="mdescLeft">&#160;</td><td class="mdescRight">Start a nanocoap server instance.  <a href="#gaa8dc99f3f6c9b49ce8a4da7f15260766">More...</a><br /></td></tr>
<tr class="separator:gaa8dc99f3f6c9b49ce8a4da7f15260766"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga67689e162bf20649cca78957f4869dba"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__core__sched.html#ga8375139300d7cbf23bd8bd89ddddbe84">kernel_pid_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__net__nanosock.html#ga67689e162bf20649cca78957f4869dba">nanocoap_server_start</a> (const <a class="el" href="group__net__sock__udp.html#gaedc829c7973d7870c1ec078f9ffd45a1">sock_udp_ep_t</a> *local)</td></tr>
<tr class="memdesc:ga67689e162bf20649cca78957f4869dba"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create and start the nanoCoAP server thread.  <a href="#ga67689e162bf20649cca78957f4869dba">More...</a><br /></td></tr>
<tr class="separator:ga67689e162bf20649cca78957f4869dba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gacec46e67451d121c6aa3c188b7734363"><td class="memItemLeft" align="right" valign="top">static int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__net__nanosock.html#gacec46e67451d121c6aa3c188b7734363">nanocoap_sock_connect</a> (<a class="el" href="structnanocoap__sock__t.html">nanocoap_sock_t</a> *sock, const <a class="el" href="group__net__sock__udp.html#gaedc829c7973d7870c1ec078f9ffd45a1">sock_udp_ep_t</a> *local, const <a class="el" href="group__net__sock__udp.html#gaedc829c7973d7870c1ec078f9ffd45a1">sock_udp_ep_t</a> *remote)</td></tr>
<tr class="memdesc:gacec46e67451d121c6aa3c188b7734363"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a CoAP client socket.  <a href="#gacec46e67451d121c6aa3c188b7734363">More...</a><br /></td></tr>
<tr class="separator:gacec46e67451d121c6aa3c188b7734363"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9027d8c301d6587c4b82e7332ae46b55"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__net__nanosock.html#ga9027d8c301d6587c4b82e7332ae46b55">nanocoap_sock_dtls_connect</a> (<a class="el" href="structnanocoap__sock__t.html">nanocoap_sock_t</a> *sock, <a class="el" href="group__net__sock__udp.html#gaedc829c7973d7870c1ec078f9ffd45a1">sock_udp_ep_t</a> *local, const <a class="el" href="group__net__sock__udp.html#gaedc829c7973d7870c1ec078f9ffd45a1">sock_udp_ep_t</a> *remote, <a class="el" href="group__net__credman.html#ga89fc115fe10d879da7faf1c0d0f901a7">credman_tag_t</a> tag)</td></tr>
<tr class="memdesc:ga9027d8c301d6587c4b82e7332ae46b55"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a DTLS secured CoAP client socket.  <a href="#ga9027d8c301d6587c4b82e7332ae46b55">More...</a><br /></td></tr>
<tr class="separator:ga9027d8c301d6587c4b82e7332ae46b55"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga282ddfd4238b746dd20d4cfe4df4c244"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__net__nanosock.html#ga282ddfd4238b746dd20d4cfe4df4c244">nanocoap_sock_url_connect</a> (const char *url, <a class="el" href="structnanocoap__sock__t.html">nanocoap_sock_t</a> *sock)</td></tr>
<tr class="memdesc:ga282ddfd4238b746dd20d4cfe4df4c244"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a CoAP client socket by URL.  <a href="#ga282ddfd4238b746dd20d4cfe4df4c244">More...</a><br /></td></tr>
<tr class="separator:ga282ddfd4238b746dd20d4cfe4df4c244"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae9376e608769729b1668ccc349447082"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__net__nanosock.html#gae9376e608769729b1668ccc349447082">nanocoap_sock_close</a> (<a class="el" href="structnanocoap__sock__t.html">nanocoap_sock_t</a> *sock)</td></tr>
<tr class="memdesc:gae9376e608769729b1668ccc349447082"><td class="mdescLeft">&#160;</td><td class="mdescRight">Close a CoAP client socket.  <a href="#gae9376e608769729b1668ccc349447082">More...</a><br /></td></tr>
<tr class="separator:gae9376e608769729b1668ccc349447082"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab66959ad47fd44afa1ebdf9d44d0b394"><td class="memItemLeft" align="right" valign="top">ssize_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__net__nanosock.html#gab66959ad47fd44afa1ebdf9d44d0b394">nanocoap_sock_get</a> (<a class="el" href="structnanocoap__sock__t.html">nanocoap_sock_t</a> *sock, const char *path, void *buf, size_t len)</td></tr>
<tr class="memdesc:gab66959ad47fd44afa1ebdf9d44d0b394"><td class="mdescLeft">&#160;</td><td class="mdescRight">Simple synchronous CoAP (confirmable) GET.  <a href="#gab66959ad47fd44afa1ebdf9d44d0b394">More...</a><br /></td></tr>
<tr class="separator:gab66959ad47fd44afa1ebdf9d44d0b394"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga136631ddd8ef9ed9ac4561a453489269"><td class="memItemLeft" align="right" valign="top">ssize_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__net__nanosock.html#ga136631ddd8ef9ed9ac4561a453489269">nanocoap_sock_get_non</a> (<a class="el" href="structnanocoap__sock__t.html">nanocoap_sock_t</a> *sock, const char *path, void *response, size_t len_max)</td></tr>
<tr class="memdesc:ga136631ddd8ef9ed9ac4561a453489269"><td class="mdescLeft">&#160;</td><td class="mdescRight">Simple non-confirmable GET.  <a href="#ga136631ddd8ef9ed9ac4561a453489269">More...</a><br /></td></tr>
<tr class="separator:ga136631ddd8ef9ed9ac4561a453489269"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga25e146569f51b488e140eac77710d67f"><td class="memItemLeft" align="right" valign="top">ssize_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__net__nanosock.html#ga25e146569f51b488e140eac77710d67f">nanocoap_sock_put</a> (<a class="el" href="structnanocoap__sock__t.html">nanocoap_sock_t</a> *sock, const char *path, const void *request, size_t len, void *response, size_t len_max)</td></tr>
<tr class="memdesc:ga25e146569f51b488e140eac77710d67f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Simple synchronous CoAP (confirmable) PUT.  <a href="#ga25e146569f51b488e140eac77710d67f">More...</a><br /></td></tr>
<tr class="separator:ga25e146569f51b488e140eac77710d67f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0ce8f6d164e274035ec452cadfa6f014"><td class="memItemLeft" align="right" valign="top">ssize_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__net__nanosock.html#ga0ce8f6d164e274035ec452cadfa6f014">nanocoap_sock_put_non</a> (<a class="el" href="structnanocoap__sock__t.html">nanocoap_sock_t</a> *sock, const char *path, const void *request, size_t len, void *response, size_t len_max)</td></tr>
<tr class="memdesc:ga0ce8f6d164e274035ec452cadfa6f014"><td class="mdescLeft">&#160;</td><td class="mdescRight">Simple non-confirmable PUT.  <a href="#ga0ce8f6d164e274035ec452cadfa6f014">More...</a><br /></td></tr>
<tr class="separator:ga0ce8f6d164e274035ec452cadfa6f014"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gacb63bde357408c45b01de0d9995aa5df"><td class="memItemLeft" align="right" valign="top">ssize_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__net__nanosock.html#gacb63bde357408c45b01de0d9995aa5df">nanocoap_sock_put_url</a> (const char *url, const void *request, size_t len, void *response, size_t len_max)</td></tr>
<tr class="memdesc:gacb63bde357408c45b01de0d9995aa5df"><td class="mdescLeft">&#160;</td><td class="mdescRight">Simple synchronous CoAP (confirmable) PUT to URL.  <a href="#gacb63bde357408c45b01de0d9995aa5df">More...</a><br /></td></tr>
<tr class="separator:gacb63bde357408c45b01de0d9995aa5df"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa3cc19122ffcf70a4a59653118808e7a"><td class="memItemLeft" align="right" valign="top">ssize_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__net__nanosock.html#gaa3cc19122ffcf70a4a59653118808e7a">nanocoap_sock_post</a> (<a class="el" href="structnanocoap__sock__t.html">nanocoap_sock_t</a> *sock, const char *path, const void *request, size_t len, void *response, size_t len_max)</td></tr>
<tr class="memdesc:gaa3cc19122ffcf70a4a59653118808e7a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Simple synchronous CoAP (confirmable) POST.  <a href="#gaa3cc19122ffcf70a4a59653118808e7a">More...</a><br /></td></tr>
<tr class="separator:gaa3cc19122ffcf70a4a59653118808e7a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaab1cde1ee8660b189691bc7ea76e5d8c"><td class="memItemLeft" align="right" valign="top">ssize_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__net__nanosock.html#gaab1cde1ee8660b189691bc7ea76e5d8c">nanocoap_sock_post_non</a> (<a class="el" href="structnanocoap__sock__t.html">nanocoap_sock_t</a> *sock, const char *path, const void *request, size_t len, void *response, size_t len_max)</td></tr>
<tr class="memdesc:gaab1cde1ee8660b189691bc7ea76e5d8c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Simple non-confirmable POST.  <a href="#gaab1cde1ee8660b189691bc7ea76e5d8c">More...</a><br /></td></tr>
<tr class="separator:gaab1cde1ee8660b189691bc7ea76e5d8c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3512df1cdfdf348901e4fa92508305e2"><td class="memItemLeft" align="right" valign="top">ssize_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__net__nanosock.html#ga3512df1cdfdf348901e4fa92508305e2">nanocoap_sock_post_url</a> (const char *url, const void *request, size_t len, void *response, size_t len_max)</td></tr>
<tr class="memdesc:ga3512df1cdfdf348901e4fa92508305e2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Simple synchronous CoAP (confirmable) POST to URL.  <a href="#ga3512df1cdfdf348901e4fa92508305e2">More...</a><br /></td></tr>
<tr class="separator:ga3512df1cdfdf348901e4fa92508305e2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga88034d74b68f56ff5c84514cba774ead"><td class="memItemLeft" align="right" valign="top">ssize_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__net__nanosock.html#ga88034d74b68f56ff5c84514cba774ead">nanocoap_sock_fetch</a> (<a class="el" href="structnanocoap__sock__t.html">nanocoap_sock_t</a> *sock, const char *path, const void *request, size_t len, void *response, size_t len_max)</td></tr>
<tr class="memdesc:ga88034d74b68f56ff5c84514cba774ead"><td class="mdescLeft">&#160;</td><td class="mdescRight">Simple synchronous CoAP (confirmable) FETCH (<a href="https://datatracker.ietf.org/doc/html/rfc8132">RFC 8132</a>)  <a href="#ga88034d74b68f56ff5c84514cba774ead">More...</a><br /></td></tr>
<tr class="separator:ga88034d74b68f56ff5c84514cba774ead"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga94a4c60055d1958fe3ecb3f2ff3b5056"><td class="memItemLeft" align="right" valign="top">ssize_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__net__nanosock.html#ga94a4c60055d1958fe3ecb3f2ff3b5056">nanocoap_sock_fetch_non</a> (<a class="el" href="structnanocoap__sock__t.html">nanocoap_sock_t</a> *sock, const char *path, const void *request, size_t len, void *response, size_t len_max)</td></tr>
<tr class="memdesc:ga94a4c60055d1958fe3ecb3f2ff3b5056"><td class="mdescLeft">&#160;</td><td class="mdescRight">Simple non-confirmable FETCH (<a href="https://datatracker.ietf.org/doc/html/rfc8132">RFC 8132</a>)  <a href="#ga94a4c60055d1958fe3ecb3f2ff3b5056">More...</a><br /></td></tr>
<tr class="separator:ga94a4c60055d1958fe3ecb3f2ff3b5056"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9ea49916951bb8110cc65d35a4ffe2d1"><td class="memItemLeft" align="right" valign="top">ssize_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__net__nanosock.html#ga9ea49916951bb8110cc65d35a4ffe2d1">nanocoap_sock_fetch_url</a> (const char *url, const void *request, size_t len, void *response, size_t len_max)</td></tr>
<tr class="memdesc:ga9ea49916951bb8110cc65d35a4ffe2d1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Simple synchronous CoAP (confirmable) FETCH to URL (<a href="https://datatracker.ietf.org/doc/html/rfc8132">RFC 8132</a>)  <a href="#ga9ea49916951bb8110cc65d35a4ffe2d1">More...</a><br /></td></tr>
<tr class="separator:ga9ea49916951bb8110cc65d35a4ffe2d1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga18c380fe1dfea851fed1bd068684d094"><td class="memItemLeft" align="right" valign="top">ssize_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__net__nanosock.html#ga18c380fe1dfea851fed1bd068684d094">nanocoap_sock_delete</a> (<a class="el" href="structnanocoap__sock__t.html">nanocoap_sock_t</a> *sock, const char *path)</td></tr>
<tr class="memdesc:ga18c380fe1dfea851fed1bd068684d094"><td class="mdescLeft">&#160;</td><td class="mdescRight">Simple synchronous CoAP (confirmable) DELETE.  <a href="#ga18c380fe1dfea851fed1bd068684d094">More...</a><br /></td></tr>
<tr class="separator:ga18c380fe1dfea851fed1bd068684d094"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga370193392b90544d127a797db8c5c2b1"><td class="memItemLeft" align="right" valign="top">ssize_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__net__nanosock.html#ga370193392b90544d127a797db8c5c2b1">nanocoap_sock_delete_url</a> (const char *url)</td></tr>
<tr class="memdesc:ga370193392b90544d127a797db8c5c2b1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Simple synchronous CoAP (confirmable) DELETE for URL.  <a href="#ga370193392b90544d127a797db8c5c2b1">More...</a><br /></td></tr>
<tr class="separator:ga370193392b90544d127a797db8c5c2b1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad565b9d312a92f25384a76cf0805b6d9"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__net__nanosock.html#gad565b9d312a92f25384a76cf0805b6d9">nanocoap_sock_get_blockwise</a> (<a class="el" href="structnanocoap__sock__t.html">nanocoap_sock_t</a> *sock, const char *path, <a class="el" href="group__net__coap.html#ga0fcf4cd975c851efc10c4388ee6236e9">coap_blksize_t</a> blksize, <a class="el" href="group__net__nanocoap.html#gac1c99e4c6b4acff707d856ba0b18d590">coap_blockwise_cb_t</a> callback, void *arg)</td></tr>
<tr class="memdesc:gad565b9d312a92f25384a76cf0805b6d9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs a blockwise coap get request on a socket.  <a href="#gad565b9d312a92f25384a76cf0805b6d9">More...</a><br /></td></tr>
<tr class="separator:gad565b9d312a92f25384a76cf0805b6d9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga402626952d9a947953122441c4245b80"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__net__nanosock.html#ga402626952d9a947953122441c4245b80">nanocoap_sock_get_slice</a> (<a class="el" href="structnanocoap__sock__t.html">nanocoap_sock_t</a> *sock, const char *path, <a class="el" href="group__net__coap.html#ga0fcf4cd975c851efc10c4388ee6236e9">coap_blksize_t</a> blksize, size_t offset, void *dst, size_t len)</td></tr>
<tr class="memdesc:ga402626952d9a947953122441c4245b80"><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs a blockwise coap get request to the specified url, store the response in a buffer.  <a href="#ga402626952d9a947953122441c4245b80">More...</a><br /></td></tr>
<tr class="separator:ga402626952d9a947953122441c4245b80"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gabcffa1a45484915af70db2a5be4990a8"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__net__nanosock.html#gabcffa1a45484915af70db2a5be4990a8">nanocoap_get_blockwise_url</a> (const char *url, <a class="el" href="group__net__coap.html#ga0fcf4cd975c851efc10c4388ee6236e9">coap_blksize_t</a> blksize, <a class="el" href="group__net__nanocoap.html#gac1c99e4c6b4acff707d856ba0b18d590">coap_blockwise_cb_t</a> callback, void *arg)</td></tr>
<tr class="memdesc:gabcffa1a45484915af70db2a5be4990a8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs a blockwise coap get request to the specified url.  <a href="#gabcffa1a45484915af70db2a5be4990a8">More...</a><br /></td></tr>
<tr class="separator:gabcffa1a45484915af70db2a5be4990a8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab75c570cd55959d508767fd7f556eaf6"><td class="memItemLeft" align="right" valign="top">ssize_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__net__nanosock.html#gab75c570cd55959d508767fd7f556eaf6">nanocoap_get_blockwise_url_to_buf</a> (const char *url, <a class="el" href="group__net__coap.html#ga0fcf4cd975c851efc10c4388ee6236e9">coap_blksize_t</a> blksize, void *buf, size_t len)</td></tr>
<tr class="memdesc:gab75c570cd55959d508767fd7f556eaf6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs a blockwise coap get request to the specified url, store the response in a buffer.  <a href="#gab75c570cd55959d508767fd7f556eaf6">More...</a><br /></td></tr>
<tr class="separator:gab75c570cd55959d508767fd7f556eaf6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaee41fbae256f3f0d28a825228a4da56d"><td class="memItemLeft" align="right" valign="top">ssize_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__net__nanosock.html#gaee41fbae256f3f0d28a825228a4da56d">nanocoap_get_blockwise_to_buf</a> (<a class="el" href="structnanocoap__sock__t.html">nanocoap_sock_t</a> *sock, const char *path, <a class="el" href="group__net__coap.html#ga0fcf4cd975c851efc10c4388ee6236e9">coap_blksize_t</a> blksize, void *buf, size_t len)</td></tr>
<tr class="memdesc:gaee41fbae256f3f0d28a825228a4da56d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs a blockwise CoAP GET request, store the response in a buffer.  <a href="#gaee41fbae256f3f0d28a825228a4da56d">More...</a><br /></td></tr>
<tr class="separator:gaee41fbae256f3f0d28a825228a4da56d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga829870b2ff3a51a4a908f86ad98303c2"><td class="memItemLeft" align="right" valign="top">ssize_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__net__nanosock.html#ga829870b2ff3a51a4a908f86ad98303c2">nanocoap_sock_request</a> (<a class="el" href="structnanocoap__sock__t.html">nanocoap_sock_t</a> *sock, <a class="el" href="structcoap__pkt__t.html">coap_pkt_t</a> *pkt, size_t len)</td></tr>
<tr class="memdesc:ga829870b2ff3a51a4a908f86ad98303c2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Simple synchronous CoAP request.  <a href="#ga829870b2ff3a51a4a908f86ad98303c2">More...</a><br /></td></tr>
<tr class="separator:ga829870b2ff3a51a4a908f86ad98303c2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab306582328424179525af3296bd3618d"><td class="memItemLeft" align="right" valign="top">ssize_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__net__nanosock.html#gab306582328424179525af3296bd3618d">nanocoap_sock_request_cb</a> (<a class="el" href="structnanocoap__sock__t.html">nanocoap_sock_t</a> *sock, <a class="el" href="structcoap__pkt__t.html">coap_pkt_t</a> *pkt, <a class="el" href="group__net__nanocoap.html#gac302c0f9ec8053b64b9b46a4dbee9092">coap_request_cb_t</a> cb, void *arg)</td></tr>
<tr class="memdesc:gab306582328424179525af3296bd3618d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Simple synchronous CoAP request with callback.  <a href="#gab306582328424179525af3296bd3618d">More...</a><br /></td></tr>
<tr class="separator:gab306582328424179525af3296bd3618d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga48c6a342b8f4c32719eb6602756783d8"><td class="memItemLeft" align="right" valign="top">ssize_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__net__nanosock.html#ga48c6a342b8f4c32719eb6602756783d8">nanocoap_request</a> (<a class="el" href="structcoap__pkt__t.html">coap_pkt_t</a> *pkt, const <a class="el" href="group__net__sock__udp.html#gaedc829c7973d7870c1ec078f9ffd45a1">sock_udp_ep_t</a> *local, const <a class="el" href="group__net__sock__udp.html#gaedc829c7973d7870c1ec078f9ffd45a1">sock_udp_ep_t</a> *remote, size_t len)</td></tr>
<tr class="memdesc:ga48c6a342b8f4c32719eb6602756783d8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Simple synchronous CoAP request.  <a href="#ga48c6a342b8f4c32719eb6602756783d8">More...</a><br /></td></tr>
<tr class="separator:ga48c6a342b8f4c32719eb6602756783d8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab53f88387e3ed79d8288ac7beaf7873a"><td class="memItemLeft" align="right" valign="top">static int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__net__nanosock.html#gab53f88387e3ed79d8288ac7beaf7873a">nanocoap_block_request_connect_url</a> (<a class="el" href="structcoap__block__request__t.html">coap_block_request_t</a> *ctx, <a class="el" href="structnanocoap__sock__t.html">nanocoap_sock_t</a> *sock, const char *url, <a class="el" href="group__net__coap.html#gaf99712dec26d13b1649cc55043580645">coap_method_t</a> method, <a class="el" href="group__net__coap.html#ga0fcf4cd975c851efc10c4388ee6236e9">coap_blksize_t</a> blksize)</td></tr>
<tr class="memdesc:gab53f88387e3ed79d8288ac7beaf7873a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initialize block request context by URL and connect a socket.  <a href="#gab53f88387e3ed79d8288ac7beaf7873a">More...</a><br /></td></tr>
<tr class="separator:gab53f88387e3ed79d8288ac7beaf7873a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa9282335cdd7d0bb39bcd4d48fab1517"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__net__nanosock.html#gaa9282335cdd7d0bb39bcd4d48fab1517">nanocoap_sock_block_request</a> (<a class="el" href="structcoap__block__request__t.html">coap_block_request_t</a> *ctx, const void *data, size_t len, bool more, <a class="el" href="group__net__nanocoap.html#gac302c0f9ec8053b64b9b46a4dbee9092">coap_request_cb_t</a> cb, void *arg)</td></tr>
<tr class="memdesc:gaa9282335cdd7d0bb39bcd4d48fab1517"><td class="mdescLeft">&#160;</td><td class="mdescRight">Do a block-wise request, send a single block.  <a href="#gaa9282335cdd7d0bb39bcd4d48fab1517">More...</a><br /></td></tr>
<tr class="separator:gaa9282335cdd7d0bb39bcd4d48fab1517"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Macro Definition Documentation</h2>
<a id="ga1288882055b3987361fa829c8fc5a774"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga1288882055b3987361fa829c8fc5a774">&#9670;&nbsp;</a></span>CONFIG_NANOCOAP_SERVER_BUF_SIZE</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define CONFIG_NANOCOAP_SERVER_BUF_SIZE</td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Value:</b><div class="fragment"><div class="line">((1 &lt;&lt; (<a class="code" href="group__net__nanocoap__conf.html#ga57764b240b0b5b1e541d437ba17b388b">CONFIG_NANOCOAP_BLOCKSIZE_DEFAULT</a> + 3)) \</div><div class="line">                                                 + <a class="code" href="group__net__nanocoap__conf.html#gad2a9d5ec5442be6a6df445254a1a5a26">CONFIG_NANOCOAP_URI_MAX</a> + 16)</div><div class="ttc" id="group__net__nanocoap__conf_html_gad2a9d5ec5442be6a6df445254a1a5a26"><div class="ttname"><a href="group__net__nanocoap__conf.html#gad2a9d5ec5442be6a6df445254a1a5a26">CONFIG_NANOCOAP_URI_MAX</a></div><div class="ttdeci">#define CONFIG_NANOCOAP_URI_MAX</div><div class="ttdoc">Maximum length of a resource path string read from or written to a message. </div><div class="ttdef"><b>Definition:</b> <a href="nanocoap_8h_source.html#l00146">nanocoap.h:146</a></div></div>
<div class="ttc" id="group__net__nanocoap__conf_html_ga57764b240b0b5b1e541d437ba17b388b"><div class="ttname"><a href="group__net__nanocoap__conf.html#ga57764b240b0b5b1e541d437ba17b388b">CONFIG_NANOCOAP_BLOCKSIZE_DEFAULT</a></div><div class="ttdeci">#define CONFIG_NANOCOAP_BLOCKSIZE_DEFAULT</div><div class="ttdoc">CoAP block-wise-transfer size that should be used by default. </div><div class="ttdef"><b>Definition:</b> <a href="nanocoap_8h_source.html#l00160">nanocoap.h:160</a></div></div>
</div><!-- fragment -->
<p>CoAP server work buf size Used both for RX and TX, needs to hold payload block + header. </p>

<p class="definition">Definition at line <a class="el" href="nanocoap__sock_8h_source.html#l00170">170</a> of file <a class="el" href="nanocoap__sock_8h_source.html">nanocoap_sock.h</a>.</p>

</div>
</div>
<a id="gaedbd07b2745e261ec745b46a6549c34d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaedbd07b2745e261ec745b46a6549c34d">&#9670;&nbsp;</a></span>CONFIG_NANOCOAP_SOCK_BLOCK_TOKEN</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define CONFIG_NANOCOAP_SOCK_BLOCK_TOKEN&#160;&#160;&#160;(0)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Include a random token with block-wise transfers. </p>
<p>This is a workaround for buggy CoPA implementations (e.g. go-coap) that expect to identify block-wise transfers based on the token.</p>
<p>See <a href="https://github.com/plgd-dev/go-coap/issues/512">https://github.com/plgd-dev/go-coap/issues/512</a> </p>

<p class="definition">Definition at line <a class="el" href="nanocoap__sock_8h_source.html#l00190">190</a> of file <a class="el" href="nanocoap__sock_8h_source.html">nanocoap_sock.h</a>.</p>

</div>
</div>
<h2 class="groupheader">Enumeration Type Documentation</h2>
<a id="gae3e4fc820564121c86199921270c0275"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gae3e4fc820564121c86199921270c0275">&#9670;&nbsp;</a></span>nanocoap_socket_type_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="group__net__nanosock.html#gae3e4fc820564121c86199921270c0275">nanocoap_socket_type_t</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>NanoCoAP socket types. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="ggae3e4fc820564121c86199921270c0275a2ebef91b4b721d48214df2d32ec4cae7"></a>COAP_SOCKET_TYPE_UDP&#160;</td><td class="fielddoc"><p>transport is plain UDP </p>
</td></tr>
<tr><td class="fieldname"><a id="ggae3e4fc820564121c86199921270c0275ac0403908f2afb92fa49f3e70e6640b38"></a>COAP_SOCKET_TYPE_DTLS&#160;</td><td class="fielddoc"><p>transport is DTLS </p>
</td></tr>
</table>

<p class="definition">Definition at line <a class="el" href="nanocoap__sock_8h_source.html#l00196">196</a> of file <a class="el" href="nanocoap__sock_8h_source.html">nanocoap_sock.h</a>.</p>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a id="gab53f88387e3ed79d8288ac7beaf7873a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gab53f88387e3ed79d8288ac7beaf7873a">&#9670;&nbsp;</a></span>nanocoap_block_request_connect_url()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static int nanocoap_block_request_connect_url </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structcoap__block__request__t.html">coap_block_request_t</a> *&#160;</td>
          <td class="paramname"><em>ctx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structnanocoap__sock__t.html">nanocoap_sock_t</a> *&#160;</td>
          <td class="paramname"><em>sock</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>url</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__net__coap.html#gaf99712dec26d13b1649cc55043580645">coap_method_t</a>&#160;</td>
          <td class="paramname"><em>method</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__net__coap.html#ga0fcf4cd975c851efc10c4388ee6236e9">coap_blksize_t</a>&#160;</td>
          <td class="paramname"><em>blksize</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Initialize block request context by URL and connect a socket. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">ctx</td><td>The block request context to initialize </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">sock</td><td>Socket to initialize and use for the request </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">url</td><td>The request URL </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">method</td><td>Request method (<code>COAP_METHOD_{GET|PUT|POST|FETCH}</code>) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">blksize</td><td>Request blocksize exponent</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">0</td><td>Success </td></tr>
    <tr><td class="paramname">&lt;0</td><td>Error (see <a class="el" href="group__net__nanosock.html#ga282ddfd4238b746dd20d4cfe4df4c244">nanocoap_sock_url_connect</a> for details) </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="nanocoap__sock_8h_source.html#l00935">935</a> of file <a class="el" href="nanocoap__sock_8h_source.html">nanocoap_sock.h</a>.</p>

</div>
</div>
<a id="gaee41fbae256f3f0d28a825228a4da56d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaee41fbae256f3f0d28a825228a4da56d">&#9670;&nbsp;</a></span>nanocoap_get_blockwise_to_buf()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ssize_t nanocoap_get_blockwise_to_buf </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structnanocoap__sock__t.html">nanocoap_sock_t</a> *&#160;</td>
          <td class="paramname"><em>sock</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>path</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__net__coap.html#ga0fcf4cd975c851efc10c4388ee6236e9">coap_blksize_t</a>&#160;</td>
          <td class="paramname"><em>blksize</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>buf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>len</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Performs a blockwise CoAP GET request, store the response in a buffer. </p>
<p>This function will fetch the content of the specified resource path via block-wise-transfer. The blocks will be re-assembled into <code>buf</code> </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">sock</td><td>socket to use for the request </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">path</td><td>pointer to source path </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">blksize</td><td>sender suggested SZX for the COAP block request </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">buf</td><td>Target buffer </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">len</td><td>Target buffer length</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>&lt;0 on error </dd>
<dd>
-EINVAL if an invalid url is provided </dd>
<dd>
-ENOBUFS if the provided buffer was too small </dd>
<dd>
size of the response payload on success </dd></dl>

</div>
</div>
<a id="gabcffa1a45484915af70db2a5be4990a8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gabcffa1a45484915af70db2a5be4990a8">&#9670;&nbsp;</a></span>nanocoap_get_blockwise_url()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int nanocoap_get_blockwise_url </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>url</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__net__coap.html#ga0fcf4cd975c851efc10c4388ee6236e9">coap_blksize_t</a>&#160;</td>
          <td class="paramname"><em>blksize</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__net__nanocoap.html#gac1c99e4c6b4acff707d856ba0b18d590">coap_blockwise_cb_t</a>&#160;</td>
          <td class="paramname"><em>callback</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>arg</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Performs a blockwise coap get request to the specified url. </p>
<p>This function will fetch the content of the specified resource path via block-wise-transfer. A coap_blockwise_cb_t will be called on each received block.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">url</td><td>Absolute URL pointer to source path (i.e. not containing a fragment identifier) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">blksize</td><td>sender suggested SZX for the COAP block request </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">callback</td><td>callback to be executed on each received block </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">arg</td><td>optional function arguments</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>-EINVAL if an invalid url is provided </dd>
<dd>
-1 if failed to fetch the url content </dd>
<dd>
0 on success </dd></dl>

</div>
</div>
<a id="gab75c570cd55959d508767fd7f556eaf6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gab75c570cd55959d508767fd7f556eaf6">&#9670;&nbsp;</a></span>nanocoap_get_blockwise_url_to_buf()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ssize_t nanocoap_get_blockwise_url_to_buf </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>url</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__net__coap.html#ga0fcf4cd975c851efc10c4388ee6236e9">coap_blksize_t</a>&#160;</td>
          <td class="paramname"><em>blksize</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>buf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>len</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Performs a blockwise coap get request to the specified url, store the response in a buffer. </p>
<p>This function will fetch the content of the specified resource path via block-wise-transfer. The blocks will be re-assembled into <code>buf</code> </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">url</td><td>Absolute URL pointer to source path (i.e. not containing a fragment identifier) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">blksize</td><td>sender suggested SZX for the COAP block request </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">buf</td><td>Target buffer </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">len</td><td>Target buffer length</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>&lt;0 on error </dd>
<dd>
-EINVAL if an invalid url is provided </dd>
<dd>
-ENOBUFS if the provided buffer was too small </dd>
<dd>
size of the response payload on success </dd></dl>

</div>
</div>
<a id="ga1b00144ef395648226920cea3d714414"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga1b00144ef395648226920cea3d714414">&#9670;&nbsp;</a></span>nanocoap_notify_observers()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void nanocoap_notify_observers </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structcoap__resource__t.html">coap_resource_t</a> *&#160;</td>
          <td class="paramname"><em>res</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group__sys__iolist.html#gaa17f91ef26edec149cd806d8457aa3a0">iolist_t</a> *&#160;</td>
          <td class="paramname"><em>iol</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Notify all currently registered observers of the given resource. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">res</td><td>Resource to send updates for </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">iol</td><td>I/O list containing the CoAP Options, payload marker, and payload of the update to send up</td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>Precondition</dt><dd><code>iol</code> contains everything but the CoAP header needed to send out. This will at least be a CoAP observe option, a payload marker, and a payload</dd></dl>
<dl class="section post"><dt>Postcondition</dt><dd>For each registered observer a CoAP packet header is generated and the concatenation of that header and the provided list is sent </dd></dl>

</div>
</div>
<a id="ga53869b20a9ab8e7a39d6781dd69f773d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga53869b20a9ab8e7a39d6781dd69f773d">&#9670;&nbsp;</a></span>nanocoap_notify_observers_simple()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void nanocoap_notify_observers_simple </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structcoap__resource__t.html">coap_resource_t</a> *&#160;</td>
          <td class="paramname"><em>res</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>obs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>payload</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>payload_len</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Build and send notification to observers registered to a specific resource. </p>
<dl class="section note"><dt>Note</dt><dd>Use <a class="el" href="group__net__nanosock.html#ga1b00144ef395648226920cea3d714414">nanocoap_notify_observers</a> for more control (such as adding custom options) over the notification(s) to send.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">res</td><td>Resource to send updates for </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">obs</td><td>24-bit number to add as observe option </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">payload</td><td>Payload to send out </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">payload_len</td><td>Length of <code>payload</code> in bytes </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga0acf5a5e9dc95e1d47cf199ec5f792cc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga0acf5a5e9dc95e1d47cf199ec5f792cc">&#9670;&nbsp;</a></span>nanocoap_register_observer()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int nanocoap_register_observer </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="group__net__nanocoap.html#gaedec79122f8968eb8b04e9e9360b392a">coap_request_ctx_t</a> *&#160;</td>
          <td class="paramname"><em>req_ctx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structcoap__pkt__t.html">coap_pkt_t</a> *&#160;</td>
          <td class="paramname"><em>req_pkt</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Register an observer. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">req_ctx</td><td>Request context belonging to <code>req_pkt</code> </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">req_pkt</td><td>Request that contained the observe registration request</td></tr>
  </table>
  </dd>
</dl>
<dl class="section warning"><dt>Warning</dt><dd>This depends on module <code>nanocoap_server_observe</code></dd></dl>
<dl class="section note"><dt>Note</dt><dd>If the same endpoint already was registered on the same resource, it will just update the token and keep the existing entry. This way duplicate detection is not needed and we eagerly can reclaim resources when a client lost state.</dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>Preventing the same endpoint to registers more than once (using different tokens) to the same resource deviates from RFC 7641.</dd></dl>
<p>The deviation here is intentional. A server can receive a second registration from the same endpoint for the same resource for one of the following reasons:</p>
<ol type="1">
<li>Reaffirming the registration by using the same token again.</li>
<li>Losing state on the client side.</li>
<li>A malicious client trying to exhaust resources.</li>
<li>The same resource has different representations depending on the request. (E.g. <code>/.well-known/core</code> can yield a wildly different response depending on filters provided via URI-Query Options.)</li>
</ol>
<p>For case 1 updating the registration is matching what the spec mandates. For two the old registration will not be of value for the client, and overwriting it makes more efficient use of network bandwidth and RAM. For 3 the deviation forces the adversary to send observe requests from different ports to exhaust resources, which is a very minor improvement. For 4 the deviation is a problem. However, the observe API does not allow to send out different notification messages for the same resource anyway, so case 4 cannot occur here.</p>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">0</td><td>Success </td></tr>
    <tr><td class="paramname">-ENOMEM</td><td>Not enough resources to register another observer </td></tr>
    <tr><td class="paramname">&lt;0</td><td>Negative errno code indicating error </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga48c6a342b8f4c32719eb6602756783d8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga48c6a342b8f4c32719eb6602756783d8">&#9670;&nbsp;</a></span>nanocoap_request()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ssize_t nanocoap_request </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structcoap__pkt__t.html">coap_pkt_t</a> *&#160;</td>
          <td class="paramname"><em>pkt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group__net__sock__udp.html#gaedc829c7973d7870c1ec078f9ffd45a1">sock_udp_ep_t</a> *&#160;</td>
          <td class="paramname"><em>local</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group__net__sock__udp.html#gaedc829c7973d7870c1ec078f9ffd45a1">sock_udp_ep_t</a> *&#160;</td>
          <td class="paramname"><em>remote</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>len</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Simple synchronous CoAP request. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">pkt</td><td>Packet struct containing the request. Is reused for the response </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">local</td><td>Local UDP endpoint, may be NULL </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">remote</td><td>remote UDP endpoint </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">len</td><td>Total length of the buffer associated with the request</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>length of response on success </dd>
<dd>
</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__net__nanosock.html#gab306582328424179525af3296bd3618d" title="Simple synchronous CoAP request with callback. ">nanocoap_sock_request_cb</a> on error </dd></dl>

</div>
</div>
<a id="gaa8dc99f3f6c9b49ce8a4da7f15260766"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaa8dc99f3f6c9b49ce8a4da7f15260766">&#9670;&nbsp;</a></span>nanocoap_server()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int nanocoap_server </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__net__sock__udp.html#gaedc829c7973d7870c1ec078f9ffd45a1">sock_udp_ep_t</a> *&#160;</td>
          <td class="paramname"><em>local</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t *&#160;</td>
          <td class="paramname"><em>buf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>bufsize</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Start a nanocoap server instance. </p>
<p>This function only returns if there's an error binding to <code>local</code>, or if receiving of UDP packets fails.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">local</td><td>local UDP endpoint to bind to </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">buf</td><td>input buffer to use </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">bufsize</td><td>size of <code>buf</code> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>-1 on error </dd></dl>

</div>
</div>
<a id="ga01062e5dfc134d6be0e205a749c2e590"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga01062e5dfc134d6be0e205a749c2e590">&#9670;&nbsp;</a></span>nanocoap_server_build_separate()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ssize_t nanocoap_server_build_separate </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structnanocoap__server__response__ctx__t.html">nanocoap_server_response_ctx_t</a> *&#160;</td>
          <td class="paramname"><em>ctx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>buf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>buf_len</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>code</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>msg_id</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Build a separate response header to a CoAP request. </p>
<p>This builds the response packet header. You may add CoAP Options, a payload marker and a payload as needed after the header.</p>
<dl class="section pre"><dt>Precondition</dt><dd><a class="el" href="group__net__nanosock.html#ga531691c36ce014e57840be2a8fc76b39">nanocoap_server_prepare_separate</a> has been called on <code>ctx</code> inside the CoAP handler </dd>
<dd>
Synchronization between calls of this function and calls of <a class="el" href="group__net__nanosock.html#ga531691c36ce014e57840be2a8fc76b39">nanocoap_server_prepare_separate</a> is ensured</dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>This function is only available when using the module <code>nanocoap_server_separate</code></dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">ctx</td><td>Context information for the CoAP response </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">buf</td><td>Buffer to write the header to </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">buf_len</td><td>Length of <code>buf</code> in bytes </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">code</td><td>CoAP response code </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">type</td><td>Response type, may be <code>COAP_TYPE_NON</code> </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">msg_id</td><td>Message ID to send</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Length of the header build in bytes </dd></dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">-ECANCELED</td><td>Request contained no-response option that did match the given <code>code</code> </td></tr>
    <tr><td class="paramname">&lt;0</td><td>Negative errno code indicating the error </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gae3dab379eeb1120072ce64392874afca"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gae3dab379eeb1120072ce64392874afca">&#9670;&nbsp;</a></span>nanocoap_server_is_remote_in_response_ctx()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool nanocoap_server_is_remote_in_response_ctx </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structnanocoap__server__response__ctx__t.html">nanocoap_server_response_ctx_t</a> *&#160;</td>
          <td class="paramname"><em>ctx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group__net__nanocoap.html#gaedec79122f8968eb8b04e9e9360b392a">coap_request_ctx_t</a> *&#160;</td>
          <td class="paramname"><em>req</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Check if a given separate response context was prepared for the remote endpoint of a given request. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">ctx</td><td>Separate response context to check </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">req</td><td>Request from the remote to check for</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">true</td><td>The remote endpoint given by <code>req</code> is in <code>ctx</code> </td></tr>
    <tr><td class="paramname">false</td><td><code>ctx</code> was prepared for a different remote endpoint </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga531691c36ce014e57840be2a8fc76b39"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga531691c36ce014e57840be2a8fc76b39">&#9670;&nbsp;</a></span>nanocoap_server_prepare_separate()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int nanocoap_server_prepare_separate </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structnanocoap__server__response__ctx__t.html">nanocoap_server_response_ctx_t</a> *&#160;</td>
          <td class="paramname"><em>ctx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structcoap__pkt__t.html">coap_pkt_t</a> *&#160;</td>
          <td class="paramname"><em>pkt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group__net__nanocoap.html#gaedec79122f8968eb8b04e9e9360b392a">coap_request_ctx_t</a> *&#160;</td>
          <td class="paramname"><em>req</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Prepare the context for a separate response. </p>
<p>This function serializes the CoAP request information so that a separate response can be generated outside the CoAP handler.</p>
<p>The CoAP handler should then respond with an empty ACK by calling <a class="el" href="group__net__nanocoap.html#ga69b46335b2b67c5245e6be1777134bf8">coap_build_empty_ack</a></p>
<dl class="section warning"><dt>Warning</dt><dd>This function is only available when using the module <code>nanocoap_server_separate</code></dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">ctx</td><td>Context information for separate response </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">pkt</td><td>CoAP packet to which the response will be generated </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">req</td><td>Context of the CoAP request</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">0</td><td>Success </td></tr>
    <tr><td class="paramname">-EOVERFLOW</td><td>Storing context would have overflown buffers in <code>ctx</code> (e.g. RFC 8974 (module <code>nanocoap_token_ext</code>) is in use and token too long) </td></tr>
    <tr><td class="paramname">&lt;0</td><td>Other error </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gaabc7cae6d9a18f2a2360d592542d67a7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaabc7cae6d9a18f2a2360d592542d67a7">&#9670;&nbsp;</a></span>nanocoap_server_send_separate()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int nanocoap_server_send_separate </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structnanocoap__server__response__ctx__t.html">nanocoap_server_response_ctx_t</a> *&#160;</td>
          <td class="paramname"><em>ctx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>code</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>payload</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>len</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Build and send a separate response to a CoAP request. </p>
<p>This sends a response to a CoAP request outside the CoAP handler</p>
<dl class="section pre"><dt>Precondition</dt><dd><a class="el" href="group__net__nanosock.html#ga531691c36ce014e57840be2a8fc76b39">nanocoap_server_prepare_separate</a> has been called on <code>ctx</code> inside the CoAP handler </dd>
<dd>
Synchronization between calls of this function and calls of <a class="el" href="group__net__nanosock.html#ga531691c36ce014e57840be2a8fc76b39">nanocoap_server_prepare_separate</a> is ensured</dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>This function is only available when using the module <code>nanocoap_server_separate</code></dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">ctx</td><td>Context information for the CoAP response </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">code</td><td>CoAP response code </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">type</td><td>Response type, may be <code>COAP_TYPE_NON</code> </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">payload</td><td>Response payload </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">len</td><td>Payload length</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">0</td><td>Success </td></tr>
    <tr><td class="paramname">-ECANCELED</td><td>Request contained no-response option that did match the given <code>code</code> </td></tr>
    <tr><td class="paramname">&lt;0</td><td>Negative errno code indicating the error </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga87500394e8015fef76ab00bf9497dc28"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga87500394e8015fef76ab00bf9497dc28">&#9670;&nbsp;</a></span>nanocoap_server_sendv_separate()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int nanocoap_server_sendv_separate </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structnanocoap__server__response__ctx__t.html">nanocoap_server_response_ctx_t</a> *&#160;</td>
          <td class="paramname"><em>ctx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group__sys__iolist.html#gaa17f91ef26edec149cd806d8457aa3a0">iolist_t</a> *&#160;</td>
          <td class="paramname"><em>reply</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Send an already build separate response. </p>
<dl class="section pre"><dt>Precondition</dt><dd><a class="el" href="group__net__nanosock.html#ga531691c36ce014e57840be2a8fc76b39">nanocoap_server_prepare_separate</a> has been called on <code>ctx</code> inside the CoAP handler </dd>
<dd>
Synchronization between calls of this function and calls of <a class="el" href="group__net__nanosock.html#ga531691c36ce014e57840be2a8fc76b39">nanocoap_server_prepare_separate</a> is ensured </dd>
<dd>
<a class="el" href="group__net__nanosock.html#ga01062e5dfc134d6be0e205a749c2e590">nanocoap_server_build_separate</a> has been used to build the header in <code>msg</code> </dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>This function is only available when using the module <code>nanocoap_server_separate</code></dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">ctx</td><td>Context information for the CoAP response </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">reply</td><td>I/O list containing the reply to send</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">0</td><td>Success </td></tr>
    <tr><td class="paramname">&lt;0</td><td>negative errno code indicating the error </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga67689e162bf20649cca78957f4869dba"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga67689e162bf20649cca78957f4869dba">&#9670;&nbsp;</a></span>nanocoap_server_start()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__core__sched.html#ga8375139300d7cbf23bd8bd89ddddbe84">kernel_pid_t</a> nanocoap_server_start </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="group__net__sock__udp.html#gaedc829c7973d7870c1ec078f9ffd45a1">sock_udp_ep_t</a> *&#160;</td>
          <td class="paramname"><em>local</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create and start the nanoCoAP server thread. </p>
<p>To automatically start the nanoCoAP server on startup, select the <code>nanocoap_server_auto_init</code> module.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">local</td><td>UDP endpoint to bind to</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>pid of the server thread </dd></dl>

</div>
</div>
<a id="gaa9282335cdd7d0bb39bcd4d48fab1517"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaa9282335cdd7d0bb39bcd4d48fab1517">&#9670;&nbsp;</a></span>nanocoap_sock_block_request()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int nanocoap_sock_block_request </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structcoap__block__request__t.html">coap_block_request_t</a> *&#160;</td>
          <td class="paramname"><em>ctx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>len</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>more</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__net__nanocoap.html#gac302c0f9ec8053b64b9b46a4dbee9092">coap_request_cb_t</a>&#160;</td>
          <td class="paramname"><em>cb</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>arg</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Do a block-wise request, send a single block. </p>
<p>This method is expected to be called in a loop until all payload blocks have been transferred.</p>
<dl class="section pre"><dt>Precondition</dt><dd><code>ctx</code> was initialized with <a class="el" href="group__net__nanosock.html#gab53f88387e3ed79d8288ac7beaf7873a">nanocoap_block_request_connect_url</a> or manually.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">ctx</td><td>blockwise request context </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">data</td><td>payload to send </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">len</td><td>payload length </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">more</td><td>more blocks after this one (will be set automatically if <code>len</code> &gt; block size) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">cb</td><td>callback for response </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">arg</td><td>callback context</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Number of payload bytes written on success Negative error on failure </dd></dl>

</div>
</div>
<a id="gae9376e608769729b1668ccc349447082"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gae9376e608769729b1668ccc349447082">&#9670;&nbsp;</a></span>nanocoap_sock_close()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void nanocoap_sock_close </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structnanocoap__sock__t.html">nanocoap_sock_t</a> *&#160;</td>
          <td class="paramname"><em>sock</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Close a CoAP client socket. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">sock</td><td>CoAP UDP socket </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="nanocoap__sock_8h_source.html#l00542">542</a> of file <a class="el" href="nanocoap__sock_8h_source.html">nanocoap_sock.h</a>.</p>

</div>
</div>
<a id="gacec46e67451d121c6aa3c188b7734363"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gacec46e67451d121c6aa3c188b7734363">&#9670;&nbsp;</a></span>nanocoap_sock_connect()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static int nanocoap_sock_connect </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structnanocoap__sock__t.html">nanocoap_sock_t</a> *&#160;</td>
          <td class="paramname"><em>sock</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group__net__sock__udp.html#gaedc829c7973d7870c1ec078f9ffd45a1">sock_udp_ep_t</a> *&#160;</td>
          <td class="paramname"><em>local</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group__net__sock__udp.html#gaedc829c7973d7870c1ec078f9ffd45a1">sock_udp_ep_t</a> *&#160;</td>
          <td class="paramname"><em>remote</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Create a CoAP client socket. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">sock</td><td>CoAP UDP socket </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">local</td><td>Local UDP endpoint, may be NULL </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">remote</td><td>remote UDP endpoint</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 on success </dd>
<dd>
&lt;0 on error </dd></dl>

<p class="definition">Definition at line <a class="el" href="nanocoap__sock_8h_source.html#l00497">497</a> of file <a class="el" href="nanocoap__sock_8h_source.html">nanocoap_sock.h</a>.</p>

</div>
</div>
<a id="ga18c380fe1dfea851fed1bd068684d094"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga18c380fe1dfea851fed1bd068684d094">&#9670;&nbsp;</a></span>nanocoap_sock_delete()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ssize_t nanocoap_sock_delete </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structnanocoap__sock__t.html">nanocoap_sock_t</a> *&#160;</td>
          <td class="paramname"><em>sock</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>path</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Simple synchronous CoAP (confirmable) DELETE. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">sock</td><td>socket to use for the request </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">path</td><td>remote path (with query) to delete</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 on success </dd>
<dd>
</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__net__nanosock.html#gab306582328424179525af3296bd3618d" title="Simple synchronous CoAP request with callback. ">nanocoap_sock_request_cb</a> on error </dd></dl>

</div>
</div>
<a id="ga370193392b90544d127a797db8c5c2b1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga370193392b90544d127a797db8c5c2b1">&#9670;&nbsp;</a></span>nanocoap_sock_delete_url()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ssize_t nanocoap_sock_delete_url </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>url</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Simple synchronous CoAP (confirmable) DELETE for URL. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">url</td><td>URL of the resource that should be deleted</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 on success </dd>
<dd>
&lt;0 on error </dd></dl>

</div>
</div>
<a id="ga9027d8c301d6587c4b82e7332ae46b55"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga9027d8c301d6587c4b82e7332ae46b55">&#9670;&nbsp;</a></span>nanocoap_sock_dtls_connect()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int nanocoap_sock_dtls_connect </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structnanocoap__sock__t.html">nanocoap_sock_t</a> *&#160;</td>
          <td class="paramname"><em>sock</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__net__sock__udp.html#gaedc829c7973d7870c1ec078f9ffd45a1">sock_udp_ep_t</a> *&#160;</td>
          <td class="paramname"><em>local</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group__net__sock__udp.html#gaedc829c7973d7870c1ec078f9ffd45a1">sock_udp_ep_t</a> *&#160;</td>
          <td class="paramname"><em>remote</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__net__credman.html#ga89fc115fe10d879da7faf1c0d0f901a7">credman_tag_t</a>&#160;</td>
          <td class="paramname"><em>tag</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create a DTLS secured CoAP client socket. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">sock</td><td>CoAP UDP socket </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">local</td><td>Local UDP endpoint, may be NULL </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">remote</td><td>remote UDP endpoint </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">tag</td><td>Tag of the PSK credential to use Has to be added with <a class="el" href="group__net__credman.html#ga541badb0086366236a741db3f50eb3dc">credman_add</a></td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 on success </dd>
<dd>
&lt;0 on error </dd></dl>

</div>
</div>
<a id="ga88034d74b68f56ff5c84514cba774ead"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga88034d74b68f56ff5c84514cba774ead">&#9670;&nbsp;</a></span>nanocoap_sock_fetch()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ssize_t nanocoap_sock_fetch </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structnanocoap__sock__t.html">nanocoap_sock_t</a> *&#160;</td>
          <td class="paramname"><em>sock</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>path</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>request</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>len</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>response</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>len_max</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Simple synchronous CoAP (confirmable) FETCH (<a href="https://datatracker.ietf.org/doc/html/rfc8132">RFC 8132</a>) </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">sock</td><td>socket to use for the request </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">path</td><td>remote path and query </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">request</td><td>buffer containing the payload </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">len</td><td>length of the payload to send </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">response</td><td>buffer for the response, may be NULL </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">len_max</td><td>length of <code>response</code> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>length of response payload on success </dd>
<dd>
</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__net__nanosock.html#gab306582328424179525af3296bd3618d" title="Simple synchronous CoAP request with callback. ">nanocoap_sock_request_cb</a> on error </dd></dl>

</div>
</div>
<a id="ga94a4c60055d1958fe3ecb3f2ff3b5056"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga94a4c60055d1958fe3ecb3f2ff3b5056">&#9670;&nbsp;</a></span>nanocoap_sock_fetch_non()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ssize_t nanocoap_sock_fetch_non </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structnanocoap__sock__t.html">nanocoap_sock_t</a> *&#160;</td>
          <td class="paramname"><em>sock</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>path</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>request</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>len</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>response</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>len_max</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Simple non-confirmable FETCH (<a href="https://datatracker.ietf.org/doc/html/rfc8132">RFC 8132</a>) </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">sock</td><td>socket to use for the request </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">path</td><td>remote path and query </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">request</td><td>buffer containing the payload </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">len</td><td>length of the payload to send </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">response</td><td>buffer for the response, may be NULL </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">len_max</td><td>length of <code>response</code> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>length of response payload on success </dd>
<dd>
0 if the request was sent and no response buffer was provided, independently of success (because no response is requested in that case) </dd>
<dd>
</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__net__nanosock.html#gab306582328424179525af3296bd3618d" title="Simple synchronous CoAP request with callback. ">nanocoap_sock_request_cb</a> on error </dd></dl>

</div>
</div>
<a id="ga9ea49916951bb8110cc65d35a4ffe2d1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga9ea49916951bb8110cc65d35a4ffe2d1">&#9670;&nbsp;</a></span>nanocoap_sock_fetch_url()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ssize_t nanocoap_sock_fetch_url </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>url</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>request</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>len</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>response</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>len_max</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Simple synchronous CoAP (confirmable) FETCH to URL (<a href="https://datatracker.ietf.org/doc/html/rfc8132">RFC 8132</a>) </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">url</td><td>Absolute URL pointer to source path </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">request</td><td>buffer containing the payload </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">len</td><td>length of the payload to send </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">response</td><td>buffer for the response, may be NULL </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">len_max</td><td>length of <code>response</code> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>length of response payload on success </dd>
<dd>
&lt;0 on error </dd></dl>

</div>
</div>
<a id="gab66959ad47fd44afa1ebdf9d44d0b394"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gab66959ad47fd44afa1ebdf9d44d0b394">&#9670;&nbsp;</a></span>nanocoap_sock_get()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ssize_t nanocoap_sock_get </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structnanocoap__sock__t.html">nanocoap_sock_t</a> *&#160;</td>
          <td class="paramname"><em>sock</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>path</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>buf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>len</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Simple synchronous CoAP (confirmable) GET. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">sock</td><td>socket to use for the request </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">path</td><td>remote path and query </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">buf</td><td>buffer to write response to </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">len</td><td>length of <code>buffer</code> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>length of response payload on success </dd>
<dd>
</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__net__nanosock.html#gab306582328424179525af3296bd3618d" title="Simple synchronous CoAP request with callback. ">nanocoap_sock_request_cb</a> on error </dd></dl>

</div>
</div>
<a id="gad565b9d312a92f25384a76cf0805b6d9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gad565b9d312a92f25384a76cf0805b6d9">&#9670;&nbsp;</a></span>nanocoap_sock_get_blockwise()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int nanocoap_sock_get_blockwise </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structnanocoap__sock__t.html">nanocoap_sock_t</a> *&#160;</td>
          <td class="paramname"><em>sock</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>path</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__net__coap.html#ga0fcf4cd975c851efc10c4388ee6236e9">coap_blksize_t</a>&#160;</td>
          <td class="paramname"><em>blksize</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__net__nanocoap.html#gac1c99e4c6b4acff707d856ba0b18d590">coap_blockwise_cb_t</a>&#160;</td>
          <td class="paramname"><em>callback</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>arg</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Performs a blockwise coap get request on a socket. </p>
<p>This function will fetch the content of the specified resource path via block-wise-transfer. A coap_blockwise_cb_t will be called on each received block.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">sock</td><td>socket to use for the request </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">path</td><td>pointer to source path </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">blksize</td><td>sender suggested SZX for the COAP block request </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">callback</td><td>callback to be executed on each received block </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">arg</td><td>optional function arguments</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>-1 if failed to fetch the url content </dd>
<dd>
0 on success </dd></dl>

</div>
</div>
<a id="ga136631ddd8ef9ed9ac4561a453489269"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga136631ddd8ef9ed9ac4561a453489269">&#9670;&nbsp;</a></span>nanocoap_sock_get_non()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ssize_t nanocoap_sock_get_non </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structnanocoap__sock__t.html">nanocoap_sock_t</a> *&#160;</td>
          <td class="paramname"><em>sock</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>path</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>response</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>len_max</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Simple non-confirmable GET. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">sock</td><td>socket to use for the request </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">path</td><td>remote path and query </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">response</td><td>buffer for the response, may be NULL </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">len_max</td><td>length of <code>response</code> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>length of response payload on success </dd>
<dd>
</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__net__nanosock.html#gab306582328424179525af3296bd3618d" title="Simple synchronous CoAP request with callback. ">nanocoap_sock_request_cb</a> on error </dd></dl>

</div>
</div>
<a id="ga402626952d9a947953122441c4245b80"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga402626952d9a947953122441c4245b80">&#9670;&nbsp;</a></span>nanocoap_sock_get_slice()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int nanocoap_sock_get_slice </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structnanocoap__sock__t.html">nanocoap_sock_t</a> *&#160;</td>
          <td class="paramname"><em>sock</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>path</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__net__coap.html#ga0fcf4cd975c851efc10c4388ee6236e9">coap_blksize_t</a>&#160;</td>
          <td class="paramname"><em>blksize</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>offset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>dst</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>len</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Performs a blockwise coap get request to the specified url, store the response in a buffer. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">sock</td><td>socket to use for the request </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">path</td><td>Absolute URL pointer to source path </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">blksize</td><td>sender suggested SZX for the COAP block request </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">offset</td><td>Offset in bytes from the start of the resource </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">dst</td><td>Target buffer </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">len</td><td>Target buffer length</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>&lt;0 on error </dd>
<dd>
-EINVAL if an invalid url is provided </dd>
<dd>
size of the response payload on success </dd></dl>

</div>
</div>
<a id="gaa327f4e1e000925a6e1d06b5009d05cf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaa327f4e1e000925a6e1d06b5009d05cf">&#9670;&nbsp;</a></span>nanocoap_sock_next_msg_id()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static uint16_t nanocoap_sock_next_msg_id </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structnanocoap__sock__t.html">nanocoap_sock_t</a> *&#160;</td>
          <td class="paramname"><em>sock</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get next consecutive message ID for use when building a new CoAP request. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">sock</td><td>CoAP socket on which the ID is used</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A new message ID that can be used for a request or response. </dd></dl>

<p class="definition">Definition at line <a class="el" href="nanocoap__sock_8h_source.html#l00456">456</a> of file <a class="el" href="nanocoap__sock_8h_source.html">nanocoap_sock.h</a>.</p>

</div>
</div>
<a id="gaa3cc19122ffcf70a4a59653118808e7a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaa3cc19122ffcf70a4a59653118808e7a">&#9670;&nbsp;</a></span>nanocoap_sock_post()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ssize_t nanocoap_sock_post </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structnanocoap__sock__t.html">nanocoap_sock_t</a> *&#160;</td>
          <td class="paramname"><em>sock</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>path</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>request</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>len</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>response</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>len_max</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Simple synchronous CoAP (confirmable) POST. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">sock</td><td>socket to use for the request </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">path</td><td>remote path and query </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">request</td><td>buffer containing the payload </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">len</td><td>length of the payload to send </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">response</td><td>buffer for the response, may be NULL </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">len_max</td><td>length of <code>response</code> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>length of response payload on success </dd>
<dd>
</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__net__nanosock.html#gab306582328424179525af3296bd3618d" title="Simple synchronous CoAP request with callback. ">nanocoap_sock_request_cb</a> on error </dd></dl>

</div>
</div>
<a id="gaab1cde1ee8660b189691bc7ea76e5d8c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaab1cde1ee8660b189691bc7ea76e5d8c">&#9670;&nbsp;</a></span>nanocoap_sock_post_non()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ssize_t nanocoap_sock_post_non </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structnanocoap__sock__t.html">nanocoap_sock_t</a> *&#160;</td>
          <td class="paramname"><em>sock</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>path</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>request</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>len</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>response</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>len_max</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Simple non-confirmable POST. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">sock</td><td>socket to use for the request </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">path</td><td>remote path and query </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">request</td><td>buffer containing the payload </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">len</td><td>length of the payload to send </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">response</td><td>buffer for the response, may be NULL </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">len_max</td><td>length of <code>response</code> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>length of response payload on success </dd>
<dd>
0 if the request was sent and no response buffer was provided, independently of success (because no response is requested in that case) </dd>
<dd>
</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__net__nanosock.html#gab306582328424179525af3296bd3618d" title="Simple synchronous CoAP request with callback. ">nanocoap_sock_request_cb</a> on error </dd></dl>

</div>
</div>
<a id="ga3512df1cdfdf348901e4fa92508305e2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga3512df1cdfdf348901e4fa92508305e2">&#9670;&nbsp;</a></span>nanocoap_sock_post_url()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ssize_t nanocoap_sock_post_url </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>url</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>request</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>len</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>response</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>len_max</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Simple synchronous CoAP (confirmable) POST to URL. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">url</td><td>Absolute URL pointer to source path </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">request</td><td>buffer containing the payload </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">len</td><td>length of the payload to send </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">response</td><td>buffer for the response, may be NULL </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">len_max</td><td>length of <code>response</code> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>length of response payload on success </dd>
<dd>
&lt;0 on error </dd></dl>

</div>
</div>
<a id="ga25e146569f51b488e140eac77710d67f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga25e146569f51b488e140eac77710d67f">&#9670;&nbsp;</a></span>nanocoap_sock_put()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ssize_t nanocoap_sock_put </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structnanocoap__sock__t.html">nanocoap_sock_t</a> *&#160;</td>
          <td class="paramname"><em>sock</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>path</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>request</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>len</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>response</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>len_max</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Simple synchronous CoAP (confirmable) PUT. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">sock</td><td>socket to use for the request </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">path</td><td>remote path and query </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">request</td><td>buffer containing the payload </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">len</td><td>length of the payload to send </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">response</td><td>buffer for the response, may be NULL </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">len_max</td><td>length of <code>response</code> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>length of response payload on success </dd>
<dd>
</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__net__nanosock.html#gab306582328424179525af3296bd3618d" title="Simple synchronous CoAP request with callback. ">nanocoap_sock_request_cb</a> on error </dd></dl>

</div>
</div>
<a id="ga0ce8f6d164e274035ec452cadfa6f014"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga0ce8f6d164e274035ec452cadfa6f014">&#9670;&nbsp;</a></span>nanocoap_sock_put_non()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ssize_t nanocoap_sock_put_non </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structnanocoap__sock__t.html">nanocoap_sock_t</a> *&#160;</td>
          <td class="paramname"><em>sock</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>path</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>request</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>len</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>response</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>len_max</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Simple non-confirmable PUT. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">sock</td><td>socket to use for the request </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">path</td><td>remote path and query </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">request</td><td>buffer containing the payload </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">len</td><td>length of the payload to send </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">response</td><td>buffer for the response, may be NULL </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">len_max</td><td>length of <code>response</code> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>length of response payload on success </dd>
<dd>
0 if the request was sent and no response buffer was provided, independently of success (because no response is requested in that case) </dd>
<dd>
</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__net__nanosock.html#gab306582328424179525af3296bd3618d" title="Simple synchronous CoAP request with callback. ">nanocoap_sock_request_cb</a> on error </dd></dl>

</div>
</div>
<a id="gacb63bde357408c45b01de0d9995aa5df"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gacb63bde357408c45b01de0d9995aa5df">&#9670;&nbsp;</a></span>nanocoap_sock_put_url()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ssize_t nanocoap_sock_put_url </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>url</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>request</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>len</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>response</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>len_max</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Simple synchronous CoAP (confirmable) PUT to URL. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">url</td><td>Absolute URL pointer to source path </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">request</td><td>buffer containing the payload </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">len</td><td>length of the payload to send </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">response</td><td>buffer for the response, may be NULL </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">len_max</td><td>length of <code>response</code> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>length of response payload on success </dd>
<dd>
&lt;0 on error </dd></dl>

</div>
</div>
<a id="ga829870b2ff3a51a4a908f86ad98303c2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga829870b2ff3a51a4a908f86ad98303c2">&#9670;&nbsp;</a></span>nanocoap_sock_request()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ssize_t nanocoap_sock_request </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structnanocoap__sock__t.html">nanocoap_sock_t</a> *&#160;</td>
          <td class="paramname"><em>sock</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structcoap__pkt__t.html">coap_pkt_t</a> *&#160;</td>
          <td class="paramname"><em>pkt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>len</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Simple synchronous CoAP request. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">sock</td><td>socket to use for the request </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">pkt</td><td>Packet struct containing the request. Is reused for the response </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">len</td><td>Total length of the buffer associated with the request</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>length of response on success </dd>
<dd>
&lt;0 on error </dd></dl>

</div>
</div>
<a id="gab306582328424179525af3296bd3618d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gab306582328424179525af3296bd3618d">&#9670;&nbsp;</a></span>nanocoap_sock_request_cb()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ssize_t nanocoap_sock_request_cb </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structnanocoap__sock__t.html">nanocoap_sock_t</a> *&#160;</td>
          <td class="paramname"><em>sock</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structcoap__pkt__t.html">coap_pkt_t</a> *&#160;</td>
          <td class="paramname"><em>pkt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__net__nanocoap.html#gac302c0f9ec8053b64b9b46a4dbee9092">coap_request_cb_t</a>&#160;</td>
          <td class="paramname"><em>cb</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>arg</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Simple synchronous CoAP request with callback. </p>
<p>The response will be handled by a callback, which avoids copying the response packet out of the network stack internal buffer.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">sock</td><td>socket to use for the request </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">pkt</td><td>Packet struct containing the request. Is reused for the response </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">cb</td><td>Callback executed for response packet </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">arg</td><td>Optional callback argumnent</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>length of response on success </dd>
<dd>
0 for a request for which no response is expected, indicated by <code>cb</code> == NULL, or for a 2.xx response </dd>
<dd>
-ETIMEDOUT, if no matching ACK or no response was received </dd>
<dd>
-EBADMSG, if a matching RST was received </dd>
<dd>
-ENXIO, if <code>cb</code> == NULL and the response indicates a 4.xx client error </dd>
<dd>
-ENETRESET, if <code>cb</code> == NULL and the response indicates a 5.xx server error </dd>
<dd>
any error on </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__net__sock__udp.html#ga86893cb9733eb7cc210e0f2407f640e0" title="Sends a UDP message to remote end point with non-continous payload. ">sock_udp_sendv</a> or </dd>
<dd>
<a class="el" href="group__net__sock__dtls.html#ga16197978f12dc0efd521e8dba2853c45" title="Encrypts and sends a message to a remote peer with non-continous payload. ">sock_dtls_sendv</a> </dd></dl>
<dl class="section return"><dt>Returns</dt><dd>any error on </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__net__sock__udp.html#ga35b5ec6cb6a197ea2f3ab6eabacca73e" title="Provides stack-internal buffer space containing a UDP message from a remote end point. ">sock_udp_recv_buf</a> or </dd>
<dd>
<a class="el" href="group__net__sock__dtls.html#ga026748dd9ad74a8a216eaad086551a7d" title="Decrypts and provides stack-internal buffer space containing a message from a remote peer...">sock_dtls_recv_buf</a> </dd></dl>
<dl class="section return"><dt>Returns</dt><dd>any return value of <code>cb</code> for a matching response </dd></dl>

</div>
</div>
<a id="ga282ddfd4238b746dd20d4cfe4df4c244"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga282ddfd4238b746dd20d4cfe4df4c244">&#9670;&nbsp;</a></span>nanocoap_sock_url_connect()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int nanocoap_sock_url_connect </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>url</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structnanocoap__sock__t.html">nanocoap_sock_t</a> *&#160;</td>
          <td class="paramname"><em>sock</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create a CoAP client socket by URL. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">url</td><td>URL with server information to connect to </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">sock</td><td>CoAP UDP socket</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 on success </dd>
<dd>
&lt;0 on error </dd></dl>

</div>
</div>
<a id="gab2874f2dab04fafa03d79cedf7e54ae3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gab2874f2dab04fafa03d79cedf7e54ae3">&#9670;&nbsp;</a></span>nanocoap_unregister_observer()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void nanocoap_unregister_observer </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="group__net__nanocoap.html#gaedec79122f8968eb8b04e9e9360b392a">coap_request_ctx_t</a> *&#160;</td>
          <td class="paramname"><em>req_ctx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structcoap__pkt__t.html">coap_pkt_t</a> *&#160;</td>
          <td class="paramname"><em>req_pkt</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Unregister an observer. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">req_ctx</td><td>Request context belonging to <code>req_pkt</code> </td></tr>
    <tr><td class="paramname">req_pkt</td><td>Received request for unregistration</td></tr>
  </table>
  </dd>
</dl>
<dl class="section warning"><dt>Warning</dt><dd>This depends on module <code>nanocoap_server_observe</code></dd></dl>
<dl class="section note"><dt>Note</dt><dd>It is safe to call this multiple times, e.g. duplicate detection is not needed for this. </dd></dl>

</div>
</div>
<a id="ga27d7cd4c949580379d9d84f5cbfd7eeb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga27d7cd4c949580379d9d84f5cbfd7eeb">&#9670;&nbsp;</a></span>nanocoap_unregister_observer_due_to_reset()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void nanocoap_unregister_observer_due_to_reset </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="group__net__sock__udp.html#gaedc829c7973d7870c1ec078f9ffd45a1">sock_udp_ep_t</a> *&#160;</td>
          <td class="paramname"><em>ep</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>msg_id</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Unregister a stale observation due to a reset message received. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">ep</td><td>Endpoint to wipe from the observer list </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">msg_id</td><td>Message ID of the notification send. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
    <div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
        <ul>
            <li class="footer">Generated on Thu Mar 13 2025 10:38:35 by <a href="http://www.doxygen.org/index.html">
                       <img class="footer" src="doxygen.png" alt="doxygen"></a> 1.8.14</li>
        </ul>
    </div>
    <!-- Include all compiled plugins (below), or include individual files as needed -->
    <script src="bootstrap.min.js"></script>
    <script src="jquery.smartmenus.min.js"></script>
    <script src="jquery.smartmenus.bootstrap.min.js"></script>
    <script src="riot-doxy.js"></script>
  </body>
</html>
