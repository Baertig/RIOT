<!DOCTYPE html>
<html lang="en">
  <head>
    <link rel="icon" type="image/png" href="favicon.png">
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <!-- The above 3 meta tags *must* come first in the head; any other head content must come *after* these tags -->
    <title>List of Features (Features as Build System Enties)</title>
    <!-- jQuery (necessary for Bootstrap's JavaScript plugins) -->
    <script src="jquery.min.js"></script>
    <script src="jquery.powertip.min.js"></script>
    <script src="jquery-ui.min.js"></script>
    <script src="jquery.scrollTo.min.js"></script>
    <script src="doxy-jquery.js"></script>
    <script src="dynsections.js"></script>
    <link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
  $(document).ready(initResizable);
/* @license-end */</script>
    <link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
    <!-- Bootstrap -->
    <link href="doxygen.css" rel="stylesheet">
    <link href="fonts.css" rel="stylesheet">
    <link href="bootstrap.min.css" rel="stylesheet">
    <link href="jquery.smartmenus.bootstrap.css" rel="stylesheet">
    <link href="riot.css" rel="stylesheet">
    <!-- HTML5 shim and Respond.js for IE8 support of HTML5 elements and media queries -->
    <!-- WARNING: Respond.js doesn't work if you view the page via file:// -->
    <!--[if lt IE 9]>
      <script src="https://oss.maxcdn.com/html5shiv/3.7.3/html5shiv.min.js"></script>
      <script src="https://oss.maxcdn.com/respond/1.4.2/respond.min.js"></script>
    <![endif]-->
        <script>
            function displaySR(){
            searchBox.Search();
            var rhtml=(document.getElementById('MSearchResults').contentWindow.document.body.innerHTML).replace(/href=\"\.\.\//g,'href="');
            document.getElementById('MSearchResultsWindow').style.display='none';
            document.getElementById('top').append(document.getElementById('MSearchSelectWindow'));
            document.getElementById('top').append(document.getElementById('MSearchResultsWindow'));
            document.getElementById('doc-content').innerHTML=rhtml;
            }
            function modSearch(){
            if(!searchBox.doxySearch){
                searchBox.doxySearch=searchBox.Search
                searchBox.Search= function(){this.doxySearch();
                var r=document.getElementById('MSearchResultsWindow');console.log(r.style);
                if(parseInt(r.style.left)<0)r.style.left=0;
                var x=document.getElementById('MSearchResults');
                if(x.scrollWidth>window.screen.width)x.style.width=window.screen.width-2+'px';
                var f=document.getElementById('riot-searchform');
                if(parseInt( r.style.top) < f.offsetTop+f.scrollHeight) r.style.top = f.offsetTop+f.scrollHeight+'px';}
            }
            }
        </script>
  </head>
  <body>
      <div id="top">
        <nav class="navbar navbar-inverse">
          <div class="container-fluid">
            <!-- Brand and toggle get grouped for better mobile display -->
            <div class="navbar-header">
              <button type="button" class="navbar-toggle collapsed" data-toggle="collapse" data-target="#navbar-collapse" aria-expanded="false">
                <span class="sr-only">Toggle navigation</span>
                <span class="icon-bar"></span>
                <span class="icon-bar"></span>
                <span class="icon-bar"></span>
              </button>
              <a class="navbar-brand" id="brand-logo" href="http://riot-os.org"><img height="40px" src="riot-logo.svg" /></a>
              <p class="navbar-text text-center visible-xs">Documentation</p>
            </div>
            <!-- Collect the nav links, forms, and other content for toggling -->
            <div class="collapse navbar-collapse" id="navbar-collapse">
              <p class="navbar-text navbar-left"><span id="projectbrief">The friendly Operating System for the Internet of Things</span></p>
              <ul id="riot-navlist" class="nav navbar-nav"></ul>
              <form id="riot-searchform" class="navbar-form navbar-left navbar-right" action="https://duckduckgo.com/" method="get">
                 <input type="hidden" name="sites" value="doc.riot-os.org"/>
                 <input type="hidden" name="kt" value="h"/>
                 <div class="form-group">
                   <div id="MSearchBox" class="MSearchBoxActive">
                     <div class="input-group">
                       <div class="input-group-addon">
                         <span id="MSearchSelect" class="glyphicon glyphicon-search" aria-hidden="true" onmouseover="return searchBox.OnSearchSelectShow()" onmouseout="return searchBox.OnSearchSelectHide()"></span>
                       </div>
                       <input class="form-control" type="text" name="q" id="MSearchField" placeholder="Search" accesskey="S" onfocus="searchBox.OnSearchFieldFocus(true)" onblur="searchBox.OnSearchFieldFocus(false)" onkeyup="searchBox.OnSearchFieldChange(event); modSearch();">
                       <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()">
                         <span id="search-reset" class="glyphicon glyphicon-remove-circle" aria-hidden="true"></span>
                       </a>
                     </div>
                   </div>
                 </div>
              </form>
            </div><!-- /.navbar-collapse -->
          </div><!-- /.container-fluid -->
        </nav>
      </div>
<!-- Generated by Doxygen 1.8.14 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(document).ready(function(){initNavTree('feature-list.html','');});
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="headertitle">
<div class="title">List of Features (Features as Build System Enties) </div>  </div>
</div><!--header-->
<div class="contents">
<div class="toc"><h3>Table of Contents</h3>
<ul><li class="level1"><a href="#autotoc_md2354">Architecture Features</a><ul><li class="level2"><a href="#autotoc_md2355">Word size</a></li>
<li class="level2"><a href="#autotoc_md2356">Architecture grouping</a></li>
</ul>
</li>
<li class="level1"><a href="#autotoc_md2357">CPU Features</a><ul><li class="level2"><a href="#autotoc_md2358">CPU Capabilities</a><ul><li class="level3"><a href="#autotoc_md2359">Cortex M Specific Features</a><ul><li class="level4"><a href="#autotoc_md2360">nRF Capabilities</a></li>
</ul>
</li>
<li class="level3"><a href="#autotoc_md2361">AVR-8 Specific Features</a><ul><li class="level4"><a href="#autotoc_md2362">ATmega Specific Features</a></li>
<li class="level4"><a href="#autotoc_md2363">ATxmega Specific Features</a></li>
</ul>
</li>
<li class="level3"><a href="#autotoc_md2364">EFM32 Specific Features</a></li>
<li class="level3"><a href="#autotoc_md2365">ESP Specific Features</a></li>
<li class="level3"><a href="#autotoc_md2366">nordic nRF Specific Features</a></li>
</ul>
</li>
<li class="level2"><a href="#autotoc_md2367">CPU Grouping</a><ul><li class="level3"><a href="#autotoc_md2368">Atmel / Microchip AVR-8 Grouping</a><ul><li class="level4"><a href="#autotoc_md2369">ATmega Grouping</a></li>
<li class="level4"><a href="#autotoc_md2370">ATxmega Grouping</a></li>
</ul>
</li>
<li class="level3"><a href="#autotoc_md2371">ARM Cortex-M and Classic ARM Grouping</a><ul><li class="level4"><a href="#autotoc_md2372">Atmel / Microchip SAM Grouping</a></li>
<li class="level4"><a href="#autotoc_md2376">GigaDevice Semiconductor Inc Grouping</a></li>
<li class="level4"><a href="#autotoc_md2377">nordic nRF Grouping</a></li>
<li class="level4"><a href="#autotoc_md2378">NXP Grouping</a></li>
<li class="level4"><a href="#autotoc_md2379">Nintendo Grouping</a></li>
<li class="level4"><a href="#autotoc_md2380">Raspberry Pi Grouping</a></li>
<li class="level4"><a href="#autotoc_md2381">Silicon Laboratories EFM32 Grouping</a></li>
<li class="level4"><a href="#autotoc_md2382">SiFive, Inc. Grouping</a></li>
<li class="level4"><a href="#autotoc_md2383">STMicroelectronics STM32 Grouping</a></li>
<li class="level4"><a href="#autotoc_md2384">Texas Instruments ARM MCU Grouping</a></li>
</ul>
</li>
<li class="level3"><a href="#autotoc_md2385">Expressif ESP Grouping</a></li>
<li class="level3"><a href="#autotoc_md2386">Texas Instruments MSP430 MCU Grouping</a></li>
</ul>
</li>
</ul>
</li>
<li class="level1"><a href="#autotoc_md2387">Arduino Features</a><ul><li class="level2"><a href="#autotoc_md2388">Arduino I/O Mapping Features</a></li>
<li class="level2"><a href="#autotoc_md2389">Arduino Form Factor Features</a></li>
</ul>
</li>
<li class="level1"><a href="#autotoc_md2390">RAM Related Features</a></li>
<li class="level1"><a href="#autotoc_md2391">Bluetooth Low Energy Features</a></li>
<li class="level1"><a href="#autotoc_md2392">Toolchain Features</a></li>
<li class="level1"><a href="#autotoc_md2393">Peripheral Features</a><ul><li class="level2"><a href="#autotoc_md2394">General-Purpose Input/Output (GPIO)</a><ul><li class="level3"><a href="#autotoc_md2395">Pin Level Peripheral GPIO API</a></li>
<li class="level3"><a href="#autotoc_md2396">GPIO LL API</a></li>
</ul>
</li>
<li class="level2"><a href="#autotoc_md2397">Serial Interfaces</a><ul><li class="level3"><a href="#autotoc_md2398">UART Features</a></li>
<li class="level3"><a href="#autotoc_md2399">SPI Features</a></li>
<li class="level3"><a href="#autotoc_md2400">I²C Features</a></li>
<li class="level3"><a href="#autotoc_md2401">USB Features</a></li>
</ul>
</li>
<li class="level2"><a href="#autotoc_md2402">Analog Features</a></li>
<li class="level2"><a href="#autotoc_md2403">Integrated Connectivity</a></li>
<li class="level2"><a href="#autotoc_md2404">SD / MMC Card Features</a></li>
<li class="level2"><a href="#autotoc_md2405">Flash Features</a></li>
<li class="level2"><a href="#autotoc_md2406">Other Peripheral Storage Features</a></li>
<li class="level2"><a href="#autotoc_md2407">Timer Features</a><ul><li class="level3"><a href="#autotoc_md2408">High Frequency Timers</a></li>
<li class="level3"><a href="#autotoc_md2409">PTP Timers</a></li>
</ul>
</li>
<li class="level2"><a href="#autotoc_md2410">Platform Specific</a></li>
<li class="level2"><a href="#autotoc_md2411">Cryptographic Features</a></li>
</ul>
</li>
<li class="level1"><a href="#autotoc_md2412">Other Features</a></li>
<li class="level1"><a href="#autotoc_md2413">Board Features</a><ul><li class="level2"><a href="#autotoc_md2414">STM32L496G Discovery Board Features</a></li>
</ul>
</li>
</ul>
</div>
<div class="textblock"><h1><a class="anchor" id="autotoc_md2354"></a>
Architecture Features</h1>
<p>These indicate architecture features, such as word size of the CPU, supported instruction sets and so on. All architecture features provided by a given board will always be used, e.g. an 8-bit CPU cannot just stop being an 8-bit CPU on request.</p>
<h2><a class="anchor" id="autotoc_md2355"></a>
Word size</h2>
<p>Word size of the CPU</p>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadLeft">Feature  </th><th class="markdownTableHeadLeft">Description   </th></tr>
<tr class="markdownTableBody" class="markdownTableRowOdd">
<td class="markdownTableBodyLeft"><code>arch_8bit</code>  </td><td class="markdownTableBodyLeft">CPU has a 8-bits architecture   </td></tr>
<tr class="markdownTableBody" class="markdownTableRowEven">
<td class="markdownTableBodyLeft"><code>arch_16bit</code>  </td><td class="markdownTableBodyLeft">CPU has a 16-bits architecture   </td></tr>
<tr class="markdownTableBody" class="markdownTableRowOdd">
<td class="markdownTableBodyLeft"><code>arch_32bit</code>  </td><td class="markdownTableBodyLeft">CPU has a 32-bits architecture   </td></tr>
<tr class="markdownTableBody" class="markdownTableRowEven">
<td class="markdownTableBodyLeft"><code>arch_64bit</code>  </td><td class="markdownTableBodyLeft">CPU has a 64-bits architecture   </td></tr>
</table>
<h2><a class="anchor" id="autotoc_md2356"></a>
Architecture grouping</h2>
<p>Instruction set of the CPU</p>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadLeft">Feature  </th><th class="markdownTableHeadLeft">Description   </th></tr>
<tr class="markdownTableBody" class="markdownTableRowOdd">
<td class="markdownTableBodyLeft"><code>arch_arm</code>  </td><td class="markdownTableBodyLeft">CPU architecture is classic ARM or Cortex M   </td></tr>
<tr class="markdownTableBody" class="markdownTableRowEven">
<td class="markdownTableBodyLeft"><code>arch_arm7</code>  </td><td class="markdownTableBodyLeft">CPU architecture is classic ARM (ARM7)   </td></tr>
<tr class="markdownTableBody" class="markdownTableRowOdd">
<td class="markdownTableBodyLeft"><code>arch_avr8</code>  </td><td class="markdownTableBodyLeft">CPU architecture is AVR-8   </td></tr>
<tr class="markdownTableBody" class="markdownTableRowEven">
<td class="markdownTableBodyLeft"><code>arch_efm32</code>  </td><td class="markdownTableBodyLeft">FIXME. This is not an architecture. Use cpu_efm32 for this   </td></tr>
<tr class="markdownTableBody" class="markdownTableRowOdd">
<td class="markdownTableBodyLeft"><code>arch_esp</code>  </td><td class="markdownTableBodyLeft">CPU architecture is an ESP. (Fixme: This is not an architecture)   </td></tr>
<tr class="markdownTableBody" class="markdownTableRowEven">
<td class="markdownTableBodyLeft"><code>arch_esp_xtensa</code>  </td><td class="markdownTableBodyLeft">CPU architecture is Xtensa   </td></tr>
<tr class="markdownTableBody" class="markdownTableRowOdd">
<td class="markdownTableBodyLeft"><code>arch_esp_riscv</code>  </td><td class="markdownTableBodyLeft">CPU architecture is RISC-V (ESP flavor)   </td></tr>
<tr class="markdownTableBody" class="markdownTableRowEven">
<td class="markdownTableBodyLeft"><code>arch_esp32</code>  </td><td class="markdownTableBodyLeft">CPU architecture is an ESP32. (Fixme: This is not an architecture)   </td></tr>
<tr class="markdownTableBody" class="markdownTableRowOdd">
<td class="markdownTableBodyLeft"><code>arch_esp32_xtensa</code>  </td><td class="markdownTableBodyLeft">CPU architecture is Xtensa (ESP32 flavor)   </td></tr>
<tr class="markdownTableBody" class="markdownTableRowEven">
<td class="markdownTableBodyLeft"><code>arch_esp8266</code>  </td><td class="markdownTableBodyLeft">CPU architecture is Xtensa (ESP8266 flavor)   </td></tr>
<tr class="markdownTableBody" class="markdownTableRowOdd">
<td class="markdownTableBodyLeft"><code>arch_msp430</code>  </td><td class="markdownTableBodyLeft">CPU architecture is MSP430   </td></tr>
<tr class="markdownTableBody" class="markdownTableRowEven">
<td class="markdownTableBodyLeft"><code>arch_native</code>  </td><td class="markdownTableBodyLeft">CPU architecture is <code>native</code>   </td></tr>
<tr class="markdownTableBody" class="markdownTableRowOdd">
<td class="markdownTableBodyLeft"><code>arch_riscv</code>  </td><td class="markdownTableBodyLeft">CPU architecture is RISC-V   </td></tr>
<tr class="markdownTableBody" class="markdownTableRowEven">
<td class="markdownTableBodyLeft"><code>arch_nuclei</code>  </td><td class="markdownTableBodyLeft">The CPU is based on a Nuclei System Technology design. Hence, RIOT is using the Nuclei Microcontroller Software Interface Standard (NMSIS) vendor independent hardware abstraction layer.   </td></tr>
</table>
<h1><a class="anchor" id="autotoc_md2357"></a>
CPU Features</h1>
<p>These features are related to CPU capabilities or just used to indicated which CPU family is used.</p>
<h2><a class="anchor" id="autotoc_md2358"></a>
CPU Capabilities</h2>
<p>These correspond to features/capabilities provided by certain CPUs</p>
<h3><a class="anchor" id="autotoc_md2359"></a>
Cortex M Specific Features</h3>
<p>These features are only available on (some) ARM Cortex M MCUs</p>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadLeft">Feature  </th><th class="markdownTableHeadLeft">Description   </th></tr>
<tr class="markdownTableBody" class="markdownTableRowOdd">
<td class="markdownTableBodyLeft"><code>cpu_check_address</code>  </td><td class="markdownTableBodyLeft">The <a class="el" href="group__cpu__cortexm__common.html#gac30423f9a6d611b7b7d0190a8d6dd6e2">cpu_check_address</a> can be used to check if accessing a given address would cause a bus fault.   </td></tr>
<tr class="markdownTableBody" class="markdownTableRowEven">
<td class="markdownTableBodyLeft"><code>cortexm_stack_limit</code>  </td><td class="markdownTableBodyLeft">ARM Cortex-M PSPLIM/MSPLIM registers are available.   </td></tr>
<tr class="markdownTableBody" class="markdownTableRowOdd">
<td class="markdownTableBodyLeft"><code>cortexm_svc</code>  </td><td class="markdownTableBodyLeft">ARM Cortex-M Supervisor Calls are available.   </td></tr>
<tr class="markdownTableBody" class="markdownTableRowEven">
<td class="markdownTableBodyLeft"><code>cortexm_fpu</code>  </td><td class="markdownTableBodyLeft">A hardware floating point unit is available.   </td></tr>
<tr class="markdownTableBody" class="markdownTableRowOdd">
<td class="markdownTableBodyLeft"><code>cortexm_mpu</code>  </td><td class="markdownTableBodyLeft">A memory protection unit (MPU) is available.   </td></tr>
</table>
<h4><a class="anchor" id="autotoc_md2360"></a>
nRF Capabilities</h4>
<p>These features are only available on (some) nordic nRF MCUs</p>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadLeft">Feature  </th><th class="markdownTableHeadLeft">Description   </th></tr>
<tr class="markdownTableBody" class="markdownTableRowOdd">
<td class="markdownTableBodyLeft"><code>vdd_lc_filter_reg1</code>  </td><td class="markdownTableBodyLeft">An LC filter for use with the internal DC/DC converter is present. If this is the case, the DC/DC converter is used over the LDO regulator for improved power efficiency.   </td></tr>
<tr class="markdownTableBody" class="markdownTableRowEven">
<td class="markdownTableBodyLeft"><code>vdd_lc_filter_reg0</code>  </td><td class="markdownTableBodyLeft">The MCU supports a high voltage supply via an two-stage regulator and the board has an LC filter required for using the two-stage DC/DC converter. This enables the two-stage DC/DC converter.   </td></tr>
</table>
<h3><a class="anchor" id="autotoc_md2361"></a>
AVR-8 Specific Features</h3>
<h4><a class="anchor" id="autotoc_md2362"></a>
ATmega Specific Features</h4>
<p>These features are only available on (some) ATmega MCUs.</p>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadLeft">Feature  </th><th class="markdownTableHeadLeft">Description   </th></tr>
<tr class="markdownTableBody" class="markdownTableRowOdd">
<td class="markdownTableBodyLeft"><code>atmega_pcint0</code>  </td><td class="markdownTableBodyLeft">Required pin-mapping for pin change interrupt on bank 0 is available. See section on pin change interrupts in <a class="el" href="group__cpu__atmega__common.html">Atmel ATmega CPU: common files</a>   </td></tr>
<tr class="markdownTableBody" class="markdownTableRowEven">
<td class="markdownTableBodyLeft"><code>atmega_pcint1</code>  </td><td class="markdownTableBodyLeft">Required pin-mapping for pin change interrupt on bank 1 is available. See section on pin change interrupts in <a class="el" href="group__cpu__atmega__common.html">Atmel ATmega CPU: common files</a>   </td></tr>
<tr class="markdownTableBody" class="markdownTableRowOdd">
<td class="markdownTableBodyLeft"><code>atmega_pcint2</code>  </td><td class="markdownTableBodyLeft">Required pin-mapping for pin change interrupt on bank 2 is available. See section on pin change interrupts in <a class="el" href="group__cpu__atmega__common.html">Atmel ATmega CPU: common files</a>   </td></tr>
<tr class="markdownTableBody" class="markdownTableRowEven">
<td class="markdownTableBodyLeft"><code>atmega_pcint3</code>  </td><td class="markdownTableBodyLeft">Required pin-mapping for pin change interrupt on bank 3 is available. See section on pin change interrupts in <a class="el" href="group__cpu__atmega__common.html">Atmel ATmega CPU: common files</a>   </td></tr>
</table>
<h4><a class="anchor" id="autotoc_md2363"></a>
ATxmega Specific Features</h4>
<p>These features are only available on (some) ATxmega MCUs.</p>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadLeft">Feature  </th><th class="markdownTableHeadLeft">Description   </th></tr>
<tr class="markdownTableBody" class="markdownTableRowOdd">
<td class="markdownTableBodyLeft"><code>atxmega_ebi</code>  </td><td class="markdownTableBodyLeft">MCU supports the external bus interface (EBI) to either extend RAM with external RAM or attach memory mapped peripherals such as (some) displays.   </td></tr>
</table>
<h3><a class="anchor" id="autotoc_md2364"></a>
EFM32 Specific Features</h3>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadLeft">Feature  </th><th class="markdownTableHeadLeft">Description   </th></tr>
<tr class="markdownTableBody" class="markdownTableRowOdd">
<td class="markdownTableBodyLeft"><code>efm32_coretemp</code>  </td><td class="markdownTableBodyLeft">Y R U not using <code>periph_temperature</code> for this?   </td></tr>
<tr class="markdownTableBody" class="markdownTableRowEven">
<td class="markdownTableBodyLeft"><code>gecko_sdk_librail_nonfpu</code>  </td><td class="markdownTableBodyLeft">The CPU offers librail support if the FPU is disabled. Librail is shipped as pre-compiled blobs. Thus, we have to adapt to their choice how to process floats.   </td></tr>
<tr class="markdownTableBody" class="markdownTableRowOdd">
<td class="markdownTableBodyLeft"><code>gecko_sdk_librail_fpu</code>  </td><td class="markdownTableBodyLeft">The CPU offers librail support if the FPU is enabled. Librail is shipped as pre-compiled blobs. Thus, we have to adapt to their choice how to process floats.   </td></tr>
</table>
<h3><a class="anchor" id="autotoc_md2365"></a>
ESP Specific Features</h3>
<p>These features are only available on (some) ESP MCUs.</p>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadLeft">Feature  </th><th class="markdownTableHeadLeft">Description   </th></tr>
<tr class="markdownTableBody" class="markdownTableRowOdd">
<td class="markdownTableBodyLeft"><code>esp_jtag</code>  </td><td class="markdownTableBodyLeft">The MCU supports JTAG for programming and debugging. Enable this feature to expose the interface at the cost of having fewer pins as GPIOs available.   </td></tr>
<tr class="markdownTableBody" class="markdownTableRowEven">
<td class="markdownTableBodyLeft"><code>esp_now</code>  </td><td class="markdownTableBodyLeft">An ESP NOW-compatible radio is present.   </td></tr>
<tr class="markdownTableBody" class="markdownTableRowOdd">
<td class="markdownTableBodyLeft"><code>esp_spiffs</code>  </td><td class="markdownTableBodyLeft">A Serial Peripheral Interface Flash File System can be used.   </td></tr>
<tr class="markdownTableBody" class="markdownTableRowEven">
<td class="markdownTableBodyLeft"><code>esp_wifi</code>  </td><td class="markdownTableBodyLeft">An ESP WiFi radio is present.   </td></tr>
<tr class="markdownTableBody" class="markdownTableRowOdd">
<td class="markdownTableBodyLeft"><code>esp_wifi_ap</code>  </td><td class="markdownTableBodyLeft">ESP WiFi SoftAP support is present.   </td></tr>
<tr class="markdownTableBody" class="markdownTableRowEven">
<td class="markdownTableBodyLeft"><code>esp_wifi_enterprise</code>  </td><td class="markdownTableBodyLeft">The ESP WiFi interface supports WPA2 enterprise mode.   </td></tr>
<tr class="markdownTableBody" class="markdownTableRowOdd">
<td class="markdownTableBodyLeft"><code>esp_ble_esp32</code>  </td><td class="markdownTableBodyLeft">The ESP32x SoC uses the SDK Bluetooth LE library for the ESP32 variant.   </td></tr>
<tr class="markdownTableBody" class="markdownTableRowEven">
<td class="markdownTableBodyLeft"><code>esp_ble_esp32c3</code>  </td><td class="markdownTableBodyLeft">The ESP32x SoC uses the SDK Bluetooth LE library for the ESP32-C3 or ESP32-S3 variant.   </td></tr>
<tr class="markdownTableBody" class="markdownTableRowOdd">
<td class="markdownTableBodyLeft"><code>esp_hw_counter</code>  </td><td class="markdownTableBodyLeft">The used ESP32x SoC supports HW counters that can be used as timers.   </td></tr>
<tr class="markdownTableBody" class="markdownTableRowEven">
<td class="markdownTableBodyLeft"><code>esp_rmt</code>  </td><td class="markdownTableBodyLeft">The ESP32x SoC has an RMT (Remote Control Transceiver) peripheral.   </td></tr>
<tr class="markdownTableBody" class="markdownTableRowOdd">
<td class="markdownTableBodyLeft"><code>esp_rtc_timer_32k</code>  </td><td class="markdownTableBodyLeft">An external 32.768 kHz crystal is connected to the ESP32x Soc on the board.   </td></tr>
<tr class="markdownTableBody" class="markdownTableRowEven">
<td class="markdownTableBodyLeft"><code>esp_spi_ram</code>  </td><td class="markdownTableBodyLeft">An external RAM is connected via the SPI interface to the ESP32x SoC on the board.   </td></tr>
<tr class="markdownTableBody" class="markdownTableRowOdd">
<td class="markdownTableBodyLeft"><code>esp_spi_oct</code>  </td><td class="markdownTableBodyLeft">Octal SPI mode is used for Flash and SPI RAM. In this case additional GPIOs are used for the SPI interface and cannot be used for other purposes.   </td></tr>
<tr class="markdownTableBody" class="markdownTableRowEven">
<td class="markdownTableBodyLeft"><code>esp_ble</code>  </td><td class="markdownTableBodyLeft">An ESP32 Bluetooth LE transceiver is present.   </td></tr>
</table>
<h3><a class="anchor" id="autotoc_md2366"></a>
nordic nRF Specific Features</h3>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadLeft">Feature  </th><th class="markdownTableHeadLeft">Description   </th></tr>
<tr class="markdownTableBody" class="markdownTableRowOdd">
<td class="markdownTableBodyLeft"><code>radio_nrf802154</code>  </td><td class="markdownTableBodyLeft">An nRF MCU with a peripheral radio that supports IEEE 802.15.4 is present.   </td></tr>
<tr class="markdownTableBody" class="markdownTableRowEven">
<td class="markdownTableBodyLeft"><code>radio_nrfble</code>  </td><td class="markdownTableBodyLeft">An nRF MCU with a peripheral radio that supports Bluetooth LE is present.   </td></tr>
<tr class="markdownTableBody" class="markdownTableRowOdd">
<td class="markdownTableBodyLeft"><code>radio_nrfmin</code>  </td><td class="markdownTableBodyLeft">An nRF MCU with a peripheral radio that supports nordics proprietary link layer protocol is present.   </td></tr>
</table>
<h2><a class="anchor" id="autotoc_md2367"></a>
CPU Grouping</h2>
<p>These are not actually features/capabilities, but just indicate to which CPU family a certain CPU belongs</p>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadLeft">Feature  </th><th class="markdownTableHeadLeft">Description   </th></tr>
<tr class="markdownTableBody" class="markdownTableRowOdd">
<td class="markdownTableBodyLeft"><code>cpu_native</code>  </td><td class="markdownTableBodyLeft">The board is simulated by a native program running on the host   </td></tr>
</table>
<h3><a class="anchor" id="autotoc_md2368"></a>
Atmel / Microchip AVR-8 Grouping</h3>
<h4><a class="anchor" id="autotoc_md2369"></a>
ATmega Grouping</h4>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadLeft">Feature  </th><th class="markdownTableHeadLeft">Description   </th></tr>
<tr class="markdownTableBody" class="markdownTableRowOdd">
<td class="markdownTableBodyLeft"><code>cpu_core_atmega</code>  </td><td class="markdownTableBodyLeft">The MCU has an ATmega CPU   </td></tr>
<tr class="markdownTableBody" class="markdownTableRowEven">
<td class="markdownTableBodyLeft"><code>cpu_atmega8</code>  </td><td class="markdownTableBodyLeft">The MCU is an ATmega8   </td></tr>
<tr class="markdownTableBody" class="markdownTableRowOdd">
<td class="markdownTableBodyLeft"><code>cpu_atmega32u4</code>  </td><td class="markdownTableBodyLeft">The MCU is an ATmega32U4   </td></tr>
<tr class="markdownTableBody" class="markdownTableRowEven">
<td class="markdownTableBodyLeft"><code>cpu_atmega128rfa1</code>  </td><td class="markdownTableBodyLeft">The MCU is an ATmega128RFA1   </td></tr>
<tr class="markdownTableBody" class="markdownTableRowOdd">
<td class="markdownTableBodyLeft"><code>cpu_atmega256rfr2</code>  </td><td class="markdownTableBodyLeft">The MCU is an ATmega256RFR2   </td></tr>
<tr class="markdownTableBody" class="markdownTableRowEven">
<td class="markdownTableBodyLeft"><code>cpu_atmega328p</code>  </td><td class="markdownTableBodyLeft">The MCU is an ATmega328P   </td></tr>
<tr class="markdownTableBody" class="markdownTableRowOdd">
<td class="markdownTableBodyLeft"><code>cpu_atmega1281</code>  </td><td class="markdownTableBodyLeft">The MCU is an ATmega1281   </td></tr>
<tr class="markdownTableBody" class="markdownTableRowEven">
<td class="markdownTableBodyLeft"><code>cpu_atmega1284p</code>  </td><td class="markdownTableBodyLeft">The MCU is an ATmega1284P   </td></tr>
<tr class="markdownTableBody" class="markdownTableRowOdd">
<td class="markdownTableBodyLeft"><code>cpu_atmega2560</code>  </td><td class="markdownTableBodyLeft">The MCU is an ATmega2560   </td></tr>
</table>
<h4><a class="anchor" id="autotoc_md2370"></a>
ATxmega Grouping</h4>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadLeft">Feature  </th><th class="markdownTableHeadLeft">Description   </th></tr>
<tr class="markdownTableBody" class="markdownTableRowOdd">
<td class="markdownTableBodyLeft"><code>cpu_core_atxmega</code>  </td><td class="markdownTableBodyLeft">The MCU has an ATxmega CPU   </td></tr>
<tr class="markdownTableBody" class="markdownTableRowEven">
<td class="markdownTableBodyLeft"><code>cpu_atxmega</code>  </td><td class="markdownTableBodyLeft">The MCU is an ATxmega XYZ CPU   </td></tr>
</table>
<h3><a class="anchor" id="autotoc_md2371"></a>
ARM Cortex-M and Classic ARM Grouping</h3>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadLeft">Feature  </th><th class="markdownTableHeadLeft">Description   </th></tr>
<tr class="markdownTableBody" class="markdownTableRowOdd">
<td class="markdownTableBodyLeft"><code>cpu_core_cortexm</code>  </td><td class="markdownTableBodyLeft">The MCU has an ARM Cortex-M CPU (any family)   </td></tr>
<tr class="markdownTableBody" class="markdownTableRowEven">
<td class="markdownTableBodyLeft"><code>cpu_stm32</code>  </td><td class="markdownTableBodyLeft">The MCU has an STM32 MCU   </td></tr>
</table>
<h4><a class="anchor" id="autotoc_md2372"></a>
Atmel / Microchip SAM Grouping</h4>
<p><a class="anchor" id="invalid"></a></p><h5>SAM0 Grouping</h5>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadLeft">Feature  </th><th class="markdownTableHeadLeft">Description   </th></tr>
<tr class="markdownTableBody" class="markdownTableRowOdd">
<td class="markdownTableBodyLeft"><code>cpu_samd21</code>  </td><td class="markdownTableBodyLeft">The MCU has an Atmel/Microchip SAM D10/D11/D20/D21 CPU   </td></tr>
<tr class="markdownTableBody" class="markdownTableRowEven">
<td class="markdownTableBodyLeft"><code>cpu_samd5x</code>  </td><td class="markdownTableBodyLeft">The MCU has an Atmel/Microchip SAM D5x CPU   </td></tr>
<tr class="markdownTableBody" class="markdownTableRowOdd">
<td class="markdownTableBodyLeft"><code>cpu_saml1x</code>  </td><td class="markdownTableBodyLeft">The MCU has an Atmel/Microchip SAM L1x CPU   </td></tr>
<tr class="markdownTableBody" class="markdownTableRowEven">
<td class="markdownTableBodyLeft"><code>cpu_saml21</code>  </td><td class="markdownTableBodyLeft">The MCU has an Atmel/Microchip SAM L2x / L3x CPU   </td></tr>
</table>
<p><a class="anchor" id="invalid"></a></p><h5>SAM3 Grouping</h5>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadLeft">Feature  </th><th class="markdownTableHeadLeft">Description   </th></tr>
<tr class="markdownTableBody" class="markdownTableRowOdd">
<td class="markdownTableBodyLeft"><code>cpu_sam3</code>  </td><td class="markdownTableBodyLeft">The MCU has an Atmel/Microchip SAM 3 CPU   </td></tr>
</table>
<p><a class="anchor" id="invalid"></a></p><h5>SAM4S Grouping</h5>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadLeft">Feature  </th><th class="markdownTableHeadLeft">Description   </th></tr>
<tr class="markdownTableBody" class="markdownTableRowOdd">
<td class="markdownTableBodyLeft"><code>cpu_sam4s</code>  </td><td class="markdownTableBodyLeft">The MCU has an Atmel/Microchip SAM 4S CPU   </td></tr>
</table>
<h4><a class="anchor" id="autotoc_md2376"></a>
GigaDevice Semiconductor Inc Grouping</h4>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadLeft">Feature  </th><th class="markdownTableHeadLeft">Description   </th></tr>
<tr class="markdownTableBody" class="markdownTableRowOdd">
<td class="markdownTableBodyLeft"><code>cpu_gd32v</code>  </td><td class="markdownTableBodyLeft">The MCU is part of the GigaDevice GD32V family   </td></tr>
</table>
<h4><a class="anchor" id="autotoc_md2377"></a>
nordic nRF Grouping</h4>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadLeft">Feature  </th><th class="markdownTableHeadLeft">Description   </th></tr>
<tr class="markdownTableBody" class="markdownTableRowOdd">
<td class="markdownTableBodyLeft"><code>cpu_nrf51</code>  </td><td class="markdownTableBodyLeft">The MCU has an nordic nRF51 CPU   </td></tr>
<tr class="markdownTableBody" class="markdownTableRowEven">
<td class="markdownTableBodyLeft"><code>cpu_nrf52</code>  </td><td class="markdownTableBodyLeft">The MCU has an nordic nRF52 CPU   </td></tr>
<tr class="markdownTableBody" class="markdownTableRowOdd">
<td class="markdownTableBodyLeft"><code>cpu_nrf53</code>  </td><td class="markdownTableBodyLeft">The MCU has an nordic nRF53 CPU   </td></tr>
<tr class="markdownTableBody" class="markdownTableRowEven">
<td class="markdownTableBodyLeft"><code>cpu_nrf9160</code>  </td><td class="markdownTableBodyLeft">The MCU has an nordic nRF9160 CPU   </td></tr>
</table>
<h4><a class="anchor" id="autotoc_md2378"></a>
NXP Grouping</h4>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadLeft">Feature  </th><th class="markdownTableHeadLeft">Description   </th></tr>
<tr class="markdownTableBody" class="markdownTableRowOdd">
<td class="markdownTableBodyLeft"><code>cpu_kinetis</code>  </td><td class="markdownTableBodyLeft">The MCU is part of the NXP Kinetis family   </td></tr>
<tr class="markdownTableBody" class="markdownTableRowEven">
<td class="markdownTableBodyLeft"><code>cpu_lpc1768</code>  </td><td class="markdownTableBodyLeft">The MCU is an NXP LPC1768   </td></tr>
<tr class="markdownTableBody" class="markdownTableRowOdd">
<td class="markdownTableBodyLeft"><code>cpu_lpc23xx</code>  </td><td class="markdownTableBodyLeft">The MCU is part of the NXP LPC23xx classic ARM family   </td></tr>
<tr class="markdownTableBody" class="markdownTableRowEven">
<td class="markdownTableBodyLeft"><code>cpu_qn908x</code>  </td><td class="markdownTableBodyLeft">The MCU is part of the NXP QN908x family   </td></tr>
</table>
<h4><a class="anchor" id="autotoc_md2379"></a>
Nintendo Grouping</h4>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadLeft">Feature  </th><th class="markdownTableHeadLeft">Description   </th></tr>
<tr class="markdownTableBody" class="markdownTableRowOdd">
<td class="markdownTableBodyLeft"><code>cpu_arm7tdmi_gba</code>  </td><td class="markdownTableBodyLeft">The MCU of the Game Boy Advance.   </td></tr>
</table>
<h4><a class="anchor" id="autotoc_md2380"></a>
Raspberry Pi Grouping</h4>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadLeft">Feature  </th><th class="markdownTableHeadLeft">Description   </th></tr>
<tr class="markdownTableBody" class="markdownTableRowOdd">
<td class="markdownTableBodyLeft"><code>cpu_rpx0xx</code>  </td><td class="markdownTableBodyLeft">The MCU is part of the Raspberry PI RPx0xx family.   </td></tr>
</table>
<h4><a class="anchor" id="autotoc_md2381"></a>
Silicon Laboratories EFM32 Grouping</h4>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadLeft">Feature  </th><th class="markdownTableHeadLeft">Description   </th></tr>
<tr class="markdownTableBody" class="markdownTableRowOdd">
<td class="markdownTableBodyLeft"><code>cpu_efm32</code>  </td><td class="markdownTableBodyLeft">The MCU is part of the Silicon Labs EFM32 family   </td></tr>
</table>
<h4><a class="anchor" id="autotoc_md2382"></a>
SiFive, Inc. Grouping</h4>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadLeft">Feature  </th><th class="markdownTableHeadLeft">Description   </th></tr>
<tr class="markdownTableBody" class="markdownTableRowOdd">
<td class="markdownTableBodyLeft"><code>cpu_fe310</code>  </td><td class="markdownTableBodyLeft">The MCU is in SiFive Freedom E310   </td></tr>
</table>
<h4><a class="anchor" id="autotoc_md2383"></a>
STMicroelectronics STM32 Grouping</h4>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadLeft">Feature  </th><th class="markdownTableHeadLeft">Description   </th></tr>
<tr class="markdownTableBody" class="markdownTableRowOdd">
<td class="markdownTableBodyLeft"><code>cpu_stm32c0</code>  </td><td class="markdownTableBodyLeft">The MCU has an STM32 C0 MCU   </td></tr>
<tr class="markdownTableBody" class="markdownTableRowEven">
<td class="markdownTableBodyLeft"><code>cpu_stm32f0</code>  </td><td class="markdownTableBodyLeft">The MCU has an STM32 F0 MCU   </td></tr>
<tr class="markdownTableBody" class="markdownTableRowOdd">
<td class="markdownTableBodyLeft"><code>cpu_stm32f1</code>  </td><td class="markdownTableBodyLeft">The MCU has an STM32 F1 MCU   </td></tr>
<tr class="markdownTableBody" class="markdownTableRowEven">
<td class="markdownTableBodyLeft"><code>cpu_stm32f2</code>  </td><td class="markdownTableBodyLeft">The MCU has an STM32 F2 MCU   </td></tr>
<tr class="markdownTableBody" class="markdownTableRowOdd">
<td class="markdownTableBodyLeft"><code>cpu_stm32f3</code>  </td><td class="markdownTableBodyLeft">The MCU has an STM32 F3 MCU   </td></tr>
<tr class="markdownTableBody" class="markdownTableRowEven">
<td class="markdownTableBodyLeft"><code>cpu_stm32f4</code>  </td><td class="markdownTableBodyLeft">The MCU has an STM32 F4 MCU   </td></tr>
<tr class="markdownTableBody" class="markdownTableRowOdd">
<td class="markdownTableBodyLeft"><code>cpu_stm32f7</code>  </td><td class="markdownTableBodyLeft">The MCU has an STM32 F7 MCU   </td></tr>
<tr class="markdownTableBody" class="markdownTableRowEven">
<td class="markdownTableBodyLeft"><code>cpu_stm32g0</code>  </td><td class="markdownTableBodyLeft">The MCU has an STM32 G0 MCU   </td></tr>
<tr class="markdownTableBody" class="markdownTableRowOdd">
<td class="markdownTableBodyLeft"><code>cpu_stm32g4</code>  </td><td class="markdownTableBodyLeft">The MCU has an STM32 G4 MCU   </td></tr>
<tr class="markdownTableBody" class="markdownTableRowEven">
<td class="markdownTableBodyLeft"><code>cpu_stm32l0</code>  </td><td class="markdownTableBodyLeft">The MCU has an STM32 L0 MCU   </td></tr>
<tr class="markdownTableBody" class="markdownTableRowOdd">
<td class="markdownTableBodyLeft"><code>cpu_stm32l1</code>  </td><td class="markdownTableBodyLeft">The MCU has an STM32 L1 MCU   </td></tr>
<tr class="markdownTableBody" class="markdownTableRowEven">
<td class="markdownTableBodyLeft"><code>cpu_stm32l4</code>  </td><td class="markdownTableBodyLeft">The MCU has an STM32 L4 MCU   </td></tr>
<tr class="markdownTableBody" class="markdownTableRowOdd">
<td class="markdownTableBodyLeft"><code>cpu_stm32l5</code>  </td><td class="markdownTableBodyLeft">The MCU has an STM32 L5 MCU   </td></tr>
<tr class="markdownTableBody" class="markdownTableRowEven">
<td class="markdownTableBodyLeft"><code>cpu_stm32mp1</code>  </td><td class="markdownTableBodyLeft">The MCU has an STM32 MP1 MCU   </td></tr>
<tr class="markdownTableBody" class="markdownTableRowOdd">
<td class="markdownTableBodyLeft"><code>cpu_stm32u5</code>  </td><td class="markdownTableBodyLeft">The MCU has an STM32 U5 MCU   </td></tr>
<tr class="markdownTableBody" class="markdownTableRowEven">
<td class="markdownTableBodyLeft"><code>cpu_stm32wb</code>  </td><td class="markdownTableBodyLeft">The MCU has an STM32 WB MCU   </td></tr>
<tr class="markdownTableBody" class="markdownTableRowOdd">
<td class="markdownTableBodyLeft"><code>cpu_stm32wl</code>  </td><td class="markdownTableBodyLeft">The MCU has an STM32 WL MCU   </td></tr>
</table>
<h4><a class="anchor" id="autotoc_md2384"></a>
Texas Instruments ARM MCU Grouping</h4>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadLeft">Feature  </th><th class="markdownTableHeadLeft">Description   </th></tr>
<tr class="markdownTableBody" class="markdownTableRowOdd">
<td class="markdownTableBodyLeft"><code>cpu_cc26x2_cc13x2</code>  </td><td class="markdownTableBodyLeft">The CPU in an TI CC26x2 or an TI CC13x2   </td></tr>
<tr class="markdownTableBody" class="markdownTableRowEven">
<td class="markdownTableBodyLeft"><code>cpu_cc26x0_cc13x0</code>  </td><td class="markdownTableBodyLeft">The CPU in an TI CC26x0 or an TI CC13x0   </td></tr>
<tr class="markdownTableBody" class="markdownTableRowOdd">
<td class="markdownTableBodyLeft"><code>cpu_cc2538</code>  </td><td class="markdownTableBodyLeft">The CPU in an TI CC2538   </td></tr>
<tr class="markdownTableBody" class="markdownTableRowEven">
<td class="markdownTableBodyLeft"><code>cpu_lm4f120</code>  </td><td class="markdownTableBodyLeft">The CPU is an TI LM4F120   </td></tr>
</table>
<h3><a class="anchor" id="autotoc_md2385"></a>
Expressif ESP Grouping</h3>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadLeft">Feature  </th><th class="markdownTableHeadLeft">Description   </th></tr>
<tr class="markdownTableBody" class="markdownTableRowOdd">
<td class="markdownTableBodyLeft"><code>cpu_esp32</code>  </td><td class="markdownTableBodyLeft">The MCU is part of the ESP32 family   </td></tr>
<tr class="markdownTableBody" class="markdownTableRowEven">
<td class="markdownTableBodyLeft"><code>cpu_esp8266</code>  </td><td class="markdownTableBodyLeft">The MCU is an ESP8266   </td></tr>
</table>
<h3><a class="anchor" id="autotoc_md2386"></a>
Texas Instruments MSP430 MCU Grouping</h3>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadLeft">Feature  </th><th class="markdownTableHeadLeft">Description   </th></tr>
<tr class="markdownTableBody" class="markdownTableRowOdd">
<td class="markdownTableBodyLeft"><code>cpu_msp430</code>  </td><td class="markdownTableBodyLeft">The MCU is member of the MSP430 family.   </td></tr>
<tr class="markdownTableBody" class="markdownTableRowEven">
<td class="markdownTableBodyLeft"><code>cpu_msp430_x1xx</code>  </td><td class="markdownTableBodyLeft">The MCU is member of the MSP430 x1xx family.   </td></tr>
<tr class="markdownTableBody" class="markdownTableRowOdd">
<td class="markdownTableBodyLeft"><code>cpu_msp430_f2xx_g2xx</code>  </td><td class="markdownTableBodyLeft">The MCU is member of the MSP430 F2xx/G2xx family.   </td></tr>
</table>
<h1><a class="anchor" id="autotoc_md2387"></a>
Arduino Features</h1>
<p>These features indicate that an Arduino style I/O mapping is available, in which common descriptors refer to a GPIO pin / I²C bus / SPI bus / PWM output / ADC input / etc. at a well-known location on a well-known board form factor.</p>
<h2><a class="anchor" id="autotoc_md2388"></a>
Arduino I/O Mapping Features</h2>
<p>These features indicate presence of I/O mappings (e.g. well-known preprocessor macro names such as <code>ARDUINO_PIN_0</code> for a GPIO pin that is routed to pin <code>D0</code> on the board.</p>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadLeft">Feature  </th><th class="markdownTableHeadLeft">Description   </th></tr>
<tr class="markdownTableBody" class="markdownTableRowOdd">
<td class="markdownTableBodyLeft"><code>arduino_analog</code>  </td><td class="markdownTableBodyLeft">Indicates that Arduino analog pins mappings are provided.   </td></tr>
<tr class="markdownTableBody" class="markdownTableRowEven">
<td class="markdownTableBodyLeft"><code>arduino_dac</code>  </td><td class="markdownTableBodyLeft">Indicates that Arduino DAC pins mappings are provided.   </td></tr>
<tr class="markdownTableBody" class="markdownTableRowOdd">
<td class="markdownTableBodyLeft"><code>arduino_i2c</code>  </td><td class="markdownTableBodyLeft">Indicates that Arduino I²C bus mappings are provided.   </td></tr>
<tr class="markdownTableBody" class="markdownTableRowEven">
<td class="markdownTableBodyLeft"><code>arduino_pins</code>  </td><td class="markdownTableBodyLeft">Indicates that Arduino digital pins mappings are provided.   </td></tr>
<tr class="markdownTableBody" class="markdownTableRowOdd">
<td class="markdownTableBodyLeft"><code>arduino_pwm</code>  </td><td class="markdownTableBodyLeft">Indicates that Arduino digital pin to PWM mappings are provided.   </td></tr>
<tr class="markdownTableBody" class="markdownTableRowEven">
<td class="markdownTableBodyLeft"><code>arduino_spi</code>  </td><td class="markdownTableBodyLeft">Indicates that Arduino SPI bus mappings are provided.   </td></tr>
<tr class="markdownTableBody" class="markdownTableRowOdd">
<td class="markdownTableBodyLeft"><code>arduino_uart</code>  </td><td class="markdownTableBodyLeft">Indicates that Arduino UART device mappings are provided.   </td></tr>
</table>
<h2><a class="anchor" id="autotoc_md2389"></a>
Arduino Form Factor Features</h2>
<p>These features indicate compatibility with a specific form factor, e.g. Arduino UNO or Adafruit Feather</p>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadLeft">Feature  </th><th class="markdownTableHeadLeft">Description   </th></tr>
<tr class="markdownTableBody" class="markdownTableRowOdd">
<td class="markdownTableBodyLeft"><code>arduino_shield_isp</code>  </td><td class="markdownTableBodyLeft">Indicates that the board is mechanically and electrically compatible with shields that mate with the ISP header for SPI connectivity.   </td></tr>
<tr class="markdownTableBody" class="markdownTableRowEven">
<td class="markdownTableBodyLeft"><code>arduino_shield_mega</code>  </td><td class="markdownTableBodyLeft">Indicates that the board is mechanically and electrically compatible with shields developed for the Arduino Mega 2560. (Note: Except the ISP header, that requires <code>arduino_shield_isp</code> in addition.)   </td></tr>
<tr class="markdownTableBody" class="markdownTableRowOdd">
<td class="markdownTableBodyLeft"><code>arduino_shield_nano</code>  </td><td class="markdownTableBodyLeft">Indicates that the board is mechanically and electrically compatible with shields developed for the Arduino Nano. (Note: Except the ISP header, that requires <code>arduino_shield_isp</code> in addition.)   </td></tr>
<tr class="markdownTableBody" class="markdownTableRowEven">
<td class="markdownTableBodyLeft"><code>arduino_shield_uno</code>  </td><td class="markdownTableBodyLeft">Indicates that the board is mechanically and electrically compatible with shields developed for the Arduino Nano. (Note: Except the ISP header, that requires <code>arduino_shield_isp</code> in addition.)   </td></tr>
</table>
<h1><a class="anchor" id="autotoc_md2390"></a>
RAM Related Features</h1>
<p>These features indicate presence of special RAM regions or features</p>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadLeft">Feature  </th><th class="markdownTableHeadLeft">Description   </th></tr>
<tr class="markdownTableBody" class="markdownTableRowOdd">
<td class="markdownTableBodyLeft"><code>backup_ram</code>  </td><td class="markdownTableBodyLeft">A special portion of RAM is retained during deep sleep. Variables can be placed there by annotating them with the <code>BACKUP_RAM</code> attribute.   </td></tr>
<tr class="markdownTableBody" class="markdownTableRowEven">
<td class="markdownTableBodyLeft"><code>periph_rtc_mem</code>  </td><td class="markdownTableBodyLeft">The RTC peripheral provides storage memory for deep sleep. Unlike <code>backup_ram</code>, this memory is not mapped in the address space and requires calls to <a class="el" href="group__drivers__periph__rtc__mem.html#ga15a989fec35430f1970ad0f400c5036b">rtc_mem_read</a> and <a class="el" href="group__drivers__periph__rtc__mem.html#ga2d0b02d6d656fb7737ed594f12dfb98f">rtc_mem_write</a> to access.   </td></tr>
<tr class="markdownTableBody" class="markdownTableRowOdd">
<td class="markdownTableBodyLeft"><code>puf_sram</code>  </td><td class="markdownTableBodyLeft">The <a class="el" href="group__sys__puf__sram.html">SRAM PUF</a> module can be used to harvest entropy from uninitialized SRAM on cold boot to seed PRNGs.   </td></tr>
</table>
<h1><a class="anchor" id="autotoc_md2391"></a>
Bluetooth Low Energy Features</h1>
<p>The capabilities of the integrated (peripheral) BLE transceiver are modules using these features.</p>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadLeft">Feature  </th><th class="markdownTableHeadLeft">Description   </th></tr>
<tr class="markdownTableBody" class="markdownTableRowOdd">
<td class="markdownTableBodyLeft"><code>ble_adv_ext</code>  </td><td class="markdownTableBodyLeft">Support for Bluetooth LE 5 Advertising Extension   </td></tr>
<tr class="markdownTableBody" class="markdownTableRowEven">
<td class="markdownTableBodyLeft"><code>ble_nimble</code>  </td><td class="markdownTableBodyLeft">Support for the NimBLE stack   </td></tr>
<tr class="markdownTableBody" class="markdownTableRowOdd">
<td class="markdownTableBodyLeft"><code>ble_nimble_netif</code>  </td><td class="markdownTableBodyLeft">NimBLE supports the netif API, so that network stacks such as GNRC can be used on top. See <a class="el" href="group__pkg__nimble__netif.html">GNRC netif Implementation</a> for details.   </td></tr>
<tr class="markdownTableBody" class="markdownTableRowEven">
<td class="markdownTableBodyLeft"><code>ble_phy_2mbit</code>  </td><td class="markdownTableBodyLeft">The BLE radio supports the 2Mbit PHY mode   </td></tr>
<tr class="markdownTableBody" class="markdownTableRowOdd">
<td class="markdownTableBodyLeft"><code>ble_phy_coded</code>  </td><td class="markdownTableBodyLeft">The BLE radio supports the CODED PHY mode   </td></tr>
</table>
<h1><a class="anchor" id="autotoc_md2392"></a>
Toolchain Features</h1>
<p>These features are used to indicate which toolchains are supported, which languages they support, which libraries (e.g. picolibc, newlibc, libstdc++, etc.) are supported. Unless using <code>BUILD_IN_DOCKER=1</code>, those toolchains/libraries need to be installed on the system for the given platform to actually be usable, though.</p>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadLeft">Feature  </th><th class="markdownTableHeadLeft">Description   </th></tr>
<tr class="markdownTableBody" class="markdownTableRowOdd">
<td class="markdownTableBodyLeft"><code>cpp</code>  </td><td class="markdownTableBodyLeft">The C++ programming language is supported. Note that libstdc++ support is not implied and indicated by a separate feature.   </td></tr>
<tr class="markdownTableBody" class="markdownTableRowEven">
<td class="markdownTableBodyLeft"><code>libstdcpp</code>  </td><td class="markdownTableBodyLeft">When using C++, a libstdc++ is available.   </td></tr>
<tr class="markdownTableBody" class="markdownTableRowOdd">
<td class="markdownTableBodyLeft"><code>picolibc</code>  </td><td class="markdownTableBodyLeft">The picolibc C library is available for the platform.   </td></tr>
<tr class="markdownTableBody" class="markdownTableRowEven">
<td class="markdownTableBodyLeft"><code>newlib</code>  </td><td class="markdownTableBodyLeft">The newlib C library is available for the platform.   </td></tr>
<tr class="markdownTableBody" class="markdownTableRowOdd">
<td class="markdownTableBodyLeft"><code>rust_target</code>  </td><td class="markdownTableBodyLeft">The Rust target definition ("triple") is known. This is a mandatory requirement to build Rust code.   </td></tr>
<tr class="markdownTableBody" class="markdownTableRowEven">
<td class="markdownTableBodyLeft"><code>emulator_renode</code>  </td><td class="markdownTableBodyLeft">The platform is compatible with the Renode emulator.   </td></tr>
</table>
<h1><a class="anchor" id="autotoc_md2393"></a>
Peripheral Features</h1>
<p>These features indicate presence of peripheral IP block, presence of a corresponding driver in RIOT, and any required board specific configuration needed.</p>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadLeft">Feature  </th><th class="markdownTableHeadLeft">Description   </th></tr>
<tr class="markdownTableBody" class="markdownTableRowOdd">
<td class="markdownTableBodyLeft"><code>periph_cpuid</code>  </td><td class="markdownTableBodyLeft">The CPU has identification information available. In the best case this is a globally unique ID, in the worst case it is some calibration parameters to compensate production variance that may or may not allow telling the CPU apart from any given other.   </td></tr>
<tr class="markdownTableBody" class="markdownTableRowEven">
<td class="markdownTableBodyLeft"><code>periph_pwm</code>  </td><td class="markdownTableBodyLeft">A Pulse-Width Modulation (PWM) peripheral is present.   </td></tr>
<tr class="markdownTableBody" class="markdownTableRowOdd">
<td class="markdownTableBodyLeft"><code>periph_qdec</code>  </td><td class="markdownTableBodyLeft">A Quadrature Decoder (QDEC) peripheral is present.   </td></tr>
<tr class="markdownTableBody" class="markdownTableRowEven">
<td class="markdownTableBodyLeft"><code>periph_temperature</code>  </td><td class="markdownTableBodyLeft">The MCU has a built-in temperature sensor.   </td></tr>
<tr class="markdownTableBody" class="markdownTableRowOdd">
<td class="markdownTableBodyLeft"><code>periph_vbat</code>  </td><td class="markdownTableBodyLeft">Backup battery monitoring is supported   </td></tr>
<tr class="markdownTableBody" class="markdownTableRowEven">
<td class="markdownTableBodyLeft"><code>periph_freqm</code>  </td><td class="markdownTableBodyLeft">A Frequency Meter peripheral is present.   </td></tr>
<tr class="markdownTableBody" class="markdownTableRowOdd">
<td class="markdownTableBodyLeft"><code>periph_dma</code>  </td><td class="markdownTableBodyLeft">A DMA peripheral is present. Enabling this feature affects the implementation of other peripheral drivers. E.g. SPI/I²C/UART/... transfers may use the DMA (possible only when transfers are longer than a certain cut-off). The main benefit is that other threads can run while the thread issuing the, say SPI transfer, is blocked until the transfer is completed. It often also speeds up longer transfers.   </td></tr>
<tr class="markdownTableBody" class="markdownTableRowEven">
<td class="markdownTableBodyLeft"><code>periph_pm</code>  </td><td class="markdownTableBodyLeft">The MCU supports power management (PM) and RIOT can make use of that.   </td></tr>
<tr class="markdownTableBody" class="markdownTableRowOdd">
<td class="markdownTableBodyLeft"><code>periph_ltdc</code>  </td><td class="markdownTableBodyLeft">An LCD/TFT Display Controller (LTDC) peripheral is present. (Currently only provided by some STM32 MCUs.)   </td></tr>
<tr class="markdownTableBody" class="markdownTableRowEven">
<td class="markdownTableBodyLeft"><code>periph_pio</code>  </td><td class="markdownTableBodyLeft">A Programmable IO (PIO) is present. (Currently only RP2040)   </td></tr>
</table>
<h2><a class="anchor" id="autotoc_md2394"></a>
General-Purpose Input/Output (GPIO)</h2>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadLeft">Feature  </th><th class="markdownTableHeadLeft">Description   </th></tr>
<tr class="markdownTableBody" class="markdownTableRowOdd">
<td class="markdownTableBodyLeft"><code>periph_gpio_fast_read</code>  </td><td class="markdownTableBodyLeft">This feature is currently available on Microchip SAM0 based MCUs only. Enabling this feature reduces read latency for an increase in power consumption. It affects both the classic GPIO API driver and the GPIO LL driver.   </td></tr>
</table>
<h3><a class="anchor" id="autotoc_md2395"></a>
Pin Level Peripheral GPIO API</h3>
<p>This is a pin-level API that caters most use cases. Most code should be using this API over GPIO LL.</p>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadLeft">Feature  </th><th class="markdownTableHeadLeft">Description   </th></tr>
<tr class="markdownTableBody" class="markdownTableRowOdd">
<td class="markdownTableBodyLeft"><code>periph_gpio</code>  </td><td class="markdownTableBodyLeft">The classic GPIO API is implemented   </td></tr>
<tr class="markdownTableBody" class="markdownTableRowEven">
<td class="markdownTableBodyLeft"><code>periph_gpio_irq</code>  </td><td class="markdownTableBodyLeft">The classic GPIO driver supports external interrupts.   </td></tr>
<tr class="markdownTableBody" class="markdownTableRowOdd">
<td class="markdownTableBodyLeft"><code>periph_gpio_tamper_wake</code>  </td><td class="markdownTableBodyLeft">This features is currently available on Microchip SAMD5x MCUs only. Enabling this features allows GPIO IRQs to wake the CPU even in deep sleep. The SAMD5x is not the only MCU that can be woken from lower power modes via GPIO, but it is currently the only MCU were this feature is configurable.   </td></tr>
</table>
<h3><a class="anchor" id="autotoc_md2396"></a>
GPIO LL API</h3>
<p>This is a lower level GPIO API that allows port based access. It exposes a number of advanced features and lower latency GPIO access at the cost of a more complex and more frequently changing API. You should only use this if the Pin Level Peripheral GPIO API is not catering your use case well enough.</p>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadLeft">Feature  </th><th class="markdownTableHeadLeft">Description   </th></tr>
<tr class="markdownTableBody" class="markdownTableRowOdd">
<td class="markdownTableBodyLeft"><code>periph_gpio_ll</code>  </td><td class="markdownTableBodyLeft">The GPIO LL driver is implemented for the MCU's GPIO peripheral.   </td></tr>
<tr class="markdownTableBody" class="markdownTableRowEven">
<td class="markdownTableBodyLeft"><code>periph_gpio_ll_irq</code>  </td><td class="markdownTableBodyLeft">The GPIO LL driver has IRQ support.   </td></tr>
<tr class="markdownTableBody" class="markdownTableRowOdd">
<td class="markdownTableBodyLeft"><code>periph_gpio_ll_irq_level_triggered_high</code>  </td><td class="markdownTableBodyLeft">Level triggered IRQs are supported for level high.   </td></tr>
<tr class="markdownTableBody" class="markdownTableRowEven">
<td class="markdownTableBodyLeft"><code>periph_gpio_ll_irq_level_triggered_low</code>  </td><td class="markdownTableBodyLeft">Level triggered IRQs are supported for level low.   </td></tr>
<tr class="markdownTableBody" class="markdownTableRowOdd">
<td class="markdownTableBodyLeft"><code>periph_gpio_ll_irq_edge_triggered_both</code>  </td><td class="markdownTableBodyLeft">Edge triggered IRQs are supported with both falling and rising edges as trigger   </td></tr>
<tr class="markdownTableBody" class="markdownTableRowEven">
<td class="markdownTableBodyLeft"><code>periph_gpio_ll_irq_unmask</code>  </td><td class="markdownTableBodyLeft">The GPIO LL driver supports unmasking interrupts without clearing pending IRQs that came in while masked.   </td></tr>
<tr class="markdownTableBody" class="markdownTableRowOdd">
<td class="markdownTableBodyLeft"><code>periph_gpio_ll_disconnect</code>  </td><td class="markdownTableBodyLeft">Some or all GPIO pins can be electrically disconnected from the MCU (high impedance state) with the GPIO LL API.   </td></tr>
<tr class="markdownTableBody" class="markdownTableRowEven">
<td class="markdownTableBodyLeft"><code>periph_gpio_ll_input_pull_down</code>  </td><td class="markdownTableBodyLeft">Some or all GPIO pins can enable an internal pull down resistor when the GPIO is configured in input mode.   </td></tr>
<tr class="markdownTableBody" class="markdownTableRowOdd">
<td class="markdownTableBodyLeft"><code>periph_gpio_ll_input_pull_keep</code>  </td><td class="markdownTableBodyLeft">Some or all GPIO pins can enable internal pull resistors that pull towards the current bus level (pull down when bus is low, pull up when bus is high).   </td></tr>
<tr class="markdownTableBody" class="markdownTableRowEven">
<td class="markdownTableBodyLeft"><code>periph_gpio_ll_input_pull_up</code>  </td><td class="markdownTableBodyLeft">Some or all GPIO pins can enable an internal pull up resistor when the GPIO is configured in input mode.   </td></tr>
<tr class="markdownTableBody" class="markdownTableRowOdd">
<td class="markdownTableBodyLeft"><code>periph_gpio_ll_open_drain</code>  </td><td class="markdownTableBodyLeft">Some or all pins can be configured in open drain mode.   </td></tr>
<tr class="markdownTableBody" class="markdownTableRowEven">
<td class="markdownTableBodyLeft"><code>periph_gpio_ll_open_drain_pull_up</code>  </td><td class="markdownTableBodyLeft">Some or all GPIO pins can enable an internal pull up resistor when the GPIO is configured in open drain mode.   </td></tr>
<tr class="markdownTableBody" class="markdownTableRowOdd">
<td class="markdownTableBodyLeft"><code>periph_gpio_ll_open_source</code>  </td><td class="markdownTableBodyLeft">Some or all pins can be configured in open source mode.   </td></tr>
<tr class="markdownTableBody" class="markdownTableRowEven">
<td class="markdownTableBodyLeft"><code>periph_gpio_ll_open_source_pull_down</code>  </td><td class="markdownTableBodyLeft">Some or all GPIO pins can enable an internal pull down resistor when the GPIO is configured in open source mode.   </td></tr>
<tr class="markdownTableBody" class="markdownTableRowOdd">
<td class="markdownTableBodyLeft"><code>periph_gpio_ll_switch_dir</code>  </td><td class="markdownTableBodyLeft">The GPIO LL driver allows switching the direction between input and (push-pull) output in an efficient manner. The main use case is bit-banging bidirectional protocols when open-drain / open-source mode is not supported. Another use case is controlling GPIOs at high speed with three output states (high, low, high impedance), as e.g. needed for Charlieplexing   </td></tr>
</table>
<h2><a class="anchor" id="autotoc_md2397"></a>
Serial Interfaces</h2>
<p>Features related to serial interfaces</p>
<h3><a class="anchor" id="autotoc_md2398"></a>
UART Features</h3>
<p>Features related to the Universal Asynchronous Receiver-Transmitter peripheral</p>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadLeft">Feature  </th><th class="markdownTableHeadLeft">Description   </th></tr>
<tr class="markdownTableBody" class="markdownTableRowOdd">
<td class="markdownTableBodyLeft"><code>periph_uart</code>  </td><td class="markdownTableBodyLeft">An UART peripheral is present.   </td></tr>
<tr class="markdownTableBody" class="markdownTableRowEven">
<td class="markdownTableBodyLeft"><code>periph_lpuart</code>  </td><td class="markdownTableBodyLeft">A low-power UART peripheral is present.   </td></tr>
<tr class="markdownTableBody" class="markdownTableRowOdd">
<td class="markdownTableBodyLeft"><code>periph_uart_collision</code>  </td><td class="markdownTableBodyLeft">The UART peripheral supports hardware collision detection.   </td></tr>
<tr class="markdownTableBody" class="markdownTableRowEven">
<td class="markdownTableBodyLeft"><code>periph_uart_hw_fc</code>  </td><td class="markdownTableBodyLeft">The UART peripheral supports hardware flow control.   </td></tr>
<tr class="markdownTableBody" class="markdownTableRowOdd">
<td class="markdownTableBodyLeft"><code>periph_uart_modecfg</code>  </td><td class="markdownTableBodyLeft">The UART peripheral allows configuration to non-default modes.   </td></tr>
<tr class="markdownTableBody" class="markdownTableRowEven">
<td class="markdownTableBodyLeft"><code>periph_uart_tx_ondemand</code>  </td><td class="markdownTableBodyLeft">Indicates that the UART peripheral can enable / disable the TX line using <a class="el" href="group__drivers__periph__uart.html#ga0256858e49537ce0dfbf14e8c0275d35">uart_enable_tx</a> / <a class="el" href="group__drivers__periph__uart.html#ga522bdce35dd52dc502ca671b00105c92">uart_disable_tx</a>   </td></tr>
<tr class="markdownTableBody" class="markdownTableRowOdd">
<td class="markdownTableBodyLeft"><code>periph_uart_nonblocking</code>  </td><td class="markdownTableBodyLeft">The UART peripheral allows non-blocking operations.   </td></tr>
<tr class="markdownTableBody" class="markdownTableRowEven">
<td class="markdownTableBodyLeft"><code>periph_uart_reconfigure</code>  </td><td class="markdownTableBodyLeft">The UART pins can be made available as regular GPIOS using <a class="el" href="group__drivers__periph__uart.html#ga0f9f17e1bd5cbbb69b709c60bbf326ed">uart_deinit_pins</a> and be attached back to the UART peripheral using <a class="el" href="group__drivers__periph__uart.html#gac3c6f029dbd157caa21bfc63da6d8c29">uart_init_pins</a>   </td></tr>
<tr class="markdownTableBody" class="markdownTableRowOdd">
<td class="markdownTableBodyLeft"><code>periph_uart_rxstart_irq</code>  </td><td class="markdownTableBodyLeft">The UART can issue an interrupt when the start condition detected. Use <a class="el" href="group__drivers__periph__uart.html#ga0f2e50dd0d37815835675a9ed1150465">uart_rxstart_irq_configure</a> to associate a callback with the ISR of a given UART peripheral.   </td></tr>
</table>
<h3><a class="anchor" id="autotoc_md2399"></a>
SPI Features</h3>
<p>Features related to the Serial Peripheral Interface peripheral</p>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadLeft">Feature  </th><th class="markdownTableHeadLeft">Description   </th></tr>
<tr class="markdownTableBody" class="markdownTableRowOdd">
<td class="markdownTableBodyLeft"><code>periph_spi</code>  </td><td class="markdownTableBodyLeft">An SPI peripheral is present.   </td></tr>
<tr class="markdownTableBody" class="markdownTableRowEven">
<td class="markdownTableBodyLeft"><code>periph_spi_on_qspi</code>  </td><td class="markdownTableBodyLeft">The QSPI peripheral can be used in SPI mode.   </td></tr>
<tr class="markdownTableBody" class="markdownTableRowOdd">
<td class="markdownTableBodyLeft"><code>periph_spi_reconfigure</code>  </td><td class="markdownTableBodyLeft">The SPI pins can be made available as regular GPIOs using <a class="el" href="group__drivers__periph__spi.html#gab53bb266f74e4aaab19955c9fd199205">spi_deinit_pins</a> and re-attached to the SPI peripheral using <a class="el" href="group__drivers__periph__spi.html#ga9fcf9ffd48cdc62c6019a2f07aab4ae9">spi_init_pins</a>   </td></tr>
<tr class="markdownTableBody" class="markdownTableRowEven">
<td class="markdownTableBodyLeft"><code>periph_spi_gpio_mode</code>  </td><td class="markdownTableBodyLeft">The SPI peripheral supports specifying the GPIO mode of each SPI pin upon initialization of the peripheral.   </td></tr>
</table>
<h3><a class="anchor" id="autotoc_md2400"></a>
I²C Features</h3>
<p>Features related to the Inter-Integrated Circuit peripheral</p>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadLeft">Feature  </th><th class="markdownTableHeadLeft">Description   </th></tr>
<tr class="markdownTableBody" class="markdownTableRowOdd">
<td class="markdownTableBodyLeft"><code>periph_i2c</code>  </td><td class="markdownTableBodyLeft">An I²C peripheral is present.   </td></tr>
<tr class="markdownTableBody" class="markdownTableRowEven">
<td class="markdownTableBodyLeft"><code>pio_i2c</code>  </td><td class="markdownTableBodyLeft">An I²C bus can be provided via the PIO peripheral.   </td></tr>
<tr class="markdownTableBody" class="markdownTableRowOdd">
<td class="markdownTableBodyLeft"><code>periph_i2c_reconfigure</code>  </td><td class="markdownTableBodyLeft">The I²C pins can be made available as regular GPIOs using <a class="el" href="group__drivers__periph__i2c.html#ga40e65b8c4c0ecb24da892b8ec6bb3f45">i2c_deinit_pins</a> and re-attached to the I²C peripheral using <a class="el" href="group__drivers__periph__i2c.html#gaa34bed3b0c852839ef35d52b017e2941">i2c_init_pins</a>   </td></tr>
</table>
<h3><a class="anchor" id="autotoc_md2401"></a>
USB Features</h3>
<p>Features related to the Universal Serial Bus</p>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadLeft">Feature  </th><th class="markdownTableHeadLeft">Description   </th></tr>
<tr class="markdownTableBody" class="markdownTableRowOdd">
<td class="markdownTableBodyLeft"><code>periph_usbdev</code>  </td><td class="markdownTableBodyLeft">An USB peripheral is present.   </td></tr>
<tr class="markdownTableBody" class="markdownTableRowEven">
<td class="markdownTableBodyLeft"><code>periph_usbdev_hs</code>  </td><td class="markdownTableBodyLeft">The USB peripheral supports High-Speed.   </td></tr>
<tr class="markdownTableBody" class="markdownTableRowOdd">
<td class="markdownTableBodyLeft"><code>periph_usbdev_hs_utmi</code>  </td><td class="markdownTableBodyLeft">An USB high-speed peripheral with internal UTMI+ HS PHY is present.   </td></tr>
<tr class="markdownTableBody" class="markdownTableRowEven">
<td class="markdownTableBodyLeft"><code>periph_usbdev_hs_ulpi</code>  </td><td class="markdownTableBodyLeft">An USB high-speed peripheral with ULPI HS PHY is present.   </td></tr>
</table>
<h2><a class="anchor" id="autotoc_md2402"></a>
Analog Features</h2>
<p>Features related to ADCs/DACs</p>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadLeft">Feature  </th><th class="markdownTableHeadLeft">Description   </th></tr>
<tr class="markdownTableBody" class="markdownTableRowOdd">
<td class="markdownTableBodyLeft"><code>periph_adc</code>  </td><td class="markdownTableBodyLeft">An ADC peripheral is present.   </td></tr>
<tr class="markdownTableBody" class="markdownTableRowEven">
<td class="markdownTableBodyLeft"><code>periph_adc_continuous</code>  </td><td class="markdownTableBodyLeft">The ADC peripheral can be left on between measurements.   </td></tr>
<tr class="markdownTableBody" class="markdownTableRowOdd">
<td class="markdownTableBodyLeft"><code>periph_dac</code>  </td><td class="markdownTableBodyLeft">A DAC peripheral is present.   </td></tr>
</table>
<h2><a class="anchor" id="autotoc_md2403"></a>
Integrated Connectivity</h2>
<p>Peripheral network and communication interfaces.</p>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadLeft">Feature  </th><th class="markdownTableHeadLeft">Description   </th></tr>
<tr class="markdownTableBody" class="markdownTableRowOdd">
<td class="markdownTableBodyLeft"><code>periph_can</code>  </td><td class="markdownTableBodyLeft">A CAN peripheral is present.   </td></tr>
<tr class="markdownTableBody" class="markdownTableRowEven">
<td class="markdownTableBodyLeft"><code>can_rx_mailbox</code>  </td><td class="markdownTableBodyLeft">CAN controller RX mailbox is supported   </td></tr>
<tr class="markdownTableBody" class="markdownTableRowOdd">
<td class="markdownTableBodyLeft"><code>periph_eth</code>  </td><td class="markdownTableBodyLeft">An Ethernet peripheral is present.   </td></tr>
</table>
<h2><a class="anchor" id="autotoc_md2404"></a>
SD / MMC Card Features</h2>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadLeft">Feature  </th><th class="markdownTableHeadLeft">Description   </th></tr>
<tr class="markdownTableBody" class="markdownTableRowOdd">
<td class="markdownTableBodyLeft"><code>periph_sdmmc</code>  </td><td class="markdownTableBodyLeft">An SDIO/SD/MMC peripheral is present and used by the board. This feature shall be provided by the board configuration, if available.   </td></tr>
<tr class="markdownTableBody" class="markdownTableRowEven">
<td class="markdownTableBodyLeft"><code>periph_sdmmc_8bit</code>  </td><td class="markdownTableBodyLeft">The SDIO/SD/MMC peripheral supports the 8-bit bus width and at least one component of the board is connected with 8 data lines. This feature shall be provided by the board configuration, if available.   </td></tr>
<tr class="markdownTableBody" class="markdownTableRowOdd">
<td class="markdownTableBodyLeft"><code>periph_sdmmc_auto_clk</code>  </td><td class="markdownTableBodyLeft">The SDIO/SD/MMC peripheral supports the Auto-CLK feature, i.e. the automatic activation and deactivation of the SD CLK signal when required. This feature shall be provided by the MCU if supported.   </td></tr>
<tr class="markdownTableBody" class="markdownTableRowEven">
<td class="markdownTableBodyLeft"><code>periph_sdmmc_auto_cmd12</code>  </td><td class="markdownTableBodyLeft">The SDIO/SD/MMC peripheral supports the Auto-CMD12 feature, i.e. CMD12 is sent automatically to stop the transmission in multiple block operations. This feature shall be provided by the MCU if supported.   </td></tr>
<tr class="markdownTableBody" class="markdownTableRowOdd">
<td class="markdownTableBodyLeft"><code>periph_sdmmc_clk</code>  </td><td class="markdownTableBodyLeft">The SDIO/SD/MMC peripheral has special clock functionality used by the peripheral driver.   </td></tr>
<tr class="markdownTableBody" class="markdownTableRowEven">
<td class="markdownTableBodyLeft"><code>periph_sdmmc_hs</code>  </td><td class="markdownTableBodyLeft">The SDIO/SD/MMC peripheral supports the high speed access, that is 50 MHz for SD and 52 MHz for MMC. This feature shall be provided by the MCU.   </td></tr>
<tr class="markdownTableBody" class="markdownTableRowOdd">
<td class="markdownTableBodyLeft"><code>periph_sdmmc_mmc</code>  </td><td class="markdownTableBodyLeft">The SDIO/SD/MMC peripheral supports MMC/eMMCs. This feature shall be provided by the MCU.   </td></tr>
<tr class="markdownTableBody" class="markdownTableRowEven">
<td class="markdownTableBodyLeft"><code>periph_sdmmc_sdhc</code>  </td><td class="markdownTableBodyLeft">The SDIO/SD/MMC peripheral is compliant with the SD Host Controller Specification. This feature shall be provided by the MCU.   </td></tr>
</table>
<h2><a class="anchor" id="autotoc_md2405"></a>
Flash Features</h2>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadLeft">Feature  </th><th class="markdownTableHeadLeft">Description   </th></tr>
<tr class="markdownTableBody" class="markdownTableRowOdd">
<td class="markdownTableBodyLeft"><code>periph_flashpage</code>  </td><td class="markdownTableBodyLeft">A Flashpage peripheral is present.   </td></tr>
<tr class="markdownTableBody" class="markdownTableRowEven">
<td class="markdownTableBodyLeft"><code>periph_flashpage_in_address_space</code>  </td><td class="markdownTableBodyLeft">Static memory sections can fundamentally be turned into flash pages.   </td></tr>
<tr class="markdownTableBody" class="markdownTableRowOdd">
<td class="markdownTableBodyLeft"><code>periph_flashpage_pagewise</code>  </td><td class="markdownTableBodyLeft">The Flashpage peripheral supports pagewise writing.   </td></tr>
<tr class="markdownTableBody" class="markdownTableRowEven">
<td class="markdownTableBodyLeft"><code>periph_flashpage_rwee</code>  </td><td class="markdownTableBodyLeft">The Flashpage peripheral is of the Read While Write.   </td></tr>
<tr class="markdownTableBody" class="markdownTableRowOdd">
<td class="markdownTableBodyLeft"><code>periph_flashpage_aux</code>  </td><td class="markdownTableBodyLeft">It is possible to partition off a part of the internal flash for an auxiliary slot.   </td></tr>
</table>
<h2><a class="anchor" id="autotoc_md2406"></a>
Other Peripheral Storage Features</h2>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadLeft">Feature  </th><th class="markdownTableHeadLeft">Description   </th></tr>
<tr class="markdownTableBody" class="markdownTableRowOdd">
<td class="markdownTableBodyLeft"><code>periph_eeprom</code>  </td><td class="markdownTableBodyLeft">An EEPROM peripheral is present.   </td></tr>
<tr class="markdownTableBody" class="markdownTableRowEven">
<td class="markdownTableBodyLeft"><code>periph_fmc</code>  </td><td class="markdownTableBodyLeft">An Flexible Memory Controller (FMC) or an Flexible Static Memory Controller (FSMC) is present. It can be used to extend memory or drive display controllers.   </td></tr>
<tr class="markdownTableBody" class="markdownTableRowOdd">
<td class="markdownTableBodyLeft"><code>periph_fmc_16bit</code>  </td><td class="markdownTableBodyLeft">The FMC/FSMC peripheral supports a 16-bit data bus   </td></tr>
<tr class="markdownTableBody" class="markdownTableRowEven">
<td class="markdownTableBodyLeft"><code>periph_fmc_32bit</code>  </td><td class="markdownTableBodyLeft">The FMC/FSMC peripheral supports a 32-bit data bus   </td></tr>
<tr class="markdownTableBody" class="markdownTableRowOdd">
<td class="markdownTableBodyLeft"><code>periph_fmc_sdram</code>  </td><td class="markdownTableBodyLeft">A board configuration is provided to attach map the board's SDRAM into the address space using the FMC/FSMC.   </td></tr>
<tr class="markdownTableBody" class="markdownTableRowEven">
<td class="markdownTableBodyLeft"><code>periph_fmc_nor_sram</code>  </td><td class="markdownTableBodyLeft">A board configuration is provided to attach map the board's NOR flash or (P)SRAM into the address space using the FMC/FSMC.   </td></tr>
<tr class="markdownTableBody" class="markdownTableRowOdd">
<td class="markdownTableBodyLeft"><code>periph_nvm</code>  </td><td class="markdownTableBodyLeft">A non-volatile memory peripheral is present. This is currently only provided by ATxmega MCUs to read the production signature which then is used as CPU ID.   </td></tr>
</table>
<h2><a class="anchor" id="autotoc_md2407"></a>
Timer Features</h2>
<p>Features related to timers</p>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadLeft">Feature  </th><th class="markdownTableHeadLeft">Description   </th></tr>
<tr class="markdownTableBody" class="markdownTableRowOdd">
<td class="markdownTableBodyLeft"><code>periph_rtc</code>  </td><td class="markdownTableBodyLeft">An Real Time Clock (RTC) peripheral is present. This timer works with time broken down into year, month, day, hour, minute, second.   </td></tr>
<tr class="markdownTableBody" class="markdownTableRowEven">
<td class="markdownTableBodyLeft"><code>periph_rtc_ms</code>  </td><td class="markdownTableBodyLeft">The RTC peripheral can provide sub-second timestamps.   </td></tr>
<tr class="markdownTableBody" class="markdownTableRowOdd">
<td class="markdownTableBodyLeft"><code>periph_rtt</code>  </td><td class="markdownTableBodyLeft">An Real Time <a class="el" href="structTimer.html" title="struct to get time references within mqtt paho ">Timer</a> (RTT) (a.k.a. Real Time Counter) peripheral is present. This timer is similar to <code>periph_timer</code>, except for using a different API (for no reason), being low power, slower ticking, and typically less affected by clock drift.   </td></tr>
<tr class="markdownTableBody" class="markdownTableRowEven">
<td class="markdownTableBodyLeft"><code>periph_rtt_set_counter</code>  </td><td class="markdownTableBodyLeft">The RTT peripheral implements <a class="el" href="group__drivers__periph__rtt.html#gaf426556b117f882b4990b2351c5026df">rtt_set_counter</a>   </td></tr>
<tr class="markdownTableBody" class="markdownTableRowOdd">
<td class="markdownTableBodyLeft"><code>periph_rtt_overflow</code>  </td><td class="markdownTableBodyLeft">The RTT provides an overflow callback.   </td></tr>
<tr class="markdownTableBody" class="markdownTableRowEven">
<td class="markdownTableBodyLeft"><code>periph_wdt</code>  </td><td class="markdownTableBodyLeft">A Watchdog <a class="el" href="structTimer.html" title="struct to get time references within mqtt paho ">Timer</a> (WDT) peripheral is present.   </td></tr>
<tr class="markdownTableBody" class="markdownTableRowOdd">
<td class="markdownTableBodyLeft"><code>periph_wdt_cb</code>  </td><td class="markdownTableBodyLeft">The WDT peripheral allows setting a callback function to be called before the reboot is actually triggered.   </td></tr>
<tr class="markdownTableBody" class="markdownTableRowEven">
<td class="markdownTableBodyLeft"><code>periph_wdt_warning_period</code>  </td><td class="markdownTableBodyLeft">By setting <a class="el" href="group__drivers__periph__wdt__conf.html#gae864085c89b76c9d9fc8bb23eb868b16">CONFIG_WDT_WARNING_PERIOD</a> the time when the WDT callback is triggered can be set. It specifies how many milliseconds before the reboot the callback should be executed.   </td></tr>
</table>
<h3><a class="anchor" id="autotoc_md2408"></a>
High Frequency Timers</h3>
<p>Features related to high frequency timers, a.k.a. <code>periph_timer</code></p>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadLeft">Feature  </th><th class="markdownTableHeadLeft">Description   </th></tr>
<tr class="markdownTableBody" class="markdownTableRowOdd">
<td class="markdownTableBodyLeft"><code>periph_timer</code>  </td><td class="markdownTableBodyLeft">A high frequency timer peripheral is present.   </td></tr>
<tr class="markdownTableBody" class="markdownTableRowEven">
<td class="markdownTableBodyLeft"><code>periph_timer_periodic</code>  </td><td class="markdownTableBodyLeft">The <a class="el" href="structTimer.html" title="struct to get time references within mqtt paho ">Timer</a> peripheral allows setting periodic timeouts in addition to the mandatory one-shot timeouts.   </td></tr>
<tr class="markdownTableBody" class="markdownTableRowOdd">
<td class="markdownTableBodyLeft"><code>periph_timer_poll</code>  </td><td class="markdownTableBodyLeft">The <a class="el" href="structTimer.html" title="struct to get time references within mqtt paho ">Timer</a> peripheral allows polling if a one-shot timer channel has already been expired using <a class="el" href="group__drivers__periph__timer.html#ga07898c80f7f0e38362b8d5dcd99c9641">timer_poll_channel</a> to allow high accuracy busy waiting.   </td></tr>
<tr class="markdownTableBody" class="markdownTableRowEven">
<td class="markdownTableBodyLeft"><code>periph_timer_query_freqs</code>  </td><td class="markdownTableBodyLeft">The timer driver supports querying supported frequencies.   </td></tr>
</table>
<h3><a class="anchor" id="autotoc_md2409"></a>
PTP Timers</h3>
<p>These features are related to the hardware requirements to implement the Precision Time Protocol.</p>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadLeft">Feature  </th><th class="markdownTableHeadLeft">Description   </th></tr>
<tr class="markdownTableBody" class="markdownTableRowOdd">
<td class="markdownTableBodyLeft"><code>periph_ptp</code>  </td><td class="markdownTableBodyLeft">A PTP clock is present. The clock must have nanoseconds as unit and be at least 64 bit wide.   </td></tr>
<tr class="markdownTableBody" class="markdownTableRowEven">
<td class="markdownTableBodyLeft"><code>periph_ptp_speed_adjustment</code>  </td><td class="markdownTableBodyLeft">The PTP clock speed can be adjusted. This can be used for clock drift correction and synchronization without "jumping" to the new network time, but rather pace faster/slow for some time until the clocks are back in sync.   </td></tr>
<tr class="markdownTableBody" class="markdownTableRowOdd">
<td class="markdownTableBodyLeft"><code>periph_ptp_timer</code>  </td><td class="markdownTableBodyLeft">The PTP clock can be used as timer (so that (absolute) timeouts can be set on the clock).   </td></tr>
<tr class="markdownTableBody" class="markdownTableRowEven">
<td class="markdownTableBodyLeft"><code>periph_ptp_txrx_timestamps</code>  </td><td class="markdownTableBodyLeft">The PTP clock can provide exact time stamps of the reception and transmission of frames (typically received at the peripheral Ethernet interface).   </td></tr>
</table>
<h2><a class="anchor" id="autotoc_md2410"></a>
Platform Specific</h2>
<p>Things specific to a single MCU family / MCU vendor</p>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadLeft">Feature  </th><th class="markdownTableHeadLeft">Description   </th></tr>
<tr class="markdownTableBody" class="markdownTableRowOdd">
<td class="markdownTableBodyLeft"><code>board_bat_voltage</code>  </td><td class="markdownTableBodyLeft">Measures battery voltage based on ADC sampling.   </td></tr>
<tr class="markdownTableBody" class="markdownTableRowEven">
<td class="markdownTableBodyLeft"><code>periph_ics</code>  </td><td class="markdownTableBodyLeft">An NXP Kinetis Internal Clock Source Controller (ICS peripheral) is present.   </td></tr>
<tr class="markdownTableBody" class="markdownTableRowOdd">
<td class="markdownTableBodyLeft"><code>periph_mcg</code>  </td><td class="markdownTableBodyLeft">An Kinetis Multipurpose Clock Generator (MCG peripheral) is present.   </td></tr>
<tr class="markdownTableBody" class="markdownTableRowEven">
<td class="markdownTableBodyLeft"><code>periph_mcg_lite</code>  </td><td class="markdownTableBodyLeft">An Kinetis Multipurpose Clock Generator (MCG peripheral) is present in the lite version.   </td></tr>
<tr class="markdownTableBody" class="markdownTableRowOdd">
<td class="markdownTableBodyLeft"><code>periph_coretimer</code>  </td><td class="markdownTableBodyLeft">A RISC-V CLINT timer is available and usable via the High Speed timer API. The CLINT only supports running at the RTC clock, typically 32.678 kHz, though.   </td></tr>
<tr class="markdownTableBody" class="markdownTableRowEven">
<td class="markdownTableBodyLeft"><code>periph_pmp</code>  </td><td class="markdownTableBodyLeft">A RISC-V physical memory protection (PMP) peripheral is present. (Similar to ARM's MPU)   </td></tr>
<tr class="markdownTableBody" class="markdownTableRowOdd">
<td class="markdownTableBodyLeft"><code>periph_clic</code>  </td><td class="markdownTableBodyLeft">A RISC-V Core-local Interrupt Controller (CLIC) peripheral is present.   </td></tr>
<tr class="markdownTableBody" class="markdownTableRowEven">
<td class="markdownTableBodyLeft"><code>periph_plic</code>  </td><td class="markdownTableBodyLeft">A RISC-V Platform-local Interrupt Controller (PLIC) peripheral is present.   </td></tr>
</table>
<h2><a class="anchor" id="autotoc_md2411"></a>
Cryptographic Features</h2>
<p>Hardware acceleration for cryptographic primitives, hardware random number generators, and other features useful for cryptography. Please keep in mind that some of the cryptographic primitives provided by the hardware have not aged well in terms of security. They may still be nifty for use cases other than security, though.</p>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadLeft">Feature  </th><th class="markdownTableHeadLeft">Description   </th></tr>
<tr class="markdownTableBody" class="markdownTableRowOdd">
<td class="markdownTableBodyLeft"><code>periph_cryptocell_310</code>  </td><td class="markdownTableBodyLeft">A cryptocell peripheral is present.   </td></tr>
<tr class="markdownTableBody" class="markdownTableRowEven">
<td class="markdownTableBodyLeft"><code>periph_hash_md5</code>  </td><td class="markdownTableBodyLeft">MD5 hardware acceleration present.   </td></tr>
<tr class="markdownTableBody" class="markdownTableRowOdd">
<td class="markdownTableBodyLeft"><code>periph_hash_sha_1</code>  </td><td class="markdownTableBodyLeft">SHA-1 hardware acceleration present.   </td></tr>
<tr class="markdownTableBody" class="markdownTableRowEven">
<td class="markdownTableBodyLeft"><code>periph_hash_sha_224</code>  </td><td class="markdownTableBodyLeft">SHA-224 hardware acceleration present.   </td></tr>
<tr class="markdownTableBody" class="markdownTableRowOdd">
<td class="markdownTableBodyLeft"><code>periph_hash_sha_256</code>  </td><td class="markdownTableBodyLeft">SHA-256 hardware acceleration present.   </td></tr>
<tr class="markdownTableBody" class="markdownTableRowEven">
<td class="markdownTableBodyLeft"><code>periph_hash_sha_384</code>  </td><td class="markdownTableBodyLeft">SHA-384 hardware acceleration present.   </td></tr>
<tr class="markdownTableBody" class="markdownTableRowOdd">
<td class="markdownTableBodyLeft"><code>periph_hash_sha_512</code>  </td><td class="markdownTableBodyLeft">SHA-512 hardware acceleration present.   </td></tr>
<tr class="markdownTableBody" class="markdownTableRowEven">
<td class="markdownTableBodyLeft"><code>periph_hash_sha_512_224</code>  </td><td class="markdownTableBodyLeft">SHA-512/224 hardware acceleration present.   </td></tr>
<tr class="markdownTableBody" class="markdownTableRowOdd">
<td class="markdownTableBodyLeft"><code>periph_hash_sha_512_256</code>  </td><td class="markdownTableBodyLeft">SHA-512/256 hardware acceleration present.   </td></tr>
<tr class="markdownTableBody" class="markdownTableRowEven">
<td class="markdownTableBodyLeft"><code>periph_hash_sha3_256</code>  </td><td class="markdownTableBodyLeft">SHA-3/256 hardware acceleration present.   </td></tr>
<tr class="markdownTableBody" class="markdownTableRowOdd">
<td class="markdownTableBodyLeft"><code>periph_hash_sha3_384</code>  </td><td class="markdownTableBodyLeft">SHA-3/384 hardware acceleration present.   </td></tr>
<tr class="markdownTableBody" class="markdownTableRowEven">
<td class="markdownTableBodyLeft"><code>periph_hash_sha3_512</code>  </td><td class="markdownTableBodyLeft">SHA-3/512 hardware acceleration present.   </td></tr>
<tr class="markdownTableBody" class="markdownTableRowOdd">
<td class="markdownTableBodyLeft"><code>periph_hmac_sha_256</code>  </td><td class="markdownTableBodyLeft">HMAC SHA-256 hardware acceleration present.   </td></tr>
<tr class="markdownTableBody" class="markdownTableRowEven">
<td class="markdownTableBodyLeft"><code>periph_hwrng</code>  </td><td class="markdownTableBodyLeft">A Hardware Random Number Generator (HWRNG) peripheral is present.   </td></tr>
<tr class="markdownTableBody" class="markdownTableRowOdd">
<td class="markdownTableBodyLeft"><code>periph_cipher_aes_128_cbc</code>  </td><td class="markdownTableBodyLeft">AES 128 CBC hardware acceleration present   </td></tr>
<tr class="markdownTableBody" class="markdownTableRowEven">
<td class="markdownTableBodyLeft"><code>periph_cipher_chacha20</code>  </td><td class="markdownTableBodyLeft">ChaCha20 hardware acceleration present   </td></tr>
<tr class="markdownTableBody" class="markdownTableRowOdd">
<td class="markdownTableBodyLeft"><code>periph_ecc_p192r1</code>  </td><td class="markdownTableBodyLeft">ECC P192R1 hardware acceleration peripheral present.   </td></tr>
<tr class="markdownTableBody" class="markdownTableRowEven">
<td class="markdownTableBodyLeft"><code>periph_ecc_p256r1</code>  </td><td class="markdownTableBodyLeft">ECC P256R1 hardware acceleration peripheral present.   </td></tr>
<tr class="markdownTableBody" class="markdownTableRowOdd">
<td class="markdownTableBodyLeft"><code>periph_ecc_ed25519</code>  </td><td class="markdownTableBodyLeft">ECC Edwards25519 hardware acceleration peripheral present.   </td></tr>
</table>
<h1><a class="anchor" id="autotoc_md2412"></a>
Other Features</h1>
<p>Features that did not fit in any category</p>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadLeft">Feature  </th><th class="markdownTableHeadLeft">Description   </th></tr>
<tr class="markdownTableBody" class="markdownTableRowOdd">
<td class="markdownTableBodyLeft"><code>dbgpin</code>  </td><td class="markdownTableBodyLeft">The platform provides the necessary initialization hooks for the <code>dbgpin</code> module.   </td></tr>
<tr class="markdownTableBody" class="markdownTableRowEven">
<td class="markdownTableBodyLeft"><code>no_idle_thread</code>  </td><td class="markdownTableBodyLeft">The MCU can idle without an idle thread   </td></tr>
<tr class="markdownTableBody" class="markdownTableRowOdd">
<td class="markdownTableBodyLeft"><code>riotboot</code>  </td><td class="markdownTableBodyLeft">The <code>riotboot</code> bootloader is supported.   </td></tr>
<tr class="markdownTableBody" class="markdownTableRowEven">
<td class="markdownTableBodyLeft"><code>ssp</code>  </td><td class="markdownTableBodyLeft">Stack Smashing Protection is supported.   </td></tr>
<tr class="markdownTableBody" class="markdownTableRowOdd">
<td class="markdownTableBodyLeft"><code>tinyusb_device</code>  </td><td class="markdownTableBodyLeft">The TinyUSB network stack is supported and can be selected with <code>USEPKG += tinyusb</code>.   </td></tr>
<tr class="markdownTableBody" class="markdownTableRowEven">
<td class="markdownTableBodyLeft"><code>bootloader_stm32</code>  </td><td class="markdownTableBodyLeft">The MCU has a STM32 bootloader in ROM that can be used for flashing.   </td></tr>
</table>
<h1><a class="anchor" id="autotoc_md2413"></a>
Board Features</h1>
<p>These features indicate features of the board</p>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadLeft">Feature  </th><th class="markdownTableHeadLeft">Description   </th></tr>
<tr class="markdownTableBody" class="markdownTableRowOdd">
<td class="markdownTableBodyLeft"><code>netif</code>  </td><td class="markdownTableBodyLeft">The board has a network interface   </td></tr>
<tr class="markdownTableBody" class="markdownTableRowEven">
<td class="markdownTableBodyLeft"><code>netif_ethernet</code>  </td><td class="markdownTableBodyLeft">The board has an Ethernet network interface   </td></tr>
<tr class="markdownTableBody" class="markdownTableRowOdd">
<td class="markdownTableBodyLeft"><code>netif_openwsn</code>  </td><td class="markdownTableBodyLeft">The board has a network interface suitable for OpenWSN   </td></tr>
<tr class="markdownTableBody" class="markdownTableRowEven">
<td class="markdownTableBodyLeft"><code>highlevel_stdio</code>  </td><td class="markdownTableBodyLeft">A high-level stdio method (such as CDC ACM) is used. This requires a running thread and set-up and will not print during a crash.   </td></tr>
<tr class="markdownTableBody" class="markdownTableRowOdd">
<td class="markdownTableBodyLeft"><code>motor_driver</code>  </td><td class="markdownTableBodyLeft">A motor_driver configuration is present.   </td></tr>
<tr class="markdownTableBody" class="markdownTableRowEven">
<td class="markdownTableBodyLeft"><code>sdcard_spi</code>  </td><td class="markdownTableBodyLeft">An SD-Card SPI configuration is provided.   </td></tr>
</table>
<h2><a class="anchor" id="autotoc_md2414"></a>
STM32L496G Discovery Board Features</h2>
<p>Features available and selectable on the <code>stm32l496-disco</code> board only</p>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadLeft">Feature  </th><th class="markdownTableHeadLeft">Description   </th></tr>
<tr class="markdownTableBody" class="markdownTableRowOdd">
<td class="markdownTableBodyLeft"><code>periph_spi_stmod</code>  </td><td class="markdownTableBodyLeft">By default, solder bridges SB6, SB7, SB8 are closed and USART1 is connected to the Pmod/STMmod+ connector. If these solder bridges are open and solder bridges SB4, SB5 and SB6 are closed instead, SPI2 is connected to the STMmod+/Pmod connector. Request this feature to use SPI2 with this board configuration.   </td></tr>
</table>
</div></div><!-- contents -->
</div><!-- doc-content -->
    <div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
        <ul>
            <li class="footer">Generated on Thu Mar 13 2025 10:38:30 by <a href="http://www.doxygen.org/index.html">
                       <img class="footer" src="doxygen.png" alt="doxygen"></a> 1.8.14</li>
        </ul>
    </div>
    <!-- Include all compiled plugins (below), or include individual files as needed -->
    <script src="bootstrap.min.js"></script>
    <script src="jquery.smartmenus.min.js"></script>
    <script src="jquery.smartmenus.bootstrap.min.js"></script>
    <script src="riot-doxy.js"></script>
  </body>
</html>
