<!DOCTYPE html>
<html lang="en">
  <head>
    <link rel="icon" type="image/png" href="favicon.png">
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <!-- The above 3 meta tags *must* come first in the head; any other head content must come *after* these tags -->
    <title>PSA Cryptographic API</title>
    <!-- jQuery (necessary for Bootstrap's JavaScript plugins) -->
    <script src="jquery.min.js"></script>
    <script src="jquery.powertip.min.js"></script>
    <script src="jquery-ui.min.js"></script>
    <script src="jquery.scrollTo.min.js"></script>
    <script src="doxy-jquery.js"></script>
    <script src="dynsections.js"></script>
    <link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
  $(document).ready(initResizable);
/* @license-end */</script>
    <link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
    <!-- Bootstrap -->
    <link href="doxygen.css" rel="stylesheet">
    <link href="fonts.css" rel="stylesheet">
    <link href="bootstrap.min.css" rel="stylesheet">
    <link href="jquery.smartmenus.bootstrap.css" rel="stylesheet">
    <link href="riot.css" rel="stylesheet">
    <!-- HTML5 shim and Respond.js for IE8 support of HTML5 elements and media queries -->
    <!-- WARNING: Respond.js doesn't work if you view the page via file:// -->
    <!--[if lt IE 9]>
      <script src="https://oss.maxcdn.com/html5shiv/3.7.3/html5shiv.min.js"></script>
      <script src="https://oss.maxcdn.com/respond/1.4.2/respond.min.js"></script>
    <![endif]-->
        <script>
            function displaySR(){
            searchBox.Search();
            var rhtml=(document.getElementById('MSearchResults').contentWindow.document.body.innerHTML).replace(/href=\"\.\.\//g,'href="');
            document.getElementById('MSearchResultsWindow').style.display='none';
            document.getElementById('top').append(document.getElementById('MSearchSelectWindow'));
            document.getElementById('top').append(document.getElementById('MSearchResultsWindow'));
            document.getElementById('doc-content').innerHTML=rhtml;
            }
            function modSearch(){
            if(!searchBox.doxySearch){
                searchBox.doxySearch=searchBox.Search
                searchBox.Search= function(){this.doxySearch();
                var r=document.getElementById('MSearchResultsWindow');console.log(r.style);
                if(parseInt(r.style.left)<0)r.style.left=0;
                var x=document.getElementById('MSearchResults');
                if(x.scrollWidth>window.screen.width)x.style.width=window.screen.width-2+'px';
                var f=document.getElementById('riot-searchform');
                if(parseInt( r.style.top) < f.offsetTop+f.scrollHeight) r.style.top = f.offsetTop+f.scrollHeight+'px';}
            }
            }
        </script>
  </head>
  <body>
      <div id="top">
        <nav class="navbar navbar-inverse">
          <div class="container-fluid">
            <!-- Brand and toggle get grouped for better mobile display -->
            <div class="navbar-header">
              <button type="button" class="navbar-toggle collapsed" data-toggle="collapse" data-target="#navbar-collapse" aria-expanded="false">
                <span class="sr-only">Toggle navigation</span>
                <span class="icon-bar"></span>
                <span class="icon-bar"></span>
                <span class="icon-bar"></span>
              </button>
              <a class="navbar-brand" id="brand-logo" href="http://riot-os.org"><img height="40px" src="riot-logo.svg" /></a>
              <p class="navbar-text text-center visible-xs">Documentation</p>
            </div>
            <!-- Collect the nav links, forms, and other content for toggling -->
            <div class="collapse navbar-collapse" id="navbar-collapse">
              <p class="navbar-text navbar-left"><span id="projectbrief">The friendly Operating System for the Internet of Things</span></p>
              <ul id="riot-navlist" class="nav navbar-nav"></ul>
              <form id="riot-searchform" class="navbar-form navbar-left navbar-right" action="https://duckduckgo.com/" method="get">
                 <input type="hidden" name="sites" value="doc.riot-os.org"/>
                 <input type="hidden" name="kt" value="h"/>
                 <div class="form-group">
                   <div id="MSearchBox" class="MSearchBoxActive">
                     <div class="input-group">
                       <div class="input-group-addon">
                         <span id="MSearchSelect" class="glyphicon glyphicon-search" aria-hidden="true" onmouseover="return searchBox.OnSearchSelectShow()" onmouseout="return searchBox.OnSearchSelectHide()"></span>
                       </div>
                       <input class="form-control" type="text" name="q" id="MSearchField" placeholder="Search" accesskey="S" onfocus="searchBox.OnSearchFieldFocus(true)" onblur="searchBox.OnSearchFieldFocus(false)" onkeyup="searchBox.OnSearchFieldChange(event); modSearch();">
                       <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()">
                         <span id="search-reset" class="glyphicon glyphicon-remove-circle" aria-hidden="true"></span>
                       </a>
                     </div>
                   </div>
                 </div>
              </form>
            </div><!-- /.navbar-collapse -->
          </div><!-- /.container-fluid -->
        </nav>
      </div>
<!-- Generated by Doxygen 1.8.14 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(document).ready(function(){initNavTree('group__sys__psa__crypto.html','');});
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#groups">Modules</a> &#124;
<a href="#files">Files</a>  </div>
  <div class="headertitle">
<div class="title">PSA Cryptographic API<div class="ingroups"><a class="el" href="group__sys.html">System</a></div></div>  </div>
</div><!--header-->
<div class="contents">

<p>Implements the PSA Crypto API specification.  
<a href="#details">More...</a></p>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<p>Implements the PSA Crypto API specification. </p>
<dl class="section see"><dt>See also</dt><dd><a href="https://armmbed.github.io/mbed-crypto/html/">https://armmbed.github.io/mbed-crypto/html/</a></dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>This implementation is not complete and not yet thoroughly tested. Please do not use this module in production, as it may introduce security issues.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>This implementation is not complete and will be successively expanded.</dd></dl>
<h1><a class="anchor" id="About"></a>
About </h1>
<p>This module implements the PSA Cryptography API Version 1.1 as specified <a href="https://armmbed.github.io/mbed-crypto/html/">here</a> and the PSA Status code API Version 1.0 as specified <a href="https://arm-software.github.io/psa-api/status-code/1.0/">here</a>. It provides an OS level access to cryptographic operations and supports software and hardware backends as well as the use of secure elements. The API automatically builds a hardware backend for an operation, if there's one available, otherwise it falls back to software. Specific backends can be configured, if needed. For configuration options see <a href="#configuration">Configuration</a>.</p>
<p>PSA Crypto has an integrated key management module, which stores keys internally without exposing them to applications. To learn how to use keys with PSA, read <a href="#using-keys">Using Keys</a>.</p>
<p>A basic usage and configuration example can be found in <code>examples/advanced/psa_crypto</code>. For more usage instructions, please read the documentation.</p>
<p>If you want to add your own crypto backend, see <a href="#porting-guide">Porting Guide</a>.</p>
<h1><a class="anchor" id="autotoc_md2163"></a>
Basic Usage</h1>
<p>To use PSA Crypto, add <code><a class="el" href="crypto_8h.html" title="Function declarations for PSA Crypto. ">psa/crypto.h</a></code> to your includes. This will make all operations and macros available.</p>
<p>Call <code><a class="el" href="crypto_8h.html#a2de150803fc2f7dc6101d5af7e921dd9" title="Library initialization. ">psa_crypto_init()</a></code> before calling any other operation.</p>
<h2><a class="anchor" id="autotoc_md2164"></a>
Structure Initialization</h2>
<p>Whenever you declare a PSA Crypto structure (e.g. operation contexts or key attributes), it needs to be initialized with zeroes. A structure that is not initialized will be interpreted by PSA as <em>active</em> and can not be used for a new operation. The example function and macro shown below result in the same thing: A new, inactive structure.</p>
<div class="fragment"><div class="line"><span class="comment">// Choose one of these options</span></div><div class="line"><a class="code" href="structpsa__hash__operation__s.html">psa_hash_operation_t</a> hash_op = <a class="code" href="crypto__struct_8h.html#ac74804b4466452143112398ec3c7ee6a">psa_hash_operation_init</a>();</div><div class="line"><a class="code" href="structpsa__hash__operation__s.html">psa_hash_operation_t</a> hash_op = <a class="code" href="crypto__struct_8h.html#a6ab7fe8d3500bc2f21be840b4f4f8d1d">PSA_HASH_OPERATION_INIT</a>;</div></div><!-- fragment --><p>An already active operation can be set to zero by reinitializing it. It then becomes <em>inactive</em> again and can be used for a new operation.</p>
<p>When errors occur during execution, PSA resets the operation contexts and makes them <em>inactive</em>, to prevent unauthorized access to an operation's state. Users can also call <code>psa_&lt;operation&gt;_abort()</code> anytime in between function calls to do the same.</p>
<h1><a class="anchor" id="using-keys"></a>
Using Keys </h1>
<p>PSA can only operate on keys, that are registered with and stored within the internal key storage module. This means you need to either generate keys with PSA or import an existing key. For this purpose there are a number of <a href="https://armmbed.github.io/mbed-crypto/html/api/keys/management.html">key management functions</a> (external link).</p>
<h2><a class="anchor" id="autotoc_md2165"></a>
Key Attributes</h2>
<p>When creating a key for PSA, the implementation needs to know what kind of key it is dealing with, what it can be used for, where it's supposed to be stored, etc. That information needs to be specified in a set of <a href="https://armmbed.github.io/mbed-crypto/html/api/keys/attributes.html">Key Attributes</a> (external link).</p>
<p>The example below defines attributes for an AES-128 key, which can be used for CBC encryption and decryption and will be stored in local volatile memory. </p><div class="fragment"><div class="line"><span class="comment">// Initializes empty attributes structure</span></div><div class="line"><a class="code" href="structpsa__key__attributes__s.html">psa_key_attributes_t</a> attributes = <a class="code" href="attributes_8h.html#a06966a8812aacd323ccdf06dbb43667d">psa_key_attributes_init</a>();</div><div class="line"></div><div class="line"><span class="comment">// Set all necessary attributes</span></div><div class="line"><a class="code" href="crypto_8h.html#ac03ccf09ca6d36cc3d5b43f8303db6f7">psa_set_key_lifetime</a>(&amp;attributes, <a class="code" href="lifetime_8h.html#a8b438870ba69489b685730d346455108">PSA_KEY_LIFETIME_VOLATILE</a>);</div><div class="line"><a class="code" href="crypto_8h.html#a6857ef0ecb3fa844d4536939d9c64025">psa_set_key_type</a>(&amp;attributes, <a class="code" href="psa__crypto_2psa_2key_2type_8h.html#a6ee54579dcf278c677eda4bb1a29575e">PSA_KEY_TYPE_AES</a>);</div><div class="line"><a class="code" href="crypto_8h.html#af61683ac87f87687a40262b5afbfa018">psa_set_key_bits</a>(&amp;attributes, 128);</div><div class="line"><a class="code" href="crypto_8h.html#aeb8341ca52baa0279475ea3fd3bcdc98">psa_set_key_algorithm</a>(&amp;attributes, <a class="code" href="cipher_2algorithm_8h.html#acb332d72716958880ee7f97d8365ae66">PSA_ALG_CBC_NO_PADDING</a>);</div><div class="line"><a class="code" href="crypto_8h.html#a42a65b3c4522ce9b67ea5ea7720e17de">psa_set_key_usage_flags</a>(&amp;attributes, (<a class="code" href="usage_8h.html#a75153b296d045d529d97203a6a995dad">PSA_KEY_USAGE_ENCRYPT</a> | <a class="code" href="usage_8h.html#ac3f2d2e5983db1edde9f142ca9bf8e6a">PSA_KEY_USAGE_DECRYPT</a>));</div></div><!-- fragment --><p>After setting the attributes, an exiting key can be imported: </p><div class="fragment"><div class="line">uint8_t aes_key[] = { ... };</div><div class="line"><a class="code" href="id_8h.html#a11e986351c65bd3dc3c0fe2cd9926e4b">psa_key_id_t</a> key_id = 0;     <span class="comment">// Will be set by PSA Crypto</span></div><div class="line">psa_status_t status = <a class="code" href="crypto_8h.html#ad088d8ebc854d2f7a5b5c1769bc9ed40">psa_import_key</a>(&amp;attributes, aes_key, <span class="keyword">sizeof</span>(aes_key), &amp;key_id);</div></div><!-- fragment --><p> The PSA Crypto implementation will assign an identifier to the key and return it via the <code>key_id</code> parameter. This identifier can then be used for operations with this specific key. </p><div class="fragment"><div class="line">uint8_t PLAINTEXT[] = { ... };</div><div class="line"><span class="comment">// Buffer sizes can be calculated with macros</span></div><div class="line"><span class="keywordtype">size_t</span> output_buf_size = <a class="code" href="crypto__sizes_8h.html#ada02457bee639a10a0c3ddbe1f73fedc">PSA_CIPHER_ENCRYPT_OUTPUT_SIZE</a>(<a class="code" href="psa__crypto_2psa_2key_2type_8h.html#a6ee54579dcf278c677eda4bb1a29575e">PSA_KEY_TYPE_AES</a>, <a class="code" href="cipher_2algorithm_8h.html#acb332d72716958880ee7f97d8365ae66">PSA_ALG_CBC_NO_PADDING</a>,<span class="keyword">sizeof</span>(PLAINTEXT));</div><div class="line">uint8_t output_buffer[output_buf_size];</div><div class="line"></div><div class="line">status = <a class="code" href="crypto_8h.html#a0ba1e627bd194914ef9297212dd423f9">psa_cipher_encrypt</a>(key_id, <a class="code" href="cipher_2algorithm_8h.html#acb332d72716958880ee7f97d8365ae66">PSA_ALG_CBC_NO_PADDING</a>, PLAINTEXT, <span class="keyword">sizeof</span>(PLAINTEXT),output_buffer, <span class="keyword">sizeof</span>(output_buffer), &amp;output_length));</div></div><!-- fragment --><p>All the supported key types, algorithms and usage flags can be found in the documentation.</p>
<h3><a class="anchor" id="key-lifetime"></a>
Key Lifetime</h3>
<h4><a class="anchor" id="autotoc_md2166"></a>
Volatile vs. Persistent</h4>
<p>The PSA API specifies two ways of storing keys: volatile and persistent. Volatile keys will be stored only in RAM, which means they will be destroyed after application termination or a device reset. Persistent keys will also be written into flash memory for later access. To destroy them they must be explicitly deleted with the <code><a class="el" href="crypto_8h.html#af503cd251eff1a0d6cd7d8e47003b92e" title="Destroy a key. ">psa_destroy_key()</a></code> function.</p>
<dl class="section note"><dt>Note</dt><dd>Persistent key storage can be optionally enabled on <code>native</code> and on the <code>nRF52840dk</code>. For this, add <code>USEMODULE += psa_persistent_storage</code> to your application makefile or <code>CONFIG_MODULE_PSA_PERSISTENT_STORAGE=y</code> to your <code>app.config.test</code> file. Example: <code>tests/sys/psa_crypto_persistent_storage</code></dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>Be aware that the current implementation writes keys in plain text to flash memory. Anyone with hardware access can read them.</dd></dl>
<h4><a class="anchor" id="autotoc_md2167"></a>
Lifetime Encoding</h4>
<p>When creating a key, the user needs to specify a lifetime value, which actually consists of two values: persistence and location. The location defines the actual memory location of the key (e.g. whether the key will be stored in RAM, in a hardware protected memory slot or on an external device like a secure element).</p>
<p>The persistence value defines whether the key will be stored in RAM (volatile) in flash (persistent). Some default values that exist are:</p><ul>
<li><a class="el" href="lifetime_8h.html#a8b438870ba69489b685730d346455108">PSA_KEY_LIFETIME_VOLATILE</a> (stored in local, volatile memory)</li>
<li><a class="el" href="lifetime_8h.html#a3713a01c5fcd5f7eae46ff22ceaf6d02">PSA_KEY_LIFETIME_PERSISTENT</a> (stored in local, persistent memory)</li>
</ul>
<p>Other lifetime values can be constructed with the macro <code><a class="el" href="lifetime_8h.html#aef4d244b4d33ae7876ed87226b8112aa" title="Construct a lifetime from a persistence level and a location. ">PSA_KEY_LIFETIME_FROM_PERSISTENCE_AND_LOCATION(persistence, location)</a></code>. All supported <code>PSA_KEY_PERSISTENCE_*</code> and <code>PSA_KEY_LOCATION_*</code> values can be combined.</p>
<p>In addition to the location values defined by the specification, this implementation also supports values for <a href="#secure-elements">Secure Elements</a>.</p>
<h1><a class="anchor" id="configuration"></a>
Configuration </h1>
<p>Currently there are two ways to configure PSA Crypto: Kconfig and Makefiles. An example for both can be found in <code>RIOT/examples/advanced/psa_crypto</code>.</p>
<h2><a class="anchor" id="autotoc_md2168"></a>
Kconfig</h2>
<p>We recommend using Kconfig and choosing your features in <code>menuconfig</code>. You can access the GUI by calling</p>
<div class="fragment"><div class="line">TEST_KCONFIG=1 BOARD=&lt;your board&gt; make menuconfig</div></div><!-- fragment --><p>from your application directory. There you can find the available PSA features and options under <code>System-&gt;PSA Crypto</code>. If you only select the operations you want to use (e.g. <code>PSA Ciphers-&gt;AES-128 CBC</code>), Kconfig will automatically select the best backend for you depending on the board (e.g. a hardware accelerator if it is available). Optionally you can force a custom backend.</p>
<p>Further you can specify the exact number of keys you need to store (section <code>PSA Key Management Configuration</code> in <code>menuconfig</code>), or choose your <a href="#secure-elements">Secure Element</a> configurations.</p>
<p>Alternatively you can create an <code>app.config.test</code> file in your application folder and choose your symbols there (see <code>examples/advanced/psa_crypto</code>).</p>
<p>In the <code>app.config.test</code> file, modules can be chosen with the following syntax: <code>CONFIG_MODULE_&lt;MODULENAME&gt;=y</code>, as shown below. </p><div class="fragment"><div class="line">CONFIG_MODULE_PSA_CRYPTO=y</div><div class="line">CONFIG_MODULE_PSA_CIPHER=y</div><div class="line">CONFIG_MODULE_PSA_CIPHER_AES_128_CBC=y</div></div><!-- fragment --><h2><a class="anchor" id="autotoc_md2169"></a>
Makefiles</h2>
<p>If you don't want to use Kconfig, you can use the traditional way in RIOT of selecting modules in your application Makefile.</p>
<p>Here you need to set the base module and individual modules for each operation you need. The example below also chooses a default backend depending on your board. </p><div class="fragment"><div class="line"><span class="comment">// Base module: this is required!</span></div><div class="line">USEMODULE += psa_crypto</div><div class="line"></div><div class="line">USEMODULE += psa_cipher</div><div class="line">USEMODULE += psa_cipher_aes_128_cbc</div></div><!-- fragment --><p>If desired, you can choose a specific backend at compile time. For this you need to specify that you want to set a custom backend and then explicitly choose the one you want (see below). </p><div class="fragment"><div class="line">USEMODULE += psa_cipher_aes_128_cbc_custom_backend</div><div class="line">USEMODULE += psa_cipher_aes_128_cbc_backend_riot</div></div><!-- fragment --><p>The currently available modules, are listed <a href="#available-modules">below</a>.</p>
<h2><a class="anchor" id="configuration-keys"></a>
Key Slot Types</h2>
<p>The key management of PSA keeps track of keys by storing them in virtual key slot representations, along with their attributes. Since keys can come in various sizes, it would be inefficient to allocate the same amount of memory for all keys. To reduce the amount of memory used for key storage, PSA internally differentiates between three types of key slots (see below). Depending on the operations your application uses, PSA will automatically detect the key sizes needed and will allocate the required memory. The number of key slots allocated of each type is set to five per default, but can be changed by the user depending on their requirements.</p>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone">Single Key Slot  </th><th class="markdownTableHeadNone">Asymmetric Key Slot  </th><th class="markdownTableHeadNone">Protected Key Slot   </th></tr>
<tr class="markdownTableBody" class="markdownTableRowOdd">
<td class="markdownTableBodyNone">Single keys or unstructured data,<br />
e.g. AES keys or asymmetric<br />
public keys in local memory  </td><td class="markdownTableBodyNone">Asymmetric key pairs&lt;br&gt;(private and public parts) <br />
in local memory  </td><td class="markdownTableBodyNone">Any keys stored on a secure<br />
element or on-chip in<br />
hardware protected memory   </td></tr>
</table>
<p>If you want to change the default number of allocated key slots you can do so by updating the number in <code>menuconfig</code>, or adding them to the <code>app.config.test</code> file like so: </p><div class="fragment"><div class="line"><a class="code" href="crypto__sizes_8h.html#aea807017642c077d1d4b7fa113985ddb">CONFIG_PSA_SINGLE_KEY_COUNT</a>=3</div><div class="line"><a class="code" href="crypto__sizes_8h.html#a323dc56e20302a949b301849ea9b8c90">CONFIG_PSA_ASYMMETRIC_KEYPAIR_COUNT</a>=1</div><div class="line"><a class="code" href="crypto__sizes_8h.html#aa85f11e7660db8293f1c5cdb0563363a">CONFIG_PSA_PROTECTED_KEY_COUNT</a>=2</div></div><!-- fragment --><p>When using Makefiles, you can pass CFLAGS as shown below. </p><div class="fragment"><div class="line">CFLAGS += -DCONFIG_PSA_SINGLE_KEY_COUNT=3</div><div class="line">CFLAGS += -DCONFIG_PSA_ASYMMETRIC_KEYPAIR_COUNT=1</div><div class="line">CFLAGS += -DCONFIG_PSA_PROTECTED_KEY_COUNT=2</div></div><!-- fragment --><dl class="section note"><dt>Note</dt><dd>The key slot count defines the maximum number of keys that can be cached in RAM at runtime. It does not limit the number of persistent keys that can be stored in flash memory. It is the user's responsibility to keep track of the number of persistently stored keys.</dd></dl>
<h2><a class="anchor" id="available-modules"></a>
Available Modules</h2>
<p>Below are the currently available modules. No matter which operation you need, you always have to choose the base module. If you want to specify a backend other than the default, you need to select <code>psa_&lt;operation&gt;_custom_backend</code> in addition to the actual backend module.</p>
<p>The names listed are are the version used in makefiles with the <code>USEMODULE += &lt;modulename&gt;</code> syntax. In Kconfig you don't need to know the exact names, you can simply choose the features in <code>menuconfig</code>. When using <code>app.config.test</code> files in your application directory, you need to write the names in uppercase and add the prefix <code>CONFIG_MODULE_</code> to all of them.</p>
<h3><a class="anchor" id="autotoc_md2170"></a>
Key Storage</h3>
<ul>
<li>Persistent Key Storage: psa_persistent_storage</li>
</ul>
<h3><a class="anchor" id="autotoc_md2171"></a>
Asymmetric Crypto</h3>
<ul>
<li>Base: psa_asymmetric</li>
</ul>
<h4><a class="anchor" id="autotoc_md2172"></a>
NIST ECC P192</h4>
<ul>
<li>psa_asymmetric_ecc_p192r1</li>
<li>psa_asymmetric_ecc_p192r1_backend_periph</li>
<li>psa_asymmetric_ecc_p192r1_custom_backend</li>
<li>psa_asymmetric_ecc_p192r1_backend_microecc</li>
</ul>
<h4><a class="anchor" id="autotoc_md2173"></a>
NIST ECC P192</h4>
<ul>
<li>psa_asymmetric_ecc_p256r1</li>
<li>psa_asymmetric_ecc_p256r1_backend_periph</li>
<li>psa_asymmetric_ecc_p256r1_custom_backend</li>
<li>psa_asymmetric_ecc_p256r1_backend_microecc</li>
</ul>
<h4><a class="anchor" id="autotoc_md2174"></a>
Ed25519</h4>
<ul>
<li>psa_asymmetric_ecc_ed25519</li>
<li>psa_asymmetric_ecc_ed25519_backend_periph</li>
<li>psa_asymmetric_ecc_ed25519_custom_backend</li>
<li>psa_asymmetric_ecc_ed25519_backend_c25519</li>
</ul>
<h3><a class="anchor" id="autotoc_md2175"></a>
Ciphers</h3>
<ul>
<li>Base: psa_cipher</li>
</ul>
<h4><a class="anchor" id="autotoc_md2176"></a>
AES ECB</h4>
<ul>
<li>psa_cipher_aes_128_ecb</li>
<li>psa_cipher_aes_128_ecb_backend_riot</li>
</ul>
<h4><a class="anchor" id="autotoc_md2177"></a>
AES CBC</h4>
<ul>
<li>psa_cipher_aes_128_cbc</li>
<li>psa_cipher_aes_128_cbc_backend_periph</li>
<li>psa_cipher_aes_128_cbc_custom_backend</li>
<li>psa_cipher_aes_128_cbc_backend_riot</li>
<li>psa_cipher_aes_192_cbc</li>
<li>psa_cipher_aes_192_cbc_custom_backend</li>
<li>psa_cipher_aes_192_cbc_backend_riot</li>
<li>psa_cipher_aes_256_cbc</li>
<li>psa_cipher_aes_256_cbc_custom_backend</li>
<li>psa_cipher_aes_256_cbc_backend_riot</li>
</ul>
<h4><a class="anchor" id="autotoc_md2178"></a>
CHACHA20</h4>
<ul>
<li>psa_cipher_chacha20</li>
<li>psa_cipher_chacha20_backend_periph</li>
<li>psa_cipher_chacha20_custom_backend</li>
<li>psa_cipher_chacha20_backend_riot</li>
</ul>
<h3><a class="anchor" id="autotoc_md2179"></a>
Hashes</h3>
<ul>
<li>Base: psa_hash</li>
</ul>
<h4><a class="anchor" id="autotoc_md2180"></a>
MD5</h4>
<ul>
<li>psa_hash_md5</li>
<li>psa_hash_md5_custom_backend</li>
<li>psa_hash_md5_backend_riot</li>
</ul>
<h4><a class="anchor" id="autotoc_md2181"></a>
SHA 1</h4>
<ul>
<li>psa_hash_sha_1</li>
<li>psa_hash_sha_1_backend_periph</li>
<li>psa_hash_sha_1_custom_backend</li>
<li>psa_hash_sha_1_backend_riot</li>
</ul>
<h4><a class="anchor" id="autotoc_md2182"></a>
SHA 224</h4>
<ul>
<li>psa_hash_sha_224</li>
<li>psa_hash_sha_224_backend_periph</li>
<li>psa_hash_sha_224_custom_backend</li>
<li>psa_hash_sha_224_backend_riot</li>
</ul>
<h4><a class="anchor" id="autotoc_md2183"></a>
SHA 256</h4>
<ul>
<li>psa_hash_sha_256</li>
<li>psa_hash_sha_256_backend_periph</li>
<li>psa_hash_sha_256_custom_backend</li>
<li>psa_hash_sha_256_backend_riot</li>
</ul>
<h4><a class="anchor" id="autotoc_md2184"></a>
SHA 384</h4>
<ul>
<li>psa_hash_sha_384</li>
<li>psa_hash_sha_384_backend_periph</li>
<li>psa_hash_sha_384_custom_backend</li>
<li>psa_hash_sha_384_backend_riot</li>
</ul>
<h4><a class="anchor" id="autotoc_md2185"></a>
SHA 512</h4>
<ul>
<li>psa_hash_sha_512</li>
<li>psa_hash_sha_512_backend_periph</li>
<li>psa_hash_sha_512_custom_backend</li>
<li>psa_hash_sha_512_backend_riot</li>
</ul>
<h4><a class="anchor" id="autotoc_md2186"></a>
SHA 512/224</h4>
<ul>
<li>psa_hash_sha_512_224</li>
<li>psa_hash_sha_512_224_backend_periph</li>
<li>psa_hash_sha_512_224_custom_backend</li>
<li>psa_hash_sha_512_224_backend_riot</li>
</ul>
<h4><a class="anchor" id="autotoc_md2187"></a>
SHA 512/256</h4>
<ul>
<li>psa_hash_sha_512_256</li>
<li>psa_hash_sha_512_256_backend_periph</li>
<li>psa_hash_sha_512_256_custom_backend</li>
<li>psa_hash_sha_512_256_backend_riot</li>
</ul>
<h4><a class="anchor" id="autotoc_md2188"></a>
SHA 3/256</h4>
<ul>
<li>psa_hash_sha3_256</li>
<li>psa_hash_sha3_256_backend_periph</li>
<li>psa_hash_sha3_256_custom_backend</li>
<li>psa_hash_sha3_256_backend_riot</li>
</ul>
<h4><a class="anchor" id="autotoc_md2189"></a>
SHA 3/384</h4>
<ul>
<li>psa_hash_sha3_384</li>
<li>psa_hash_sha3_384_backend_periph</li>
<li>psa_hash_sha3_384_custom_backend</li>
<li>psa_hash_sha3_384_backend_riot</li>
</ul>
<h4><a class="anchor" id="autotoc_md2190"></a>
SHA 3/512</h4>
<ul>
<li>psa_hash_sha3_512</li>
<li>psa_hash_sha3_512_backend_periph</li>
<li>psa_hash_sha3_512_custom_backend</li>
<li>psa_hash_sha3_512_backend_riot</li>
</ul>
<h3><a class="anchor" id="autotoc_md2191"></a>
MAC</h3>
<ul>
<li>Base: psa_mac</li>
</ul>
<h4><a class="anchor" id="autotoc_md2192"></a>
HMAC SHA 256</h4>
<ul>
<li>psa_mac_hmac_sha_256</li>
<li>psa_mac_hmac_sha_256_backend_periph</li>
<li>psa_mac_hmac_sha_256_custom_backend</li>
<li>psa_mac_hmac_sha_256_backend_riot</li>
</ul>
<h3><a class="anchor" id="autotoc_md2193"></a>
Secure Elements</h3>
<p>Base:</p><ul>
<li>psa_secure_element</li>
<li>psa_secure_element_multiple</li>
</ul>
<h4><a class="anchor" id="autotoc_md2194"></a>
SE Types</h4>
<ul>
<li>psa_secure_element_ateccx08a</li>
<li>psa_secure_element_ateccx08a_cipher_aes_128</li>
<li>psa_secure_element_ateccx08a_ecc_p256</li>
<li>psa_secure_element_ateccx08a_hmac_sha256</li>
</ul>
<h1><a class="anchor" id="rng"></a>
Random Number Generation </h1>
<p>Currently uses the <a href="#sys_random">RIOT Random Module</a> as a backend. See the documentation for configuration options.</p>
<h1><a class="anchor" id="secure-elements"></a>
Secure Elements </h1>
<p>An example showing the use of SEs can be found in <code>examples/advanced/psa_crypto</code>.</p>
<p>To use secure elements, you first need to assign a static location value to each device, so PSA can find it. If you only use one device, you can use <code>PSA_KEY_LOCATION_PRIMARY_SECURE_ELEMENT</code>. For additional devices this value must be within the range of <code>PSA_KEY_LOCATION_SE_MIN</code> and <code>PSA_KEY_LOCATION_SE_MAX</code>. When booting the system, the <code>auto_init</code> module in RIOT will automatically register the device with the location with PSA Crypto.</p>
<p>You can now import or create keys on the secure element by constructing a key lifetime containing a device's location value.</p>
<div class="fragment"><div class="line"><a class="code" href="lifetime_8h.html#a6821ff6dd39dc2bc370ded760ad8b0cf">psa_key_lifetime_t</a> lifetime =</div><div class="line">     <a class="code" href="lifetime_8h.html#aef4d244b4d33ae7876ed87226b8112aa">PSA_KEY_LIFETIME_FROM_PERSISTENCE_AND_LOCATION</a> (<a class="code" href="lifetime_8h.html#a8b438870ba69489b685730d346455108">PSA_KEY_LIFETIME_VOLATILE</a>,</div><div class="line">                                                     <a class="code" href="lifetime_8h.html#a7159eb4b29fe3459a99e005efb32f38d">PSA_KEY_LOCATION_PRIMARY_SECURE_ELEMENT</a>);</div></div><!-- fragment --><p>Some secure elements come with their own key management and device configurations. In this case the configuration parameters must be passed to PSA Crypto during the registration. For this, you need to define a <code><a class="el" href="unionpsa__se__config__t.html" title="Structure containing device specific configuration data. ">psa_se_config_t</a></code> structure containing the configuration. PSA Crypto will use this structure to keep track of what types of keys are allowed on the device and how much storage is available. Where this structure should be placed, how it looks and what parameters are required depends on the type of your device.</p>
<p>A good place to define that structure and the location values is a drivers <code>&lt;driver&gt;_params.h</code> file, but this may vary depending on how your device is integrated in RIOT.</p>
<p>For detailed, device specific information, please check the device driver documentation or the example.</p>
<h2><a class="anchor" id="autotoc_md2195"></a>
Available Devices and Drivers</h2>
<ul>
<li>ATECCX08A: <a href="#psa-cryptoauthlib">Microchip Cryptoauthlib as a PSA backend</a></li>
</ul>
<h2><a class="anchor" id="autotoc_md2196"></a>
Main SE Configuration</h2>
<p>To use SEs, the appropriate modules must be chosen in Kconfig: </p><div class="fragment"><div class="line">CONFIG_PSA_SECURE_ELEMENT=y</div><div class="line">CONFIG_PSA_SECURE_ELEMENT_ATECCX08A=y        <span class="comment">// device example</span></div><div class="line">CONFIG_PSA_SECURE_ELEMENT_ATECCX08A_ECC_P256=y</div></div><!-- fragment --><p>or added to the Makefile: </p><div class="fragment"><div class="line">USEMODULE += psa_secure_element</div><div class="line">USEMODULE += psa_secure_element_ateccx08a        <span class="comment">// device example</span></div><div class="line">USEMODULE += psa_secure_element_ateccx08a_ecc_p256</div></div><!-- fragment --><p>This implementation supports the use of one or more secure elements (SE) as backends. In this case the number of used secure elements must be specified (must be at least 2 and at most 255). When using more than one SE, add </p><div class="fragment"><div class="line">CONFIG_PSA_SECURE_ELEMENT_MULTIPLE=y</div><div class="line"><a class="code" href="group__psa__crypto__se__mgmt.html#ga9c8f4ca1b4eba3dc9280377e7afe65e6">CONFIG_PSA_MAX_SE_COUNT</a>=2                    <span class="comment">// or any other number between 2 and 255</span></div></div><!-- fragment --><p>or, respectively,</p>
<div class="fragment"><div class="line">USEMODULE += psa_secure_element_multiple</div><div class="line">CFLAGS += -DCONFIG_PSA_MAX_SE_COUNT=2        <span class="comment">// or any other number between 2 and 255</span></div></div><!-- fragment --><h1><a class="anchor" id="porting-guide"></a>
Porting Guide </h1>
<p>This porting guide focuses on how to add your software library or hardware driver as a backend to PSA Crypto without actually touching the PSA implementation. We will provide some <a href="#porting-general">general information</a> and then some case examples for different kinds of backends:</p><ul>
<li><a href="#porting-software">Software Libraries</a></li>
<li><a href="#porting-hardware">Hardware Drivers</a></li>
<li><a href="#porting-secure-elements">Secure Elements</a></li>
</ul>
<p>Some examples to look at are:</p><ul>
<li><a href="#sys_hashes">RIOT hash module</a></li>
<li><a href="#sys_crypto">RIOT cipher module</a></li>
<li><a href="#pkg_micro_ecc">Micro-ECC</a></li>
<li><a href="#pkg_driver_cryptocell_310">CryptoCell 310 driver</a>.</li>
</ul>
<p>An example integrating a secure element can be found in the <a href="#pkg_cryptoauthlib">Cryptoauthlib Package</a>.</p>
<h2><a class="anchor" id="porting-general"></a>
General Information</h2>
<h3><a class="anchor" id="autotoc_md2197"></a>
Error Values</h3>
<p>You should always check the status of your function calls and translate your library's or driver's errors to PSA error values (please be as thorough as possible). The PSA Crypto specification describes exactly what kind of error values should be returned by which function. Please read the API documentation and comply with the instructions. We recommend writing a<code>&lt;mylibrary&gt;_to_psa_error()</code> function right in the beginning (see for example <code><a class="el" href="psa__error_8h.html#ab307f06eca19636806ea2895c9b49652" title="Convert CryptoCell CRYS errors to PSA status values. ">CRYS_to_psa_error()</a></code> in <code>pkg/driver_cryptocell_310/psa_cryptocell_310/error_conversion.c</code>).</p>
<h3><a class="anchor" id="autotoc_md2198"></a>
The Build System</h3>
<p>As mentioned before, there are two ways of selecting build time configurations in RIOT: Kconfig and Makefiles. Kconfig dependency resolution is currently an experimental feature and will at some point replace Makefiles. Until then, our implementation needs to support both, which means we need to define features and symbols in multiple places. Luckily, the modules have the exact same names in both systems, which makes the transfer easier. The examples below show both ways.</p>
<h3><a class="anchor" id="module-names"></a>
Modules</h3>
<p>In RIOT, module names are generated from path names, so if you create a directory for your sourcefiles, the module name will be the same as the directory name. It is possible to change that by declaring a new module name in the Makefile by adding the line <code>MODULE := your_module_name</code>.</p>
<p>If you leave it like this, all sourcefiles in the path corresponding to the module name will be built (e.g. if you choose the module <code>hashes</code>, all files in <code>sys/hashes</code> will be included). For better configurability it is possible to add submodules (see <code>sys/hashes/psa_riot_hashes</code> for example). In that case the base module name will be the directory name and each file inside the directory becomes its own submodule that must be explicitly chosen. The module name will then be the directory name with the file name as a postfix. For example: </p><div class="fragment"><div class="line">USEMODULE += hashes</div><div class="line">USEMODULE += psa_riot_hashes</div><div class="line">USEMODULE += psa_riot_hashes_sha_256</div><div class="line"></div><div class="line">will build the file at `sys/hashes/psa_riot_hashes/sha_256.c`, but none of the other files in</div><div class="line">the directory.</div><div class="line"></div><div class="line">To enable submodules <span class="keywordflow">for</span> your implementation add the following to the directory makefile:</div><div class="line">@code</div><div class="line">BASE_MODULE := psa_&lt;modulename&gt;</div><div class="line">SUBMODULES := 1</div></div><!-- fragment --><p>We also need to create so-called pseudomodules for each available submodule. Those must follow the scheme <code>psa_&lt;modulename&gt;_&lt;filename&gt;</code>. Where they are declared depends on where your module is located. Pseudomodules in <code>RIOT/sys</code> must be added in <code><a class="el" href="pseudomodules_8inc_8mk_source.html">pseudomodules.inc.mk</a></code>. When integrating packages or drivers, the pseudomodules can be added in the <code>Makefile.include</code> file of the individual module's directory (see <code>pkg/micro-ecc/Makefile.include</code>).</p>
<p>When adding backends to PSA Crypto, please name your modules in ways that fit within the current naming scheme: <code>psa_&lt;library&gt;_&lt;algorithm&gt;</code>. Also, when adding software libraries and hardware drivers, use the submodule approach. That makes PSA Crypto more configurable.</p>
<p>The drawback of the submodule approach is, that if one of our sourcefiles depends on another sourcefile in the same folder, we need to select it explicitly. For example, in <code>pkg/driver_cryptocell_310/psa_cryptocell_310</code> you can see that there are some common source files that all the others use (e.g. for hashes there is a <code>hashes_common.c</code> file).</p>
<p>If that is the case for your driver, you need to make sure the modules are selected in the Kconfig file as well as the <code>Makefile.dep</code> file (see <code>psa_cryptocell_310/Makefile.dep</code> or <code>psa_cryptocell_310/Kconfig</code>).</p>
<h3><a class="anchor" id="glue-code"></a>
Adding Glue Code</h3>
<p>We define a number of wrapper APIs, which are called by PSA to invoke crypto backends. Software libraries and hardware drivers use the same methods, secure elements are handled in a different way (see <a href="#porting-secure-elements">Case Example – Secure Elements</a> for details).</p>
<p>The names, parameters and return values for wrapper methods are defined in header files in <code>sys/psa_crypto/include/psa_&lt;algorithm&gt;.h</code>. The functions declared in those files are the ones that are currently supported by this PSA implementation. They will be extended in the future.</p>
<p>You need to implement those functions with glue code calling your library or driver code and converting types and error values between PSA and your backend. Below is an example of how this might look (it's very reduced, your library may need much more glue code). </p><div class="fragment"><div class="line">psa_status_t <a class="code" href="group__sys__psa__crypto__ecc.html#ga999306493c27f60e83d71e2cf567b5b8">psa_ecc_p256r1_sign_hash</a>(<span class="keyword">const</span> <a class="code" href="structpsa__key__attributes__s.html">psa_key_attributes_t</a> *attributes,</div><div class="line">                                      psa_algorithm_t alg, <span class="keyword">const</span> uint8_t *key_buffer,</div><div class="line">                                      <span class="keywordtype">size_t</span> key_buffer_size, <span class="keyword">const</span> uint8_t *hash,</div><div class="line">                                      <span class="keywordtype">size_t</span> hash_length, uint8_t *signature,</div><div class="line">                                      <span class="keywordtype">size_t</span> signature_size, <span class="keywordtype">size_t</span> *signature_length)</div><div class="line">{</div><div class="line">    <span class="keywordtype">int</span> status = &lt;libraryname&gt;_&lt;sign_hash_func&gt;(key_buffer, hash, hash_length,</div><div class="line">                                           signature, signature_length, curve);</div><div class="line"></div><div class="line">    <span class="keywordflow">if</span> (status != SUCCESS) {</div><div class="line">        return &lt;libraryname&gt;_status_to_psa_error(status);</div><div class="line">    }</div><div class="line"></div><div class="line">    (void)alg;</div><div class="line">    (void)attributes;</div><div class="line">    (void)key_buffer_size;</div><div class="line">    <span class="keywordflow">return</span> PSA_SUCCESS;</div><div class="line">}</div></div><!-- fragment --><h3><a class="anchor" id="autotoc_md2199"></a>
Operation Contexts</h3>
<p>Some cryptographic operations use driver specific context to store the operation state in between function calls. These must be defined somewhere. Examples can be found in <code><a class="el" href="psa__periph__hashes__ctx_8h.html" title="CryptoCell 310 driver specific hash contexts. ">pkg/driver_cryptocell_310/include/psa_periph_hashes_ctx.h</a></code> and <code><a class="el" href="riot__hashes_8h_source.html">sys/include/hashes/psa/riot_hashes.h</a></code>.</p>
<p>When defining the contexts for a hardware driver, all you need to do is add a file called <code>psa_periph_&lt;algorithm&gt;_ctx.h</code> to your driver's include folder and define the available types (see supported <a href="#supported-types">types</a> below). Those files are automatically included in <code><a class="el" href="crypto__includes_8h_source.html">crypto_includes.h</a></code> and it is important that they always have the same name for each algorithm.</p>
<p>When defining the contexts for a software library, the headerfile should be called <code>&lt;library&gt;_&lt;algorithm&gt;.h</code> (e.g. <code><a class="el" href="riot__hashes_8h_source.html">riot_hashes.h</a></code>) and must be added to <code><a class="el" href="crypto__includes_8h_source.html">crypto_includes.h</a></code> as shown below: </p><div class="fragment"><div class="line"><span class="preprocessor">#if IS_USED(MODULE_PSA_&lt;LIBRARY&gt;_&lt;ALGORITHM&gt;)</span></div><div class="line"><span class="preprocessor">#include &quot;&lt;library&gt;</span>/&lt;library&gt;_&lt;algorithm&gt;.h<span class="stringliteral">&quot;</span></div><div class="line"><span class="stringliteral">#endif</span></div></div><!-- fragment --><p>When defining the context types, those must always depend on the specific algorithm module, for example </p><div class="fragment"><div class="line"><span class="preprocessor">#if IS_USED(MODULE_PSA_&lt;LIBRARY&gt;_HASHES_SHA_256)</span></div><div class="line"><span class="preprocessor">#include &quot;path/to/headerfile_containing_the_driver_context_definition&quot;</span></div><div class="line"></div><div class="line">typedef &lt;library_context_type_t&gt; <a class="code" href="psa__periph__hashes__ctx_8h.html#a83a959f81cb5d96f5b7a7b20ffc4af67">psa_hashes_sha256_ctx_t</a>;</div><div class="line"><span class="preprocessor">#endif</span></div></div><!-- fragment --><h4><a class="anchor" id="supported-types"></a>
Hashes</h4>
<ul>
<li><code>psa_hashes_md5_ctx_t</code></li>
<li><code>psa_hashes_sha1_ctx_t</code></li>
<li><code>psa_hashes_sha224_ctx_t</code></li>
<li><code>psa_hashes_sha256_ctx_t</code></li>
<li><code>psa_hashes_sha384_ctx_t</code></li>
<li><code>psa_hashes_sha512_ctx_t</code></li>
<li><code>psa_hashes_sha512_224_ctx_t</code></li>
<li><code>psa_hashes_sha512_256_ctx_t</code></li>
</ul>
<h4><a class="anchor" id="autotoc_md2200"></a>
Ciphers</h4>
<ul>
<li><code>psa_cipher_aes_128_ctx_t</code></li>
<li><code>psa_cipher_aes_192_ctx_t</code></li>
<li><code>psa_cipher_aes_256_ctx_t</code></li>
</ul>
<p>Secure Elements need their own contexts. For this, see <a href="#porting-secure-elements">Case Example – Secure Elements</a>.</p>
<h2><a class="anchor" id="autotoc_md2201"></a>
Adding a Backend</h2>
<p>The integration of hardware drivers, software libraries and secure element drivers differs a bit. Below we describe the necessary steps for each of them.</p>
<h3><a class="anchor" id="porting-software"></a>
Case Example – A Software Library</h3>
<p>Software libraries are the easiest backends, because they are not platform or hardware specific. They can generally run on all platforms in RIOT and we can combine different software backends for different operations (we could, for example, use the Micro-ECC package for ECC NIST curves and the C25519 package for operations with the Curve25519).</p>
<p>Let's say we have an imaginary software library called <code>FancyCrypt</code> and want to use it as a backend of PSA. We've already added it to RIOT as a third party package in <code>pkg/fancycrypt</code>. Our library provides hashes and elliptic curve operations and to make it accessible to PSA Crypto we need to write wrappers for our API calls.</p>
<p>First we create a folder called <code>psa_fancycrypt</code> in the package directory. Inside we create a file with the name of each operation you want to integrate, e.g. <code>p256.c</code> and <code>hashes_sha_224.c</code> (when adding operations, remember that the path of the files will also be the <a href="#module-names">module name</a>, so please comply with the current naming scheme).</p>
<p>In these files we need to implement the methods that are called by PSA as described <a href="#glue-code">above</a>.</p>
<h4><a class="anchor" id="autotoc_md2202"></a>
Adding Makefiles</h4>
<p>We add a Makefile to the <code>psa_fancycrypt</code> folder with the following content: </p><div class="fragment"><div class="line">BASE_MODULE := psa_fancycrypt</div><div class="line">SUBMODULES := 1</div><div class="line"></div><div class="line">include $(RIOTBASE)/Makefile.base</div></div><!-- fragment --><p>This tells RIOT that the <code>psa_fancycrypt</code> module has submodules, which can be selected individually.</p>
<p>In <code>pkg/fancycrypt</code> we now need to declare explicit pseudomodules in <code>Makefile.include</code> and add the <code>psa_fancycrypt</code> folder to the source files and the <code>sys/psa_crypto/include</code> folder to the includes. These should be dependent on the PSA Crypto module as shown below.</p>
<div class="fragment"><div class="line">ifneq (,$(filter psa_fancycrypt_%, $(USEMODULE)))</div><div class="line">    PSEUDOMODULES += psa_fancycrypt_hashes_sha_256</div><div class="line">    PSEUDOMODULES += psa_fancycrypt_p256</div><div class="line">    DIRS += $(RIOTPKG)/fancycrypt/psa_fancycrypt</div><div class="line">    INCLUDES += -I$(RIOTBASE)/sys/psa_crypto/include</div><div class="line">endif</div></div><!-- fragment --><p>If the implementation has any dependencies, they need to be added in <code>Makefile.dep</code>, for example: </p><div class="fragment"><div class="line">USEMODULE += psa_fancycrypt</div><div class="line">USEMODULE += psa_fancycrypt_error_conversion</div><div class="line"></div><div class="line">ifneq (,$(filter psa_fancycrypt_hashes_sha1,$(USEMODULE)))</div><div class="line">  USEMODULE += psa_fancycrypt_hashes_common</div><div class="line">endif</div></div><!-- fragment --><h4><a class="anchor" id="autotoc_md2203"></a>
Adding a Kconfig file</h4>
<p>We add a file called <code>Kconfig</code> to the <code>psa_fancycrypt</code> folder. Here we declare the modules for Kconfig like so: </p><div class="fragment"><div class="line">config MODULE_PSA_FANCYCRYPT_HASHES_SHA_256</div><div class="line">    <span class="keywordtype">bool</span></div><div class="line">    depends on MODULE_PSA_CRYPTO</div><div class="line">    <a class="code" href="group__posix__select.html#ga7ffa34f8c9a12e7fd43f5ef65bf889fa">select</a> MODULE_PSA_FANCYCRYPT</div><div class="line"></div><div class="line">config MODULE_PSA_FANCYCRYPT_P256</div><div class="line">    <span class="keywordtype">bool</span></div><div class="line">    depends on MODULE_PSA_CRYPTO</div><div class="line">    <a class="code" href="group__posix__select.html#ga7ffa34f8c9a12e7fd43f5ef65bf889fa">select</a> MODULE_PSA_FANCYCRYPT</div><div class="line"></div><div class="line">config MODULE_PSA_FANCYCRYPT</div><div class="line">    <span class="keywordtype">bool</span></div></div><!-- fragment --><p>If the implementation has any dependencies, we can select them in this Kconfig file: </p><div class="fragment"><div class="line">config MODULE_PSA_FANCYCRYPT_HASHES_SHA_256</div><div class="line">    <span class="keywordtype">bool</span></div><div class="line">    depends on MODULE_PSA_CRYPTO</div><div class="line">    <a class="code" href="group__posix__select.html#ga7ffa34f8c9a12e7fd43f5ef65bf889fa">select</a> MODULE_PSA_FANCYCRYPT</div><div class="line">    <a class="code" href="group__posix__select.html#ga7ffa34f8c9a12e7fd43f5ef65bf889fa">select</a> MODULE_PSA_FANCYCRYPT_HASHES_COMMON</div><div class="line">    <a class="code" href="group__posix__select.html#ga7ffa34f8c9a12e7fd43f5ef65bf889fa">select</a> MODULE_PSA_FANCYCRYPT_ERROR_CONVERSION</div></div><!-- fragment --><p>In <code>pkg/fancycrypt/Kconfig</code> we need to add the line </p><div class="fragment"><div class="line">rsource <span class="stringliteral">&quot;psa_fancycrypt/Kconfig&quot;</span></div></div><!-- fragment --><p> at the bottom.</p>
<h4><a class="anchor" id="autotoc_md2204"></a>
Telling PSA Crypto about it</h4>
<p>To be able to choose <code>fancycrypt</code> as a PSA backend, we need to add the option to the Kconfig and Makefiles of the PSA Crypto Module.</p>
<p>In <code>sys/psa_crypto/</code> we need to modify <code>Kconfig.asymmetric</code>, <code>sys/psa_crypto/Kconfig.hashes</code>, <code>Makefile.dep</code> and <code>Makefile.include</code>.</p>
<p>To <code>Kconfig.asymmetric</code> we need to add </p><div class="fragment"><div class="line">config MODULE_PSA_ASYMMETRIC_ECC_P256R1_BACKEND_FANCYCRYPT</div><div class="line">    <span class="keywordtype">bool</span> <span class="stringliteral">&quot;FancyCrypt Package&quot;</span></div><div class="line">    <a class="code" href="group__posix__select.html#ga7ffa34f8c9a12e7fd43f5ef65bf889fa">select</a> PACKAGE_FANCYCRYPT</div><div class="line">    <a class="code" href="group__posix__select.html#ga7ffa34f8c9a12e7fd43f5ef65bf889fa">select</a> MODULE_PSA_FANCYCRYPT_P256</div></div><!-- fragment --><p> This will expose FancyCrypt as a backend option in PSA and then enable all the necessary features, when users select it. You need to do the same thing for the hash operation in <code>Kconfig.hashes</code>.</p>
<p>To achieve the same thing with Makefiles we need to do this in two places: In <code>Makefile.include</code> there are some existing pseudomodules for asymmetric crypto and hashes. There we need to create the backend modules for FancyCrypt by adding</p>
<div class="fragment"><div class="line">PSEUDOMODULES += psa_asymmetric_ecc_p256r1_backend_fancycrypt</div></div><!-- fragment --><p>and</p>
<div class="fragment"><div class="line">PSEUDOMODULES += psa_hash_sha_256_backend_fancycrypt</div></div><!-- fragment --><p>The automatic module selection happens in <code>Makefile.dep</code>. To the place where exiting P256 curves and hashes are selected we add cases for our backend modules:</p>
<div class="fragment"><div class="line">ifneq (,$(filter psa_asymmetric_ecc_p256r1_backend_fancycrypt,$(USEMODULE)))</div><div class="line">    USEPKG += fancycrypt</div><div class="line">    USEMODULE += psa_fancycrypt</div><div class="line">    USEMODULE += psa_fancycrypt_p256</div><div class="line">endif</div></div><!-- fragment --><p>Now you should be able to select your package as a backend for PSA Crypto and use it to perform operations.</p>
<h3><a class="anchor" id="porting-hardware"></a>
Case Example – A Hardware Driver</h3>
<p>The first steps of porting a hardware driver are the same as for the software library. Only we skip the last part where we add the modules to the PSA Crypto Kconfig and Makefiles and do something else instead.</p>
<p>Hardware drivers are treated a little differently, mostly because they are tied to a specific platform and users can not just choose a different driver for their accelerator. Therefore we just want PSA Crypto to automatically use this driver whenever it runs on the corresponding platform, which means that we have to add some additional options and features, not only to the driver but also to the CPU it belongs to. A good example for this is the <a href="#pkg_driver_cryptocell_310">CryptoCell 310 driver</a> for the accelerator on the <a href="#cpu_nrf52">nRF52840 CPU</a>.</p>
<p>Now, let's say we have a CPU called <code>myCPU</code> with an on-chip accelerator called <code>speedycrypt</code>. Let's say that <code>speedycrypt</code> provides hashes and ECC curves. The vendor provides a driver, which we already have included in RIOT as a package. Also we've followed the steps in the <a href="#glue-code">glue code section</a> and provide a folder called <code>pkg/driver_speedycrypt/psa_speedycrypt</code> with the required wrapper files. We have also added the module names in a Kconfig file and in the Makefiles.</p>
<h4><a class="anchor" id="autotoc_md2205"></a>
Telling PSA Crypto about it</h4>
<p>This is where we diverge from the software library example. If you take a look at the available backends in PSA, you'll notice one with the postfix <code>*_BACKEND_PERIPH</code> for each available algorithm. <b>Periph</b> here is short for <em>peripheral hardware accelerator</em>. The <code>*_BACKEND_PERIPH</code> modules depend on the presence of such an accelerator. They are a generic module for all crypto hardware accelerators and will automatically resolve to the driver that is associated with the available accelerator.</p>
<p>Before we're able to use it we need to tell RIOT that those hardware features exist for our <code>myCPU</code> (see <code>cpu/nrf52/Kconfig</code> and <code>cpu/nrf52/Makefile.features</code> as an example). In <code>cpu/myCPU</code> we add all the provided features as shown below.</p>
<p>Files we need to touch:</p><ul>
<li><code>cpu/myCPU/Makefile.features</code></li>
<li><code>cpu/myCPU/Kconfig</code></li>
<li><code>cpu/myCPU/periph/Makefile.dep</code></li>
<li><code>cpu/myCPU/periph/Kconfig</code></li>
<li>When defining new features: <code>RIOT/kconfigs/Kconfig.features</code></li>
</ul>
<p><b>cpu/myCPU/Makefile.features:</b> </p><div class="fragment"><div class="line">FEATURES_PROVIDED += periph_speedycrypt      <span class="comment">// General feature for the accelerator</span></div><div class="line">FEATURES_PROVIDED += periph_hash_sha_256</div><div class="line">FEATURES_PROVIDED += periph_ecc_p256r1</div></div><!-- fragment --><p><b>cpu/myCPU/Kconfig:</b> </p><div class="fragment"><div class="line">config CPU_FAM_MYCPU</div><div class="line">    <span class="keywordtype">bool</span></div><div class="line">    <a class="code" href="group__posix__select.html#ga7ffa34f8c9a12e7fd43f5ef65bf889fa">select</a> CPU_SOME_FEATURES</div><div class="line">     ...</div><div class="line">    <a class="code" href="group__posix__select.html#ga7ffa34f8c9a12e7fd43f5ef65bf889fa">select</a> HAS_PERIPH_HASH_SHA_256</div><div class="line">    <a class="code" href="group__posix__select.html#ga7ffa34f8c9a12e7fd43f5ef65bf889fa">select</a> HAS_PERIPH_ECC_P256R1</div><div class="line">    <a class="code" href="group__posix__select.html#ga7ffa34f8c9a12e7fd43f5ef65bf889fa">select</a> HAS_PERIPH_SPEEDYCRYPT</div></div><!-- fragment --><p> The <code>HAS_PERIPH_*</code> symbols are defined in ``. If your device provides capabilities that are not yet defined, you can add them to that file.</p>
<p>Next we need to define selectable modules for this in the <code>cpu/myCPU/periph</code> folder, which then automatically enable the driver. An example for this is <code>cpu/nrf52/periph</code>. We add the following to the <code>cpu/myCPU/periph/Kconfig</code> file and <code>cpu/myCPU/periph/Makefile.dep</code>:</p>
<p><b>cpu/myCPU/periph/Makefile.dep:</b> </p><div class="fragment"><div class="line">ifneq (,$(filter periph_hash_sha_256,$(USEMODULE)))</div><div class="line">    USEPKG += driver_speedycrypt</div><div class="line">    USEMODULE += psa_speedycrypt_hashes_sha256</div><div class="line">endif</div></div><!-- fragment --><p><b>cpu/myCPU/periph/Kconfig:</b> </p><div class="fragment"><div class="line">config MODULE_PERIPH_FANCYCRYPT</div><div class="line">    <span class="keywordtype">bool</span></div><div class="line">    depends on HAS_PERIPH_FANCYCRYPT</div><div class="line">    <a class="code" href="group__posix__select.html#ga7ffa34f8c9a12e7fd43f5ef65bf889fa">select</a> PACKAGE_DRIVER_FANCYCRYPT</div><div class="line"></div><div class="line">config MODULE_PERIPH_HASH_SHA_256</div><div class="line">    <span class="keywordtype">bool</span></div><div class="line">    depends on HAS_PERIPH_HASH_SHA_256</div><div class="line">    <a class="code" href="group__posix__select.html#ga7ffa34f8c9a12e7fd43f5ef65bf889fa">select</a> MODULE_PERIPH_SPEEDYCRYPT</div><div class="line">    <a class="code" href="group__posix__select.html#ga7ffa34f8c9a12e7fd43f5ef65bf889fa">select</a> MODULE_PSA_SPEEDYCRYPT_HASHES_SHA256</div></div><!-- fragment --><p>Here we basically say "If the user chooses the `periph_hash_sha_256 module`, also select the
`periph_speedycrypt` feature, which will then enable the speedycrypt driver". Of course you need to do this for all your available features.</p>
<p>Now, if you build PSA Crypto with default configurations, it should automatically detect that your board has a hardware accelerator for hashes and ECC operations and build the hardware driver as a backend.</p>
<h3><a class="anchor" id="porting-secure-elements"></a>
Case Example – A Secure Element Driver</h3>
<p>Secure elements (SEs) are handled almost completely separate from the other backends. When we use software libraries or hardware drivers, we only build one implementation per algorithm. When it comes to secure elements we want to be able to build them in addition to the other backends and we may want to connect and use more than one of them at the same time. Another difference is that when using software libraries and hardware drivers, PSA handles the storage of key material. When using SEs, keys are stored on the SE, which means, we need additional functionality for the key management.</p>
<p>An existing example in RIOT is the Microchip ATECCX08A device family, whose driver can be found in <code>pkg/cryptoauthlib</code>.</p>
<p>PSA Crypto has an integrated SE driver registry, which stores all registered drivers in a list. When an application calls a cryptographic operation that's supposed to be performed by a secure element, the registry will find the correct driver in the list and PSA will invoke the operation. Each driver is stored with a context that contains persistent as well as transient driver data. Transient driver data can be anything the driver needs to function. Persistent data is supposed to be used to keep track of how many keys are stored on the device and if there is still some free space available.</p>
<dl class="section note"><dt>Note</dt><dd>Currently PSA does not support persistent storage, so the persistent driver data is not really persistent, yet. Once persistent storage is implemented, this data will be stored, so the implementation can find already existing keys again after a reboot.</dd></dl>
<p>For this example we integrate an imaginary SE called <code>superSE</code>, which comes with a driver called <code>superSE_lib</code>. Again, we assume that we have already added the driver as a package in RIOT and it can be found at <code>pkg/superse_lib</code>.</p>
<h4><a class="anchor" id="autotoc_md2206"></a>
Adding the Glue Code</h4>
<p>Secure element drivers need to implement a different API than the other backends. It is defined <a href="#sys_psa_crypto_se_driver">here</a>. In our package folder we now create a new folder called <code>psa_superse_driver</code> and add a source file called <code>psa_superse_lib_driver.c</code>. Here we now implement glue code for all the cryptographic operations our SE supports.</p>
<p>You will notice that the SE interface also provides some key management functions. This is because keys are stored on the device and PSA can not access the memory and key data itself, but needs to tell the driver to do it.</p>
<h3><a class="anchor" id="autotoc_md2207"></a>
Operation Contexts</h3>
<p>Some operations need driver specific contexts. For secure elements these are wrapped in types defined in <code><a class="el" href="crypto__contexts_8h.html" title="Context definitions for PSA Crypto. ">crypto_contexts.h</a></code> (currently only <code>psa_se_cipher_context_t</code> is supported). In this header file add operation contexts that belong to your driver to the available SE context unions as shown in the example below:</p>
<div class="fragment"><div class="line"><span class="keyword">typedef</span> <span class="keyword">struct </span>{</div><div class="line">    <span class="keyword">union </span>driver_context {</div><div class="line">        <span class="keywordtype">unsigned</span> dummy;</div><div class="line"><span class="preprocessor">    #if IS_USED(MODULE_PSA_SECURE_ELEMENT_ATECCX08A) || defined(DOXYGEN)</span></div><div class="line">        atca_aes_cbc_ctx_t atca_aes_cbc;</div><div class="line"><span class="preprocessor">    #endif</span></div><div class="line"><span class="preprocessor">    #if IS_USED(MODULE_PSA_SECURE_ELEMENT_SUPERSE) || defined(DOXYGEN)</span></div><div class="line">        superse_cipher_ctx_t superse_aes_cbc;</div><div class="line"><span class="preprocessor">    #endif</span></div><div class="line">    } drv_ctx;</div><div class="line">} psa_se_cipher_context_t;</div></div><!-- fragment --><h4><a class="anchor" id="autotoc_md2208"></a>
Allocation</h4>
<p>The first thing PSA will do, when an application creates a key on an SE, is ask the driver to find a free key slot on the device. This is what the <code>allocate</code> function is for. How exactly the slot is allocated, depends on the driver. It may be possible to query that information directly from the device. If that is not possible, we can use the persistent data stored in the driver context. An example for this can be found in <code>pkg/cryptoauthlib/psa_atca_driver/psa_atca_se_driver.c</code>. This example requires the user to provide information about the configurations for each key slot, which is then stored in the persistent driver data and used for key management (for a better description read <a href="#psa-cryptoauthlib">Using Cryptoauthlib as a backend for PSA Crypto</a>). At this point you can decide what the best approach for your device is.</p>
<p>The <code>allocate</code> function should then return some reference to the slot it has allocated for the key (possibly a pointer or a slot number). Next PSA Crypto will invoke the <code>import</code> or <code>generate</code> function to store a key.</p>
<h4><a class="anchor" id="autotoc_md2209"></a>
Using Persistent Data</h4>
<p>When you want to use persistent data to keep track of keys, you should utilize the <code><a class="el" href="unionpsa__se__config__t.html" title="Structure containing device specific configuration data. ">psa_se_config_t</a></code> structure, which is declared in <code><a class="el" href="crypto__se__config_8h.html" title="Define structures für SE slot configurations. ">crypto_se_config.h</a></code>. You can define a structure that can hold your device configuration and make sure it is available then your SE is used.</p>
<h4><a class="anchor" id="autotoc_md2210"></a>
Making the Methods Available</h4>
<p>At the bottom of the wrapper code, define structures with pointers to the available methods. For example if you have implemented a <code>superse_allocate</code> and <code>superse_generate_key</code> function, you need to add a <code><a class="el" href="structpsa__drv__se__key__management__t.html" title="A struct containing all of the function pointers needed to for secure element key management...">psa_drv_se_key_management_t</a></code> structure as shown below. Fill the unimplemented methods with <code>NULL</code> pointers. The last structure should be a <code><a class="el" href="structpsa__drv__se__t.html" title="A structure containing pointers to all the entry points of a secure element driver. ">psa_drv_se_t</a></code> struct containing pointers to the other structures. That one will be stored during driver registration to get access to all the implemented functions.</p>
<div class="fragment"><div class="line"><span class="keyword">static</span> <a class="code" href="structpsa__drv__se__key__management__t.html">psa_drv_se_key_management_t</a> superse_key_management = {</div><div class="line">    .<a class="code" href="structpsa__drv__se__key__management__t.html#ada92ba1ee99afb1e8ac719e2feeee4cc">p_allocate</a> = superse_allocate,</div><div class="line">    .p_validate_slot_number = NULL,</div><div class="line">    .p_import = NULL,</div><div class="line">    .p_generate = superse_generate_key,</div><div class="line">    .p_destroy = NULL,</div><div class="line">    .p_export = NULL,</div><div class="line">    .p_export_public = NULL</div><div class="line">};</div><div class="line"></div><div class="line"><a class="code" href="structpsa__drv__se__t.html">psa_drv_se_t</a> superse_methods = {</div><div class="line">    .<a class="code" href="structpsa__drv__se__t.html#aeca4c14c7327c4b40ffb84aab6121d1f">hal_version</a> = <a class="code" href="group__sys__psa__crypto__se__driver.html#ga65e25a718c3e95893522ae882d4ea826">PSA_DRV_SE_HAL_VERSION</a>,</div><div class="line">    .persistent_data_size = 0,</div><div class="line">    .p_init = NULL,</div><div class="line">    .key_management = &amp;superse_key_management,</div><div class="line">    .mac = NULL,</div><div class="line">    .cipher = NULL,</div><div class="line">    .aead = NULL,</div><div class="line">    .asymmetric = NULL,</div><div class="line">    .derivation = NULL</div><div class="line">};</div></div><!-- fragment --><p>You should do this for all available functions. The structures for the functions are declared in <code><a class="el" href="psa__crypto__se__driver_8h.html" title="PSA external cryptoprocessor driver module. ">sys/psa_crypto/include/psa_crypto_se_driver.h</a></code>.</p>
<h4><a class="anchor" id="autotoc_md2211"></a>
Driver Registration</h4>
<p>At start-up all secure element drivers need to be registered with the PSA SE management module. This happens by calling <code><a class="el" href="group__psa__crypto__se__mgmt.html#ga8c311a8c2fbf766df233237569b6cc34" title="Register a secure element driver with the SE management. ">psa_register_secure_element()</a></code> during the automatic driver initialization in RIOT. When you added support for our device to RIOT, you should have implemented an <code>auto_init_&lt;device&gt;</code> function, which initializes the connected devices. In this function, after initializing a device, you should call <code><a class="el" href="group__psa__crypto__se__mgmt.html#ga8c311a8c2fbf766df233237569b6cc34" title="Register a secure element driver with the SE management. ">psa_register_secure_element()</a></code> and pass the device's location value, and pointers to the <code><a class="el" href="structpsa__drv__se__t.html" title="A structure containing pointers to all the entry points of a secure element driver. ">psa_drv_se_t</a></code> structure, the persistent data and some device specific context. An example implementation of this can be seen in <code>sys/auto_init/security/auto_init_atca.c</code>.</p>
<h4><a class="anchor" id="autotoc_md2212"></a>
Telling PSA Crypto about it</h4>
<p>To be able to choose our <code>superSE</code> during configuration, we need to define the corresponding modules in the Kconfig files and Makefiles.</p>
<p>To <code>pkg/super_se_lib/Kconfig</code> we add something like </p><div class="fragment"><div class="line">config MODULE_PSA_SUPERSE_DRIVER</div><div class="line">    <span class="keywordtype">bool</span></div><div class="line">    depends on PACKAGE_SUPERSE_LIB</div><div class="line">    <span class="keywordflow">default</span> y <span class="keywordflow">if</span> MODULE_PSA_CRYPTO</div><div class="line">    <a class="code" href="group__posix__select.html#ga7ffa34f8c9a12e7fd43f5ef65bf889fa">select</a> PSA_KEY_MANAGEMENT</div></div><!-- fragment --><p> This tells the build system that whenever this driver and PSA Crypto are used at the same time, the wrapper and the PSA key management module are needed, too.</p>
<p>To <code>sys/psa_crypto/psa_se_mgmt/Kconfig</code> we add a menu for the SE like so: </p><div class="fragment"><div class="line">menuconfig MODULE_PSA_SECURE_ELEMENT_SUPERSE</div><div class="line">    <span class="keywordtype">bool</span> <span class="stringliteral">&quot;Our Vendor&#39;s SuperSE&quot;</span></div><div class="line">    <a class="code" href="group__posix__select.html#ga7ffa34f8c9a12e7fd43f5ef65bf889fa">select</a> PACKAGE_SUPERSE_LIB</div><div class="line">    depends on &lt;whatever protocol is needed <span class="keywordflow">for</span> communication, e.g. HAS_PERIPH_I2C&gt;</div><div class="line">    help</div><div class="line">        &lt;Some helpful information about <span class="keyword">this</span> module&gt;</div></div><!-- fragment --><p> This makes our driver selectable whenever an application configuration selects the PSA secure element module.</p>
<p>As described in the <a href="#configuration-keys">Configuration Section</a>, references to keys on secure elements are stored by PSA in a different type of key slot than other keys. The slot for protected keys usually only contains a slot number or address and not the actual key, which requires a lot less memory space.</p>
<p><b>BUT:</b> If your secure element supports asymmetric cryptography and exports a public key part during key generation, that key part must be stored somewhere. So when you choose an asymmetric operation, the protected key slots will have the space to store a public key.</p>
<h4><a class="anchor" id="autotoc_md2213"></a>
Dependencies</h4>
<p>Secure Element operations also depend on the PSA modules. E.g. when you want to use an ECC operation, you need to make sure that you also build the asymmetric PSA functions.</p>
<p>For this we need to add the following to the <code>superSE</code> menu: </p><div class="fragment"><div class="line">config MODULE_PSA_SECURE_ELEMENT_SUPERSE_ECC_P256</div><div class="line">    <span class="keywordtype">bool</span> <span class="stringliteral">&quot;Our Vendor&#39;s Elliptic Curve P256&quot;</span></div><div class="line">    <a class="code" href="group__posix__select.html#ga7ffa34f8c9a12e7fd43f5ef65bf889fa">select</a> PSA_KEY_SIZE_256</div><div class="line">    <a class="code" href="group__posix__select.html#ga7ffa34f8c9a12e7fd43f5ef65bf889fa">select</a> MODULE_PSA_ASYMMETRIC</div><div class="line">    depends on MODULE_PSA_SECURE_ELEMENT_SUPERSE</div></div><!-- fragment --><p> This tells us, what size a key slot should have to store the public key. If your SE supports other curves, you need to modify this accordingly or add more of them.</p>
<p>Now we need to add the same to the Makefiles. In <code>Makefile.include</code> we add the source file path and the PSA include folders and define the new available pseudomodules: </p><div class="fragment"><div class="line">ifneq (,$(filter psa_crypto,$(USEMODULE)))</div><div class="line">    DIRS += $(RIOTPKG)/superse_lib/psa_superse_driver</div><div class="line">    INCLUDES += -I$(RIOTBASE)/sys/psa_crypto/include</div><div class="line">    PSEUDOMODULES += psa_secure_element_superse</div><div class="line">    PSEUDOMODULES += psa_secure_element_superse_ecc_p256</div><div class="line">endif</div></div><!-- fragment --><p>In <code>Makefile.dep</code> we automatically add required modules when PSA Crypto and the ECC curve module are chosen: </p><div class="fragment"><div class="line">ifneq (,$(filter psa_crypto,$(USEMODULE)))</div><div class="line">  USEMODULE += psa_superse_driver</div><div class="line">endif</div><div class="line"></div><div class="line">ifneq (,$(filter psa_secure_element_superse_ecc_p256, $(USEMODULE)))</div><div class="line">  USEMODULE += psa_asymmetric</div><div class="line">endif</div></div><!-- fragment --><p> This needs to be done for all other supported operations (e.g. ATECCX08 operations in <code>pkg/cryptoauthlib/Makefile.include</code>, <code>pkg/cryptoauthlib/Makefile.dep</code> and <code>sys/psa_crypto/psa_se_mgmt/Kconfig</code>. Now the secure element should be available for use with PSA Crypto. </p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="groups"></a>
Modules</h2></td></tr>
<tr class="memitem:group__sys__psa__crypto__cbor__encoder"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__sys__psa__crypto__cbor__encoder.html">Module for encoding PSA keys in CBOR</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:group__sys__psa__crypto__alg__disp"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__sys__psa__crypto__alg__disp.html">PSA Crypto Algorithm Dispatcher</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:group__sys__psa__crypto__slot__mgmt"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__sys__psa__crypto__slot__mgmt.html">PSA Crypto Key Slot Management</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:group__sys__psa__crypto__loc__disp"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__sys__psa__crypto__loc__disp.html">PSA Crypto Location Dispatcher</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:group__sys__psa__crypto__pers__stor"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__sys__psa__crypto__pers__stor.html">PSA Crypto Persistent Storage API</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:group__psa__crypto__se__mgmt"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__psa__crypto__se__mgmt.html">PSA Crypto SE Management</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:group__sys__psa__crypto__se__driver"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__sys__psa__crypto__se__driver.html">PSA Crypto Secure Element Wrapper</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:group__sys__psa__crypto__cipher"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__sys__psa__crypto__cipher.html">PSA Wrapper Functions: Cipher</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:group__sys__psa__crypto__ecc"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__sys__psa__crypto__ecc.html">PSA Wrapper Functions: ECC</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:group__sys__psa__crypto__hashes"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__sys__psa__crypto__hashes.html">PSA Wrapper Functions: Hashes</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:group__sys__psa__crypto__mac"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__sys__psa__crypto__mac.html">PSA Wrapper Functions: MAC</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="files"></a>
Files</h2></td></tr>
<tr class="memitem:aead_2algorithm_8h"><td class="memItemLeft" align="right" valign="top">file &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="aead_2algorithm_8h.html">algorithm.h</a></td></tr>
<tr class="memdesc:aead_2algorithm_8h"><td class="mdescLeft">&#160;</td><td class="mdescRight">AEAD algorithm definitions for the PSA Crypto API. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:asymmetric__encryption_2algorithm_8h"><td class="memItemLeft" align="right" valign="top">file &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="asymmetric__encryption_2algorithm_8h.html">algorithm.h</a></td></tr>
<tr class="memdesc:asymmetric__encryption_2algorithm_8h"><td class="mdescLeft">&#160;</td><td class="mdescRight">Asymmetric encryption algorithm definitions for the PSA Crypto API. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:asymmetric__signature_2algorithm_8h"><td class="memItemLeft" align="right" valign="top">file &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="asymmetric__signature_2algorithm_8h.html">algorithm.h</a></td></tr>
<tr class="memdesc:asymmetric__signature_2algorithm_8h"><td class="mdescLeft">&#160;</td><td class="mdescRight">Asymmetric signature algorithm definitions for the PSA Crypto API. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:cipher_2algorithm_8h"><td class="memItemLeft" align="right" valign="top">file &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cipher_2algorithm_8h.html">algorithm.h</a></td></tr>
<tr class="memdesc:cipher_2algorithm_8h"><td class="mdescLeft">&#160;</td><td class="mdescRight">Cipher algorithm definitions for the PSA Crypto API. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:crypto_8h"><td class="memItemLeft" align="right" valign="top">file &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="crypto_8h.html">crypto.h</a></td></tr>
<tr class="memdesc:crypto_8h"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function declarations for PSA Crypto. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:crypto__contexts_8h"><td class="memItemLeft" align="right" valign="top">file &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="crypto__contexts_8h.html">crypto_contexts.h</a></td></tr>
<tr class="memdesc:crypto__contexts_8h"><td class="mdescLeft">&#160;</td><td class="mdescRight">Context definitions for PSA Crypto. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:crypto__se__config_8h"><td class="memItemLeft" align="right" valign="top">file &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="crypto__se__config_8h.html">crypto_se_config.h</a></td></tr>
<tr class="memdesc:crypto__se__config_8h"><td class="mdescLeft">&#160;</td><td class="mdescRight">Define structures für SE slot configurations. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:crypto__sizes_8h"><td class="memItemLeft" align="right" valign="top">file &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="crypto__sizes_8h.html">crypto_sizes.h</a></td></tr>
<tr class="memdesc:crypto__sizes_8h"><td class="mdescLeft">&#160;</td><td class="mdescRight">Size definitions for PSA Crypto. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:crypto__struct_8h"><td class="memItemLeft" align="right" valign="top">file &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="crypto__struct_8h.html">crypto_struct.h</a></td></tr>
<tr class="memdesc:crypto__struct_8h"><td class="mdescLeft">&#160;</td><td class="mdescRight">Structure definitions for PSA Crypto. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:crypto__types_8h"><td class="memItemLeft" align="right" valign="top">file &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="crypto__types_8h.html">crypto_types.h</a></td></tr>
<tr class="memdesc:crypto__types_8h"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type definitions for PSA Crypto. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:crypto__values_8h"><td class="memItemLeft" align="right" valign="top">file &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="crypto__values_8h.html">crypto_values.h</a></td></tr>
<tr class="memdesc:crypto__values_8h"><td class="mdescLeft">&#160;</td><td class="mdescRight">Value definitions for PSA Crypto. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:hash_2algorithm_8h"><td class="memItemLeft" align="right" valign="top">file &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="hash_2algorithm_8h.html">algorithm.h</a></td></tr>
<tr class="memdesc:hash_2algorithm_8h"><td class="mdescLeft">&#160;</td><td class="mdescRight">Hash algorithm definitions for the PSA Crypto API. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:attributes_8h"><td class="memItemLeft" align="right" valign="top">file &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="attributes_8h.html">attributes.h</a></td></tr>
<tr class="memdesc:attributes_8h"><td class="mdescLeft">&#160;</td><td class="mdescRight">Key attributes definitions for the PSA Crypto API. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:bits_8h"><td class="memItemLeft" align="right" valign="top">file &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="bits_8h.html">bits.h</a></td></tr>
<tr class="memdesc:bits_8h"><td class="mdescLeft">&#160;</td><td class="mdescRight">Key size definitions for the PSA Crypto API. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:id_8h"><td class="memItemLeft" align="right" valign="top">file &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="id_8h.html">id.h</a></td></tr>
<tr class="memdesc:id_8h"><td class="mdescLeft">&#160;</td><td class="mdescRight">Key ID definitions for the PSA Crypto API. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:lifetime_8h"><td class="memItemLeft" align="right" valign="top">file &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="lifetime_8h.html">lifetime.h</a></td></tr>
<tr class="memdesc:lifetime_8h"><td class="mdescLeft">&#160;</td><td class="mdescRight">Key ilfetime definitions for the PSA Crypto API. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:psa__crypto_2psa_2key_2type_8h"><td class="memItemLeft" align="right" valign="top">file &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="psa__crypto_2psa_2key_2type_8h.html">type.h</a></td></tr>
<tr class="memdesc:psa__crypto_2psa_2key_2type_8h"><td class="mdescLeft">&#160;</td><td class="mdescRight">Key type definitions for the PSA Crypto API. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:usage_8h"><td class="memItemLeft" align="right" valign="top">file &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="usage_8h.html">usage.h</a></td></tr>
<tr class="memdesc:usage_8h"><td class="mdescLeft">&#160;</td><td class="mdescRight">Key usage definitions for the PSA Crypto API. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:key__agreement_2algorithm_8h"><td class="memItemLeft" align="right" valign="top">file &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="key__agreement_2algorithm_8h.html">algorithm.h</a></td></tr>
<tr class="memdesc:key__agreement_2algorithm_8h"><td class="mdescLeft">&#160;</td><td class="mdescRight">Key agreement algorithm definitions for the PSA Crypto API. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:key__derivation_2algorithm_8h"><td class="memItemLeft" align="right" valign="top">file &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="key__derivation_2algorithm_8h.html">algorithm.h</a></td></tr>
<tr class="memdesc:key__derivation_2algorithm_8h"><td class="mdescLeft">&#160;</td><td class="mdescRight">Key derivation algorithm definitions for the PSA Crypto API. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:mac_2algorithm_8h"><td class="memItemLeft" align="right" valign="top">file &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="mac_2algorithm_8h.html">algorithm.h</a></td></tr>
<tr class="memdesc:mac_2algorithm_8h"><td class="mdescLeft">&#160;</td><td class="mdescRight">MAC algorithm definitions for the PSA Crypto API. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:psa__crypto__operation__encoder_8h"><td class="memItemLeft" align="right" valign="top">file &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="psa__crypto__operation__encoder_8h.html">psa_crypto_operation_encoder.h</a></td></tr>
<tr class="memdesc:psa__crypto__operation__encoder_8h"><td class="mdescLeft">&#160;</td><td class="mdescRight">Macros used to map PSA algorithms, key types and key sizes to specific key types and operations to call the corresponding driver functions. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
</div><!-- contents -->
</div><!-- doc-content -->
    <div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
        <ul>
            <li class="footer">Generated on Wed Mar 12 2025 10:21:34 by <a href="http://www.doxygen.org/index.html">
                       <img class="footer" src="doxygen.png" alt="doxygen"></a> 1.8.14</li>
        </ul>
    </div>
    <!-- Include all compiled plugins (below), or include individual files as needed -->
    <script src="bootstrap.min.js"></script>
    <script src="jquery.smartmenus.min.js"></script>
    <script src="jquery.smartmenus.bootstrap.min.js"></script>
    <script src="riot-doxy.js"></script>
  </body>
</html>
